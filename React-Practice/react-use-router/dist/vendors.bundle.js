"use strict";
(self["webpackChunkreact_use_router"] = self["webpackChunkreact_use_router"] || []).push([["vendors"],{

/***/ "./node_modules/decode-uri-component/index.js":
/*!****************************************************!*\
  !*** ./node_modules/decode-uri-component/index.js ***!
  \****************************************************/
/***/ (function(module) {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
  try {
    // Try to decode the entire string first
    return decodeURIComponent(components.join(''));
  } catch (err) {// Do nothing
  }

  if (components.length === 1) {
    return components;
  }

  split = split || 1; // Split the array in 2 parts

  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher);

    for (var i = 1; i < tokens.length; i++) {
      input = decodeComponents(tokens, i).join('');
      tokens = input.match(singleMatcher);
    }

    return input;
  }
}

function customDecodeURIComponent(input) {
  // Keep track of all the replacements and prefill the map with the `BOM`
  var replaceMap = {
    '%FE%FF': "\uFFFD\uFFFD",
    '%FF%FE': "\uFFFD\uFFFD"
  };
  var match = multiMatcher.exec(input);

  while (match) {
    try {
      // Decode as big chunks as possible
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode(match[0]);

      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }

    match = multiMatcher.exec(input);
  } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else


  replaceMap['%C2'] = "\uFFFD";
  var entries = Object.keys(replaceMap);

  for (var i = 0; i < entries.length; i++) {
    // Replace all decoded components
    var key = entries[i];
    input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
  }

  return input;
}

module.exports = function (encodedURI) {
  if (typeof encodedURI !== 'string') {
    throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + _typeof(encodedURI) + '`');
  }

  try {
    encodedURI = encodedURI.replace(/\+/g, ' '); // Try the built in decoder first

    return decodeURIComponent(encodedURI);
  } catch (err) {
    // Fallback to a more advanced decoder
    return customDecodeURIComponent(encodedURI);
  }
};

/***/ }),

/***/ "./node_modules/filter-obj/index.js":
/*!******************************************!*\
  !*** ./node_modules/filter-obj/index.js ***!
  \******************************************/
/***/ (function(module) {



module.exports = function (obj, predicate) {
  var ret = {};
  var keys = Object.keys(obj);
  var isArr = Array.isArray(predicate);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];

    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
      ret[key] = val;
    }
  }

  return ret;
};

/***/ }),

/***/ "./node_modules/history/index.js":
/*!***************************************!*\
  !*** ./node_modules/history/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Action": function() { return /* binding */ Action; },
/* harmony export */   "createBrowserHistory": function() { return /* binding */ createBrowserHistory; },
/* harmony export */   "createHashHistory": function() { return /* binding */ createHashHistory; },
/* harmony export */   "createMemoryHistory": function() { return /* binding */ createMemoryHistory; },
/* harmony export */   "createPath": function() { return /* binding */ createPath; },
/* harmony export */   "parsePath": function() { return /* binding */ parsePath; }
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");

/**
 * Actions represent the type of change to a location value.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action
 */

var Action;

(function (Action) {
  /**
   * A POP indicates a change to an arbitrary index in the history stack, such
   * as a back or forward navigation. It does not describe the direction of the
   * navigation, only that the current index changed.
   *
   * Note: This is the default action for newly created history objects.
   */
  Action["Pop"] = "POP";
  /**
   * A PUSH indicates a new entry being added to the history stack, such as when
   * a link is clicked and a new page loads. When this happens, all subsequent
   * entries in the stack are lost.
   */

  Action["Push"] = "PUSH";
  /**
   * A REPLACE indicates the entry at the current index in the history stack
   * being replaced by a new one.
   */

  Action["Replace"] = "REPLACE";
})(Action || (Action = {}));

var readOnly =  true ? function (obj) {
  return Object.freeze(obj);
} : 0;

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== 'undefined') console.warn(message);

    try {
      // Welcome to debugging history!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}

var BeforeUnloadEventType = 'beforeunload';
var HashChangeEventType = 'hashchange';
var PopStateEventType = 'popstate';
/**
 * Browser history stores the location in regular URLs. This is the standard for
 * most web apps, but it requires some configuration on the server to ensure you
 * serve the same app at multiple URLs.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory
 */

function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$window = _options.window,
      window = _options$window === void 0 ? document.defaultView : _options$window;
  var globalHistory = window.history;

  function getIndexAndLocation() {
    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname: pathname,
      search: search,
      hash: hash,
      state: state.usr || null,
      key: state.key || 'default'
    })];
  }

  var blockedPopTx = null;

  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;

      var _getIndexAndLocation = getIndexAndLocation(),
          nextIndex = _getIndexAndLocation[0],
          nextLocation = _getIndexAndLocation[1];

      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;

          if (delta) {
            // Revert the POP
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        } else {
          // Trying to POP to a location with no index. We did not create
          // this location, so we can't effectively block the navigation.
           true ? warning(false, // TODO: Write up a doc that explains our blocking strategy in
          // detail and link to it here so people can understand better what
          // is going on and how to avoid it.
          "You are trying to block a POP navigation to a location that was not " + "created by the history library. The block will fail silently in " + "production, but in general you should do all navigation with the " + "history library (instead of using window.history.pushState directly) " + "to avoid this situation.") : 0;
        }
      } else {
        applyTx(nextAction);
      }
    }
  }

  window.addEventListener(PopStateEventType, handlePop);
  var action = Action.Pop;

  var _getIndexAndLocation2 = getIndexAndLocation(),
      index = _getIndexAndLocation2[0],
      location = _getIndexAndLocation2[1];

  var listeners = createEvents();
  var blockers = createEvents();

  if (index == null) {
    index = 0;
    globalHistory.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, globalHistory.state, {
      idx: index
    }), '');
  }

  function createHref(to) {
    return typeof to === 'string' ? to : createPath(to);
  } // state defaults to `null` because `window.history.state` does


  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }

    return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      pathname: location.pathname,
      hash: '',
      search: ''
    }, typeof to === 'string' ? parsePath(to) : to, {
      state: state,
      key: createKey()
    }));
  }

  function getHistoryStateAndUrl(nextLocation, index) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index
    }, createHref(nextLocation)];
  }

  function allowTx(action, location, retry) {
    return !blockers.length || (blockers.call({
      action: action,
      location: location,
      retry: retry
    }), false);
  }

  function applyTx(nextAction) {
    action = nextAction;

    var _getIndexAndLocation3 = getIndexAndLocation();

    index = _getIndexAndLocation3[0];
    location = _getIndexAndLocation3[1];
    listeners.call({
      action: action,
      location: location
    });
  }

  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      push(to, state);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),
          historyState = _getHistoryStateAndUr[0],
          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading
      // try...catch because iOS limits us to 100 pushState calls :/


      try {
        globalHistory.pushState(historyState, '', url);
      } catch (error) {
        // They are going to lose state here, but there is no real
        // way to warn them about it since the page will refresh...
        window.location.assign(url);
      }

      applyTx(nextAction);
    }
  }

  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      replace(to, state);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),
          historyState = _getHistoryStateAndUr2[0],
          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading


      globalHistory.replaceState(historyState, '', url);
      applyTx(nextAction);
    }
  }

  function go(delta) {
    globalHistory.go(delta);
  }

  var history = {
    get action() {
      return action;
    },

    get location() {
      return location;
    },

    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);

      if (blockers.length === 1) {
        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }

      return function () {
        unblock(); // Remove the beforeunload listener so the document may
        // still be salvageable in the pagehide event.
        // See https://html.spec.whatwg.org/#unloading-documents

        if (!blockers.length) {
          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
/**
 * Hash history stores the location in window.location.hash. This makes it ideal
 * for situations where you don't want to send the location to the server for
 * some reason, either because you do cannot configure it or the URL space is
 * reserved for something else.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory
 */


function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }

  var _options2 = options,
      _options2$window = _options2.window,
      window = _options2$window === void 0 ? document.defaultView : _options2$window;
  var globalHistory = window.history;

  function getIndexAndLocation() {
    var _parsePath = parsePath(window.location.hash.substr(1)),
        _parsePath$pathname = _parsePath.pathname,
        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,
        _parsePath$search = _parsePath.search,
        search = _parsePath$search === void 0 ? '' : _parsePath$search,
        _parsePath$hash = _parsePath.hash,
        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;

    var state = globalHistory.state || {};
    return [state.idx, readOnly({
      pathname: pathname,
      search: search,
      hash: hash,
      state: state.usr || null,
      key: state.key || 'default'
    })];
  }

  var blockedPopTx = null;

  function handlePop() {
    if (blockedPopTx) {
      blockers.call(blockedPopTx);
      blockedPopTx = null;
    } else {
      var nextAction = Action.Pop;

      var _getIndexAndLocation4 = getIndexAndLocation(),
          nextIndex = _getIndexAndLocation4[0],
          nextLocation = _getIndexAndLocation4[1];

      if (blockers.length) {
        if (nextIndex != null) {
          var delta = index - nextIndex;

          if (delta) {
            // Revert the POP
            blockedPopTx = {
              action: nextAction,
              location: nextLocation,
              retry: function retry() {
                go(delta * -1);
              }
            };
            go(delta);
          }
        } else {
          // Trying to POP to a location with no index. We did not create
          // this location, so we can't effectively block the navigation.
           true ? warning(false, // TODO: Write up a doc that explains our blocking strategy in
          // detail and link to it here so people can understand better
          // what is going on and how to avoid it.
          "You are trying to block a POP navigation to a location that was not " + "created by the history library. The block will fail silently in " + "production, but in general you should do all navigation with the " + "history library (instead of using window.history.pushState directly) " + "to avoid this situation.") : 0;
        }
      } else {
        applyTx(nextAction);
      }
    }
  }

  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge
  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event

  window.addEventListener(HashChangeEventType, function () {
    var _getIndexAndLocation5 = getIndexAndLocation(),
        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.


    if (createPath(nextLocation) !== createPath(location)) {
      handlePop();
    }
  });
  var action = Action.Pop;

  var _getIndexAndLocation6 = getIndexAndLocation(),
      index = _getIndexAndLocation6[0],
      location = _getIndexAndLocation6[1];

  var listeners = createEvents();
  var blockers = createEvents();

  if (index == null) {
    index = 0;
    globalHistory.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, globalHistory.state, {
      idx: index
    }), '');
  }

  function getBaseHref() {
    var base = document.querySelector('base');
    var href = '';

    if (base && base.getAttribute('href')) {
      var url = window.location.href;
      var hashIndex = url.indexOf('#');
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }

    return href;
  }

  function createHref(to) {
    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));
  }

  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }

    return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      pathname: location.pathname,
      hash: '',
      search: ''
    }, typeof to === 'string' ? parsePath(to) : to, {
      state: state,
      key: createKey()
    }));
  }

  function getHistoryStateAndUrl(nextLocation, index) {
    return [{
      usr: nextLocation.state,
      key: nextLocation.key,
      idx: index
    }, createHref(nextLocation)];
  }

  function allowTx(action, location, retry) {
    return !blockers.length || (blockers.call({
      action: action,
      location: location,
      retry: retry
    }), false);
  }

  function applyTx(nextAction) {
    action = nextAction;

    var _getIndexAndLocation7 = getIndexAndLocation();

    index = _getIndexAndLocation7[0];
    location = _getIndexAndLocation7[1];
    listeners.call({
      action: action,
      location: location
    });
  }

  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      push(to, state);
    }

     true ? warning(nextLocation.pathname.charAt(0) === '/', "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")") : 0;

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),
          historyState = _getHistoryStateAndUr3[0],
          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading
      // try...catch because iOS limits us to 100 pushState calls :/


      try {
        globalHistory.pushState(historyState, '', url);
      } catch (error) {
        // They are going to lose state here, but there is no real
        // way to warn them about it since the page will refresh...
        window.location.assign(url);
      }

      applyTx(nextAction);
    }
  }

  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      replace(to, state);
    }

     true ? warning(nextLocation.pathname.charAt(0) === '/', "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to) + ")") : 0;

    if (allowTx(nextAction, nextLocation, retry)) {
      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),
          historyState = _getHistoryStateAndUr4[0],
          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading


      globalHistory.replaceState(historyState, '', url);
      applyTx(nextAction);
    }
  }

  function go(delta) {
    globalHistory.go(delta);
  }

  var history = {
    get action() {
      return action;
    },

    get location() {
      return location;
    },

    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      var unblock = blockers.push(blocker);

      if (blockers.length === 1) {
        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
      }

      return function () {
        unblock(); // Remove the beforeunload listener so the document may
        // still be salvageable in the pagehide event.
        // See https://html.spec.whatwg.org/#unloading-documents

        if (!blockers.length) {
          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
        }
      };
    }
  };
  return history;
}
/**
 * Memory history stores the current location in memory. It is designed for use
 * in stateful non-browser environments like tests and React Native.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory
 */


function createMemoryHistory(options) {
  if (options === void 0) {
    options = {};
  }

  var _options3 = options,
      _options3$initialEntr = _options3.initialEntries,
      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,
      initialIndex = _options3.initialIndex;
  var entries = initialEntries.map(function (entry) {
    var location = readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      pathname: '/',
      search: '',
      hash: '',
      state: null,
      key: createKey()
    }, typeof entry === 'string' ? parsePath(entry) : entry));
     true ? warning(location.pathname.charAt(0) === '/', "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(entry) + ")") : 0;
    return location;
  });
  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);
  var action = Action.Pop;
  var location = entries[index];
  var listeners = createEvents();
  var blockers = createEvents();

  function createHref(to) {
    return typeof to === 'string' ? to : createPath(to);
  }

  function getNextLocation(to, state) {
    if (state === void 0) {
      state = null;
    }

    return readOnly((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      pathname: location.pathname,
      search: '',
      hash: ''
    }, typeof to === 'string' ? parsePath(to) : to, {
      state: state,
      key: createKey()
    }));
  }

  function allowTx(action, location, retry) {
    return !blockers.length || (blockers.call({
      action: action,
      location: location,
      retry: retry
    }), false);
  }

  function applyTx(nextAction, nextLocation) {
    action = nextAction;
    location = nextLocation;
    listeners.call({
      action: action,
      location: location
    });
  }

  function push(to, state) {
    var nextAction = Action.Push;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      push(to, state);
    }

     true ? warning(location.pathname.charAt(0) === '/', "Relative pathnames are not supported in memory history.push(" + JSON.stringify(to) + ")") : 0;

    if (allowTx(nextAction, nextLocation, retry)) {
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      applyTx(nextAction, nextLocation);
    }
  }

  function replace(to, state) {
    var nextAction = Action.Replace;
    var nextLocation = getNextLocation(to, state);

    function retry() {
      replace(to, state);
    }

     true ? warning(location.pathname.charAt(0) === '/', "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(to) + ")") : 0;

    if (allowTx(nextAction, nextLocation, retry)) {
      entries[index] = nextLocation;
      applyTx(nextAction, nextLocation);
    }
  }

  function go(delta) {
    var nextIndex = clamp(index + delta, 0, entries.length - 1);
    var nextAction = Action.Pop;
    var nextLocation = entries[nextIndex];

    function retry() {
      go(delta);
    }

    if (allowTx(nextAction, nextLocation, retry)) {
      index = nextIndex;
      applyTx(nextAction, nextLocation);
    }
  }

  var history = {
    get index() {
      return index;
    },

    get action() {
      return action;
    },

    get location() {
      return location;
    },

    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    back: function back() {
      go(-1);
    },
    forward: function forward() {
      go(1);
    },
    listen: function listen(listener) {
      return listeners.push(listener);
    },
    block: function block(blocker) {
      return blockers.push(blocker);
    }
  };
  return history;
} ////////////////////////////////////////////////////////////////////////////////
// UTILS
////////////////////////////////////////////////////////////////////////////////


function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}

function promptBeforeUnload(event) {
  // Cancel the event.
  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.

  event.returnValue = '';
}

function createEvents() {
  var handlers = [];
  return {
    get length() {
      return handlers.length;
    },

    push: function push(fn) {
      handlers.push(fn);
      return function () {
        handlers = handlers.filter(function (handler) {
          return handler !== fn;
        });
      };
    },
    call: function call(arg) {
      handlers.forEach(function (fn) {
        return fn && fn(arg);
      });
    }
  };
}

function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
/**
 * Creates a string URL path from the given pathname, search, and hash components.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath
 */


function createPath(_ref) {
  var _ref$pathname = _ref.pathname,
      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,
      _ref$search = _ref.search,
      search = _ref$search === void 0 ? '' : _ref$search,
      _ref$hash = _ref.hash,
      hash = _ref$hash === void 0 ? '' : _ref$hash;
  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;
  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;
  return pathname;
}
/**
 * Parses a string URL path into its separate pathname, search, and hash components.
 *
 * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath
 */


function parsePath(path) {
  var parsedPath = {};

  if (path) {
    var hashIndex = path.indexOf('#');

    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }

    var searchIndex = path.indexOf('?');

    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }

    if (path) {
      parsedPath.pathname = path;
    }
  }

  return parsedPath;
}



/***/ }),

/***/ "./node_modules/query-string/index.js":
/*!********************************************!*\
  !*** ./node_modules/query-string/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var strictUriEncode = __webpack_require__(/*! strict-uri-encode */ "./node_modules/strict-uri-encode/index.js");

var decodeComponent = __webpack_require__(/*! decode-uri-component */ "./node_modules/decode-uri-component/index.js");

var splitOnFirst = __webpack_require__(/*! split-on-first */ "./node_modules/split-on-first/index.js");

var filterObject = __webpack_require__(/*! filter-obj */ "./node_modules/filter-obj/index.js");

var isNullOrUndefined = function isNullOrUndefined(value) {
  return value === null || value === undefined;
};

var encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

function encoderForArrayFormat(options) {
  switch (options.arrayFormat) {
    case 'index':
      return function (key) {
        return function (result, value) {
          var index = result.length;

          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [].concat(_toConsumableArray(result), [[encode(key, options), '[', index, ']'].join('')]);
          }

          return [].concat(_toConsumableArray(result), [[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')]);
        };
      };

    case 'bracket':
      return function (key) {
        return function (result, value) {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [].concat(_toConsumableArray(result), [[encode(key, options), '[]'].join('')]);
          }

          return [].concat(_toConsumableArray(result), [[encode(key, options), '[]=', encode(value, options)].join('')]);
        };
      };

    case 'colon-list-separator':
      return function (key) {
        return function (result, value) {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [].concat(_toConsumableArray(result), [[encode(key, options), ':list='].join('')]);
          }

          return [].concat(_toConsumableArray(result), [[encode(key, options), ':list=', encode(value, options)].join('')]);
        };
      };

    case 'comma':
    case 'separator':
    case 'bracket-separator':
      {
        var keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
        return function (key) {
          return function (result, value) {
            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            } // Translate null to an empty string so that it doesn't serialize as 'null'


            value = value === null ? '' : value;

            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
            }

            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        };
      }

    default:
      return function (key) {
        return function (result, value) {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [].concat(_toConsumableArray(result), [encode(key, options)]);
          }

          return [].concat(_toConsumableArray(result), [[encode(key, options), '=', encode(value, options)].join('')]);
        };
      };
  }
}

function parserForArrayFormat(options) {
  var result;

  switch (options.arrayFormat) {
    case 'index':
      return function (key, value, accumulator) {
        result = /\[(\d*)\]$/.exec(key);
        key = key.replace(/\[\d*\]$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = {};
        }

        accumulator[key][result[1]] = value;
      };

    case 'bracket':
      return function (key, value, accumulator) {
        result = /(\[\])$/.exec(key);
        key = key.replace(/\[\]$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = [value];
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };

    case 'colon-list-separator':
      return function (key, value, accumulator) {
        result = /(:list)$/.exec(key);
        key = key.replace(/:list$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = [value];
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };

    case 'comma':
    case 'separator':
      return function (key, value, accumulator) {
        var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
        var isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
        value = isEncodedArray ? decode(value, options) : value;
        var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(function (item) {
          return decode(item, options);
        }) : value === null ? value : decode(value, options);
        accumulator[key] = newValue;
      };

    case 'bracket-separator':
      return function (key, value, accumulator) {
        var isArray = /(\[\])$/.test(key);
        key = key.replace(/\[\]$/, '');

        if (!isArray) {
          accumulator[key] = value ? decode(value, options) : value;
          return;
        }

        var arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(function (item) {
          return decode(item, options);
        });

        if (accumulator[key] === undefined) {
          accumulator[key] = arrayValue;
          return;
        }

        accumulator[key] = [].concat(accumulator[key], arrayValue);
      };

    default:
      return function (key, value, accumulator) {
        if (accumulator[key] === undefined) {
          accumulator[key] = value;
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };
  }
}

function validateArrayFormatSeparator(value) {
  if (typeof value !== 'string' || value.length !== 1) {
    throw new TypeError('arrayFormatSeparator must be single character string');
  }
}

function encode(value, options) {
  if (options.encode) {
    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
  }

  return value;
}

function decode(value, options) {
  if (options.decode) {
    return decodeComponent(value);
  }

  return value;
}

function keysSorter(input) {
  if (Array.isArray(input)) {
    return input.sort();
  }

  if (_typeof(input) === 'object') {
    return keysSorter(Object.keys(input)).sort(function (a, b) {
      return Number(a) - Number(b);
    }).map(function (key) {
      return input[key];
    });
  }

  return input;
}

function removeHash(input) {
  var hashStart = input.indexOf('#');

  if (hashStart !== -1) {
    input = input.slice(0, hashStart);
  }

  return input;
}

function getHash(url) {
  var hash = '';
  var hashStart = url.indexOf('#');

  if (hashStart !== -1) {
    hash = url.slice(hashStart);
  }

  return hash;
}

function extract(input) {
  input = removeHash(input);
  var queryStart = input.indexOf('?');

  if (queryStart === -1) {
    return '';
  }

  return input.slice(queryStart + 1);
}

function parseValue(value, options) {
  if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
    value = Number(value);
  } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
    value = value.toLowerCase() === 'true';
  }

  return value;
}

function parse(query, options) {
  options = Object.assign({
    decode: true,
    sort: true,
    arrayFormat: 'none',
    arrayFormatSeparator: ',',
    parseNumbers: false,
    parseBooleans: false
  }, options);
  validateArrayFormatSeparator(options.arrayFormatSeparator);
  var formatter = parserForArrayFormat(options); // Create an object with no prototype

  var ret = Object.create(null);

  if (typeof query !== 'string') {
    return ret;
  }

  query = query.trim().replace(/^[?#&]/, '');

  if (!query) {
    return ret;
  }

  var _iterator = _createForOfIteratorHelper(query.split('&')),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var param = _step.value;

      if (param === '') {
        continue;
      }

      var _splitOnFirst = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '='),
          _splitOnFirst2 = _slicedToArray(_splitOnFirst, 2),
          _key = _splitOnFirst2[0],
          _value = _splitOnFirst2[1]; // Missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters


      _value = _value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? _value : decode(_value, options);
      formatter(decode(_key, options), _value, ret);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  for (var _i = 0, _Object$keys = Object.keys(ret); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var value = ret[key];

    if (_typeof(value) === 'object' && value !== null) {
      for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {
        var k = _Object$keys2[_i2];
        value[k] = parseValue(value[k], options);
      }
    } else {
      ret[key] = parseValue(value, options);
    }
  }

  if (options.sort === false) {
    return ret;
  }

  return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce(function (result, key) {
    var value = ret[key];

    if (Boolean(value) && _typeof(value) === 'object' && !Array.isArray(value)) {
      // Sort object keys, not values
      result[key] = keysSorter(value);
    } else {
      result[key] = value;
    }

    return result;
  }, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = function (object, options) {
  if (!object) {
    return '';
  }

  options = Object.assign({
    encode: true,
    strict: true,
    arrayFormat: 'none',
    arrayFormatSeparator: ','
  }, options);
  validateArrayFormatSeparator(options.arrayFormatSeparator);

  var shouldFilter = function shouldFilter(key) {
    return options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
  };

  var formatter = encoderForArrayFormat(options);
  var objectCopy = {};

  for (var _i3 = 0, _Object$keys3 = Object.keys(object); _i3 < _Object$keys3.length; _i3++) {
    var key = _Object$keys3[_i3];

    if (!shouldFilter(key)) {
      objectCopy[key] = object[key];
    }
  }

  var keys = Object.keys(objectCopy);

  if (options.sort !== false) {
    keys.sort(options.sort);
  }

  return keys.map(function (key) {
    var value = object[key];

    if (value === undefined) {
      return '';
    }

    if (value === null) {
      return encode(key, options);
    }

    if (Array.isArray(value)) {
      if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
        return encode(key, options) + '[]';
      }

      return value.reduce(formatter(key), []).join('&');
    }

    return encode(key, options) + '=' + encode(value, options);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&');
};

exports.parseUrl = function (url, options) {
  options = Object.assign({
    decode: true
  }, options);

  var _splitOnFirst3 = splitOnFirst(url, '#'),
      _splitOnFirst4 = _slicedToArray(_splitOnFirst3, 2),
      url_ = _splitOnFirst4[0],
      hash = _splitOnFirst4[1];

  return Object.assign({
    url: url_.split('?')[0] || '',
    query: parse(extract(url), options)
  }, options && options.parseFragmentIdentifier && hash ? {
    fragmentIdentifier: decode(hash, options)
  } : {});
};

exports.stringifyUrl = function (object, options) {
  options = Object.assign(_defineProperty({
    encode: true,
    strict: true
  }, encodeFragmentIdentifier, true), options);
  var url = removeHash(object.url).split('?')[0] || '';
  var queryFromUrl = exports.extract(object.url);
  var parsedQueryFromUrl = exports.parse(queryFromUrl, {
    sort: false
  });
  var query = Object.assign(parsedQueryFromUrl, object.query);
  var queryString = exports.stringify(query, options);

  if (queryString) {
    queryString = "?".concat(queryString);
  }

  var hash = getHash(object.url);

  if (object.fragmentIdentifier) {
    hash = "#".concat(options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier);
  }

  return "".concat(url).concat(queryString).concat(hash);
};

exports.pick = function (input, filter, options) {
  options = Object.assign(_defineProperty({
    parseFragmentIdentifier: true
  }, encodeFragmentIdentifier, false), options);

  var _exports$parseUrl = exports.parseUrl(input, options),
      url = _exports$parseUrl.url,
      query = _exports$parseUrl.query,
      fragmentIdentifier = _exports$parseUrl.fragmentIdentifier;

  return exports.stringifyUrl({
    url: url,
    query: filterObject(query, filter),
    fragmentIdentifier: fragmentIdentifier
  }, options);
};

exports.exclude = function (input, filter, options) {
  var exclusionFilter = Array.isArray(filter) ? function (key) {
    return !filter.includes(key);
  } : function (key, value) {
    return !filter(key, value);
  };
  return exports.pick(input, exclusionFilter, options);
};

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */function _typeof(obj){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj;}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;},_typeof(obj);}if(true){(function(){'use strict';/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=__webpack_require__(/*! react */ "./node_modules/react/index.js");var Scheduler=__webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js");var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced
// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.
function warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also
// update consoleWithStackDev.www.js as well.
{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion
var argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix
argsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it
// breaks IE9: https://github.com/facebook/react/issues/13610
// eslint-disable-next-line react-internal/no-production-logging
Function.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class
var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------
var enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing
// the react-reconciler package.
var enableNewReconciler=false;// Support legacy Primer support on internal FB www
var enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.
var enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber
var enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz
// React DOM Chopping Block
//
// Similar to main Chopping Block but only flags related to React DOM. These are
// grouped because we will likely batch all of them into a single major release.
// -----------------------------------------------------------------------------
// Disable support for comment nodes as React DOM containers. Already disabled
// in open source, but www codebase still relies on it. Need to remove.
var disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.
// and client rendering, mostly to allow JSX attributes to apply to the custom
// element's object properties instead of only HTML attributes.
// https://github.com/facebook/react/issues/11347
var enableCustomElementPropertySupport=false;// Disables children for <textarea> elements
var warnAboutStringRefs=false;// -----------------------------------------------------------------------------
// Debugging and DevTools
// -----------------------------------------------------------------------------
// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,
// for an experimental timeline tool.
var enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState
var enableProfilerTimer=true;// Record durations for commit and passive effects phases.
var enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an "update" and a "cascading-update".
var allNativeEvents=new Set();/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
function registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */ // $FlowFixMe only called in DEV, so void return is not possible.
function typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant
var hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.
function willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's
// happened: you supplied an object or symbol value to React (as a prop, key,
// DOM attribute, CSS property, string ref, etc.) and when React tried to
// coerce it to a string using `'' + value`, an exception was thrown.
//
// The most common types that will cause this exception are `Symbol` instances
// and Temporal objects like `Temporal.Instant`. But any object that has a
// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
// exception. (Library authors do this to prevent users from using built-in
// numeric operators like `+` or comparison operators like `>=` because custom
// methods are needed to perform accurate arithmetic or comparison.)
//
// To fix the problem, coerce this object or symbol value to a string before
// passing it to React. The most reliable way is usually `String(value)`.
//
// To find which value is throwing, check the browser or debugger console.
// Before this exception was thrown, there should be `console.error` output
// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
// problem and how that type was used: key, atrribute, input value prop, etc.
// In most cases, this console output also shows the component and its
// ancestor components where the exception happened.
//
// eslint-disable-next-line react-internal/safe-string-coercion
return''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)
}}}// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED=0;// A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.
var STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.
var BOOLEANISH_STRING=2;// A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
var BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.
var OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.
var NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.
var POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+"\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(_typeof(value)){case'function':// $FlowIssue symbol is perfectly valid here
case'symbol':// eslint-disable-line
return true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
var properties={};// These props are reserved by React. They shouldn't be written to the DOM.
var reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.
[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.
['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML boolean attributes.
['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata
'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.
['checked',// Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.
['capture','download'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that must be positive numbers.
['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty
name,// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These are HTML attributes that must be numbers.
['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty
name.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.
['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,null,// attributeNamespace
false,// sanitizeURL
false);});// String SVG attributes with the xlink namespace.
['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL
false);});// String SVG attributes with the xml namespace.
['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL
false);});// These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.
['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
attributeName.toLowerCase(),// attributeName
null,// attributeNamespace
false,// sanitizeURL
false);});// These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.
var xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty
'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL
false);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
attributeName.toLowerCase(),// attributeName
null,// attributeNamespace
true,// sanitizeURL
true);});// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space
/* eslint-disable max-len */var isJavaScriptProtocol=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{// This check protects multiple uses of `expected`, which is why the
// react-internal/safe-string-coercion rule is disabled in several spots
// below.
{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if
// the hydration is successful of a javascript: URL, we
// still want to warn on the client.
// eslint-disable-next-line react-internal/safe-string-coercion
sanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion
if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion
}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}// If the prop isn't in the special list, treat it as a simple attribute.
if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyName]=value;}return;}// The rest are treated as attributes with special cases.
var attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink
// and we won't require Trusted Type here.
attributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION
var REACT_ELEMENT_TYPE=Symbol.for('react.element');var REACT_PORTAL_TYPE=Symbol.for('react.portal');var REACT_FRAGMENT_TYPE=Symbol.for('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol.for('react.strict_mode');var REACT_PROFILER_TYPE=Symbol.for('react.profiler');var REACT_PROVIDER_TYPE=Symbol.for('react.provider');var REACT_CONTEXT_TYPE=Symbol.for('react.context');var REACT_FORWARD_REF_TYPE=Symbol.for('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol.for('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol.for('react.suspense_list');var REACT_MEMO_TYPE=Symbol.for('react.memo');var REACT_LAZY_TYPE=Symbol.for('react.lazy');var REACT_SCOPE_TYPE=Symbol.for('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol.for('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol.for('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol.for('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol.for('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol.for('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||_typeof(maybeIterable)!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099
var props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.
Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.
Object.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.
try{throw Error();}catch(x){var match=x.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.
return'\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.
if(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.
Error.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function
// for warnings.
ReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.
if(construct){// Something should be setting the props in the constructor.
var Fake=function Fake(){throw Error();};// $FlowFixMe
Object.defineProperty(Fake.prototype,'props',{set:function set(){// We use a throwing setter instead of frozen or non-writable props
// because that won't throw in a non-strict mode function.
throw Error();}});if((typeof Reflect==="undefined"?"undefined":_typeof(Reflect))==='object'&&Reflect.construct){// We construct a different control for this case to include any extra
// frames added by the construct call.
try{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.
if(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.
// Skipping one frame that we assume is the frame that calls the two.
var sampleLines=sample.stack.split('\n');var controlLines=control.stack.split('\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.
// Typically this will be the root most one. However, stack frames may be
// cut off due to maximum stack limits. In this case, one maybe cut off
// earlier than the other. We assume that the sample is longer or the same
// and there for cut off earlier. So we should find the root most frame in
// the sample somewhere in the control.
c--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the
// frame that called our sample function and the control.
if(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.
// If we're about to return the first line, and the control is also on the same
// line, that's a pretty good indicator that our sample threw at same line as
// the control. I.e. before we entered the sample frame. So we ignore this result.
// This can happen if you passed a class to function component, or non-function.
if(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.
// The next one that isn't the same should be our match though.
if(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
var _frame='\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled "<anonymous>"
// but we have a user-provided "displayName"
// splice it in to make the stack more readable.
if(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.
return _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.
var name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.
return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.
return describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}catch(x){return'\nError generating stack: '+x.message+'\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+"("+functionName+")":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber
function getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.
function getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.
return null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough
}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+"("+functionName+")":wrapperName);}// Keep in sync with shared/getComponentNameFromType
function getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return'Fragment';case HostComponent:// Host component type is the display name (e.g. "div", "View")
return type;case HostPortal:return'Portal';case HostRoot:return'Root';case HostText:return'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.
return getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType
return'StrictMode';}return'Mode';case OffscreenComponent:return'Offscreen';case Profiler:return'Profiler';case ScopeComponent:return'Scope';case SuspenseComponent:return'Suspense';case SuspenseListComponent:return'SuspenseList';case TracingMarkerComponent:return'TracingMarker';// The display name for this tags come from the user-provided type:
case ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value){// The coercion safety check is performed in getToStringValue().
// eslint-disable-next-line react-internal/safe-string-coercion
return''+value;}function getToStringValue(value){switch(_typeof(value)){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings
return'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var _get=descriptor.get,_set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function get(){return _get.call(this);},set:function set(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;_set.call(this,value);}});// We could've passed this the first time
// but it triggers a bug in IE11 and Edge 14/15.
// Calling defineProperty() again should be equivalent.
// https://github.com/facebook/react/issues/11768
Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.
// eslint-disable-next-line
node.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid
// blank-text buttons.
node.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of
// properties:
//  1. The value React property
//  2. The defaultValue React property
//  3. Otherwise there should be no change
if(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs
// to be removed, such as transitioning from a checkbox into a text input
if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the
// default value provided by the browser. See: #12872
if(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(!isHydrating){{// When syncing the value attribute, the value property should use
// the wrapperState._initialValue property. This uses:
//
//   1. The value React property when present
//   2. The defaultValue React property when present
//   3. An empty string
if(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,
// so we assign defaultValue to the same thing as the value property
// assignment step above.
node.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and
// attribute are assigned at the same time using defaultChecked. This uses:
//
//   1. The checked React property when present
//   2. The defaultChecked React property when present
//   3. Otherwise, false
node.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
function setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js
type!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){{// If a value is not provided, then the children must be simple.
if(props.value==null){if(_typeof(props.children)==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.
if(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare
function isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp */ /**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}{checkCSSPropertyStringCoercion(value,name);}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function warnValidStyle(){};{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function camelize(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function warnHyphenatedStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests
// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
// is converted to lowercase `ms`.
camelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error("Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function warnValidStyle(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 */ /**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+"avoid this, don't mix shorthand and non-shorthand properties "+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.
};// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+" is a void element tag and must neither have `children` nor "+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(_typeof(props.dangerouslySetInnerHTML)!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&_typeof(props.style)!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+"not a string. For example, style={{marginRight: spacing + 'em'}} when "+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this list too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state
'aria-description':0,'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function validateProperty$1(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function validateProperty$1(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',_typeof(value));warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
error('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop
if((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string "false".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
// we call willDeferLaterForLegacyFBSupport, thus not bailing out
// will result in endless cycles like an infinite loop.
// We also don't want to defer during event replaying.
var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying
// and DOMPluginEventSystem.
var currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9
// https://github.com/facebook/react/issues/12506
var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.
if(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var batchedUpdatesImpl=function batchedUpdatesImpl(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function flushSyncImpl(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
var controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of
// the DOM node back to the controlled value. This is necessary when React
// bails out of the update without touching the DOM.
// TODO: Restore state in the microtask, after the discrete updates flush,
// instead of early flushing them here.
flushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state.
return fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync
function setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.
return null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error("Expected `"+registrationName+"` listener to be a function, instead got a value of `"+_typeof(listener)+"` type.");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners
// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
if(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value
Object.defineProperty(options,'passive',{get:function get(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// unintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method
// when we call document.createEvent(). However this can cause confusing
// errors: https://github.com/facebook/create-react-app/issues/3482
// So we preemptively throw with a better message instead.
if(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Keeps track of the value of window.event so that we can reset it
// during the callback to let user code access window.event in the
// browsers that support it.
var windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event
// dispatching: https://github.com/facebook/react/issues/13688
var windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the
// window.event assignment in both IE <= 10 as they throw an error
// "Member not found" in strict mode, and in Firefox which does not
// support window.event.
if(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.
// Browsers silence the error report if this happens.
// We'll remember this to later decide whether to log it or not.
if(error!=null&&_typeof(error)==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.
}}}}// Create a fake event type.
var evtType="react-"+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.
// eslint-disable-next-line react-internal/prod-error-codes
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes
error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners
window.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.
// https://github.com/facebook/react/issues/16734
// https://github.com/facebook/react/issues/16585
// Fall back to the production implementation.
restoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.
var hasRethrowError=false;var rethrowError=null;var reporter={onError:function onError(error){hasError=true;caughtError=error;}};/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.
var NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).
var Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)
var HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.
var Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,
// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).
// This enables us to defer more work in the unmount case,
// since we can defer traversing the tree during layout to look for Passive effects,
// and instead rely on the static flag as a signal that there may be cleanup work.
var RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount
// without traversing the entire tree after every commit for
// double invoking
var MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that
// don't contain effects, by checking subtreeFlags.
var BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility
// flag logic (see #20043)
Update|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask
var PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.
// This allows certain concepts to persist without recalculating them,
// e.g. whether a subtree contains passive effects or portals.
var StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
var nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible
// mounted fiber is the parent but we need to continue to figure out
// if that one is still mounted.
nearestMounted=node.return;}nextNode=node.return;}while(nextNode);}else{while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a.return;if(parentA===null){// We're at the root.
break;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only
// happens when a Suspense component is hidden. An extra fragment fiber
// is inserted in between the Suspense fiber and its children. Skip
// over this extra fragment fiber and proceed to the next parent.
var nextParent=parentA.return;if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
throw new Error('Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error("Return fibers should always be each others' alternates. "+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
if(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.
if(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.
if(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS
var scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*
// on scheduler/unstable_mock, which we'll need for internal testing
var unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.
// This gives DevTools a way to feature detect that isn't tied to version number
// (since profiling and timeline are controlled by different feature flags).
internals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
injectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.
return true;}else{// This is likely a hook installed by Fast Refresh runtime.
return false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists
// in SchedulerMock. To reduce the noise in strict mode tests,
// suppress warnings and disable scheduler yielding during the double render
unstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks
function injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead
var ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.
var clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.
// Based on:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32
var log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.
var TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)
// It should be kept in sync with the Lanes values above.
function getLabelForLane(lane){{if(lane&SyncLane){return'Sync';}if(lane&InputContinuousHydrationLane){return'InputContinuousHydration';}if(lane&InputContinuousLane){return'InputContinuous';}if(lane&DefaultHydrationLane){return'DefaultHydration';}if(lane&DefaultLane){return'Default';}if(lane&TransitionHydrationLane){return'TransitionHydration';}if(lane&TransitionLanes){return'Transition';}if(lane&RetryLanes){return'Retry';}if(lane&SelectiveHydrationLane){return'SelectiveHydration';}if(lane&IdleHydrationLane){return'IdleHydration';}if(lane&IdleLane){return'Idle';}if(lane&OffscreenLane){return'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.
return lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.
var pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,
// even if the work is suspended.
var nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else{// The only remaining work is Idle.
var unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended
// TODO: Consider warning in this path if a fallback timer is not scheduled.
return NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt
// it and we'll lose our progress. We should only do this if the new lanes are
// higher priority.
if(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't
// bother waiting until the root is complete.
(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip
// one. This works because the bits decrease in priority as you go left.
nextLane>=wipLane||// Default priority updates should not interrupt transition updates. The
// only difference between default updates and transition updates is that
// default updates do not support refresh transitions.
nextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.
return wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates
// and default updates, so they render in the same batch. The only reason
// they use separate lanes is because continuous updates should interrupt
// transitions, but default updates should not.
nextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.
//
// A lane is said to be entangled with another when it's not allowed to render
// in a batch that does not also include the other lane. Typically we do this
// when multiple updates have the same source, and we only want to respond to
// the most recent event from that source.
//
// Note that we apply entanglements *after* checking for partial work above.
// This means that if a lane is entangled during an interleaved event while
// it's already rendering, we won't interrupt it. This is intentional, since
// entanglement is usually "best effort": we'll try our best to render the
// lanes in the same batch, but it's not worth throwing out partially
// completed work in order to do it.
// TODO: Reconsider this. The counter-argument is that the partial work
// represents an intermediate state, which we don't want to show to the user.
// And by spending extra time finishing it, we're increasing the amount of
// time it takes to show the final state, which is what they are actually
// waiting for.
//
// For those exceptions where entanglement is semantically important, like
// useMutableSource, we should ensure that there is no partial work at the
// time we apply the entanglement.
var entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.
//
// NOTE: This is set to the corresponding constant as in Scheduler.js.
// When we made it larger, a product metric in www regressed, suggesting
// there's a user interaction that's being starved by a series of
// synchronous updates. If that theory is correct, the proper solution is
// to fix the starvation. However, this scenario supports the idea that
// expiration times are an important safeguard when starvation
// does happen.
return currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for
// too long, but when I made this change it caused a spike in browser
// crashes. There must be some other underlying bug; not super urgent but
// ideally should figure out why and fix it. Unfortunately we don't have
// a repro for the crashes, only detected via production metrics.
return NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.
return NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing
// the earliest expiration time on the root. Then use that to quickly bail out
// of this function.
var pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their
// expiration time. If so, we'll assume the update is being starved and mark
// it as expired to force it to finish.
var lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or
// if it's pinged, assume it's CPU-bound. Compute a new expiration time
// using the current time.
if((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.
expirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired
root.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they
// are suspended.
function getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return(lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can
// expire after a render has already started.
return(lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return(lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.
// In most cases, this means every transition gets its own lane, until we
// run out of lanes and cycle back to the beginning.
var lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it
// doesn't matter which bit is selected; you can pick any bit without
// affecting the algorithms where its used. Here I'm using
// getHighestPriorityLane because it requires the fewest operations.
return getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for
// updates) to a group of lanes (used for flushing work).
function laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.
return a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.
// https://v8.dev/blog/elements-kinds#avoid-creating-holes
var laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update
// could unblock them. Clear the suspended lanes so that we can try rendering
// them again.
//
// TODO: We really only need to unsuspend only lanes that are in the
// `subtreeLanes` of the updated fiber, or the update lanes of the return
// path. This would exclude suspended updates in an unrelated sibling tree,
// since there's no way for this update to unblock it.
//
// We don't do this if the incoming update is idle, because we never process
// idle updates until after all the regular updates have finished; there's no
// way it could unblock a transition.
if(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most
// recent event, and we assume time is monotonically increasing.
eventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.
var expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again
root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work
var lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also
// have to consider _transitive_ entanglements. For each lane that is already
// entangled with *any* of the given lanes, that lane is now transitively
// entangled with *all* the given lanes.
//
// Translated: If C is entangled with A, then entangling A with B also
// entangles C with B.
//
// If this is hard to grasp, it might help to intentionally break this
// function and look at the tests that fail in ReactTransition-test.js. Try
// commenting out one of the conditions below.
var rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?
lane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?
entanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't
// be retried at a hydration lane.
lane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we
// already attempted and failed to hydrate at that level. Also check if we're
// already rendering that lane, which is rare but could happen.
if((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.
return NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's
// in a separate file to break a circular dependency between the renderer and
// the reconciler.
function isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that
// has this definition built-in.
var hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.
var queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.
// if the last target was dehydrated.
var queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.
var queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.
var queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase
'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.
attemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because
// the different event systems have different DOM event listeners.
// We can accumulate the flags, and the targetContainers, and
// store a single event to be replayed.
existingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we
// moved from outside the window (no target) onto the target once it hydrates.
// Instead of mutating we could clone the event.
switch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.
function attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.
// Try to unify them. It's a bit tricky since it would require two return
// values.
var targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.
// Increase its priority.
queuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of
// a root other than sync.
return;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React
// event system but not native events. Should read window.event.type, like
// we do for updates (getCurrentEventPriority).
var updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than
if(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else{// We're still blocked. Try again later.
var _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.
targetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map.delete(key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are
// now unblocked. This first might not actually be unblocked yet.
// We could check it early to avoid scheduling an unnecessary callback.
Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked
// and eligible for a replay.
if(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's
// worth it because we expect very few discrete events to queue up and once
// we are actually fully unblocked it will be fast to replay them.
for(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function unblock(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.
break;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.
queuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?
var _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.
// We'd like to remove this but it's not clear if this is safe.
function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because
// queueing is accumulative.
clearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,
// in case the event system needs to trace it.
dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.
// The return_targetInst field above is conceptually part of the return value.
function findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.
return_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.
targetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we
// don't want this event dispatched twice through the event system.
// TODO: If this is the first discrete event in the queue. Schedule an increased
// priority for this boundary.
return instance;}// This shouldn't happen, something went wrong but to avoid blocking
// the whole system, dispatch the event without a target.
// TODO: Warn.
targetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block
// the whole system.
return getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.
return null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:
case'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:
// eslint-disable-next-line no-fallthrough
case'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:
// eslint-disable-next-line no-fallthrough
case'beforeblur':case'afterblur':// Not used by React but could be by user code:
// eslint-disable-next-line no-fallthrough
case'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:
// eslint-disable-next-line no-fallthrough
case'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.
// Eventually this mechanism will be replaced by a check
// of the current priority on the native scheduler.
var schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
return DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
// report Enter as charCode 10 when ctrl is pressed.
if(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.
// If we had a single constructor, it would be megamorphic and engines would deopt.
function createSyntheticEvent(Interface){/**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE
}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE
}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */persist:function persist(){// Modern event system doesn't use pooling.
},/**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function relatedTarget(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function movementX(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function movementY(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here
// because it's guaranteed to have already run when movementX
// was copied.
return lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */ // Happens to share the same list for now.
var SyntheticInputEvent=SyntheticCompositionEvent;/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(_typeof(detail)==='object'&&'data'in detail){return detail.data;}return null;}/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to ignore it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'keypress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=(eventName in document);if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.
enqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur
setDefaultValue(node,'number',node.value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched
// the event in the out event of the other target. If this is replayed,
// then it's because we couldn't dispatch against this target previously
// so we have to do it now instead.
var related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have
// already dispatched the corresponding events during its mouseout.
if(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.
return;}var win;// TODO: why is this nullable in the types but we read from it?
if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing
// the first ancestor. Next time, we will ignore the event.
var nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare
;}var objectIs=typeof Object.is==='function'?Object.is:is;/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(_typeof(objA)!=='object'||objA===null||_typeof(objB)!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.
for(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with "Object expected" in some scenarios.
// (For instance: TinyMCE editor used in a list component that supports pasting to add more,
// fails when pasting 100+ items)
if(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser
// to throw, e.g. if it has a cross-origin src attribute.
// Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
// iframe.contentDocument.defaultView;
// A safety way is to access one of the cross origin properties: Window or Location
// Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
return typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */ /**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Get document associated with the event target.
 */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
var doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.
var currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.
case'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'selectionchange':if(skipSelectionChangeEvent){break;}// falls through
case'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!
//
// E.g. it needs "pointerDown", not "pointerdown".
// This is because we derive both React name ("onPointerDown")
// and DOM name ("pointerdown") from the same list.
//
// Exceptions that don't match this convention are listed separately.
//
// prettier-ignore
var simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.
registerSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.
// In the past, React has always bubbled them, but this can be surprising.
// We're going to try aligning closer to the browser behavior by not bubbling
// them in React either. We'll start by not bubbling onScroll, and then expand.
var accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from
// nonDelegatedEvents list in DOMPluginEventSystem.
// Then we can remove this special list.
// This is a breaking change that can wait until React 18.
domEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.
var _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.
registerSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a "SimpleEventPlugin".
// This is the basic functionality of the event system. All
// the other plugins are essentially polyfills. So the plugin
// should probably be inlined somewhere and have its logic
// be core the to event system. This would potentially allow
// us to ship builds of React without the polyfilled plugins below.
extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the
// event's native "bubble" phase, which means that we're
// not in the capture phase. That's because we emulate
// the capture phase here still. This is a trade-off,
// because in an ideal world we would not emulate and use
// the phases properly, like we do with the SimpleEvent
// plugin. However, the plugins below either expect
// emulation (EnterLeave) or use state localized to that
// plugin (BeforeInput, Change, Select). The state in
// these modules complicates things, as you'll essentially
// get the case where the capture phase event might change
// state, only for the following bubble event to come in
// later and not trigger anything as the state now
// invalidates the heuristics of the event plugin. We
// could alter all these plugins to work in such ways, but
// that might cause other unknown side-effects that we
// can't foresee right now.
if(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.
var mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather
// set them on the actual target element itself. This is primarily
// because these events do not consistently bubble in the DOM.
var nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.
}// This would be a good time to rethrow if any of the event handlers threw.
rethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for "%s". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the
var listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it
// doesn't bubble and needs to be on the document.
if(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication
// but it is attached to the document.
if(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be
// active and not passive.
var isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events
// passive by default on document. React doesn't bind them
// to document anymore, but changing this now would undo
// the performance wins from the change. So we emulate
// the existing behavior manually on the roots now.
// https://github.com/facebook/react/issues/19651
if(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we
if(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we
if(targetInst!==null){// The below logic attempts to work out if we need to change
// the target fiber to a different ancestor. We had similar logic
// in the legacy event system, except the big difference between
// systems is that the modern event system now has an event listener
// attached to each React Root and React Portal Root. Together,
// the DOM nodes representing these roots are the "rootContainer".
// To figure out which ancestor instance we should use, we traverse
// up the fiber tree from the target instance and attempt to find
// root boundaries that match that of our current "rootContainer".
// If we find that "rootContainer", we find the parent fiber
// sub-tree for that root and make that our ancestor instance.
var node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.
// Normally portals handle their own events all the way down to the root.
// So we should be able to stop now. However, we don't know if this portal
// was part of *our* root.
var grandNode=node.return;while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as
// a parent of the Portal. That means we can ignore it because the
// Portal will bubble through to us.
return;}}grandNode=grandNode.return;}}// Now we need to find it's corresponding host fiber in the other
// tree. To do this we can use getClosestInstanceFromNode, but we
// need to validate that the fiber is a host instance, otherwise
// we need to traverse up through the DOM till we find the correct
// node that is from the other tree.
while(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node.return;}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.
while(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)
if(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners
if(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't
// continue to propagate through the React fiber tree to find other
// listeners.
if(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take
instance=instance.return;}return listeners;}// We should only use this function for:
// - BeforeInputEventPlugin
// - ChangeEventPlugin
// - SelectEventPlugin
// This is because we only process these plugins
// in the bubble phase, so we need to accumulate two
// phase event listeners (via emulation).
function accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.
while(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)
if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance.return;}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance.return;}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:
// - EnterLeaveEventPlugin
// This is because we only process this plugin
// in the bubble phase, so we need to accumulate two
// phase event listeners.
function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+"__"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.
dialog:true,// Electron ships a custom <webview> tag to display external web content in
// an isolated frame and process.
// This tag is not present in non Electron environments such as JSDom which
// is often used for testing purposes.
// @see https://electronjs.org/docs/api/webview-tag
webview:true};validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other
// browsers. It adds spaces and sorts the properties in some
// non-alphabetical order. Handling that would require sorting CSS
// properties in the client & server versions or applying
// `expectedStyle` to a temporary DOM node to read its `style` attribute
// normalized. Since it only affects IE, we're skipping style warnings
// in that browser completely in favor of doing all that work.
// See https://github.com/facebook/react/issues/11807
canDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,_typeof(listener));}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to
// client rendering, up to the nearest Suspense boundary.
throw new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML
// tags get no namespace.
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
if(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
// attributes on `select`s needs to be added before `option`s are inserted.
// This prevents:
// - a bug where the `select` does not scroll to the correct option because singular
//  `select` elements automatically pick the first item #13222
// - a bug where the `select` set the first item as selected despite the `size` attribute #14239
// See https://github.com/facebook/react/issues/13222
// and https://github.com/facebook/react/issues/14239
if(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where
// it is possible that no option is selected.
//
// This is only necessary when a select in "single selection mode".
node.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the load event.
listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble
// listeners still fire for all the media events.
for(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the error event.
listenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble
// listeners still fire for error and load events.
listenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the toggle event.
listenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the allowed property list in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the allowed property list during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the load event.
listenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble
// listeners still fire for all the media events.
for(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the error event.
listenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble
// listeners still fire for error and load events.
listenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble
// listeners still fire for the toggle event.
listenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble
// listeners still fire for the invalid event.
listenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)
typeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.
var serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will
// be successfully parsed from HTML, but will produce a mismatch
// (and would be incorrectly rendered on the client).
// However, we already warn about bad casing elsewhere.
// So we'll skip the misleading extra mismatch warning in this case.
isMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function validateDOMNesting(){};var updatedAncestorInfo=function updatedAncestorInfo(){};{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function updatedAncestorInfo(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.
var scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------
var scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.
function handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------
function commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only
// fires if there is an `Update` effect scheduled during mounting.
// This happens if `finalizeInitialChildren` returns `true` (which it
// does to implement the `autoFocus` attribute on the client). But
// there are also other cases when this might happen (such as patching
// up text content during hydration mismatch). So we'll check this again.
switch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.
// If something inside a portal is clicked, that click should bubble
// through the React tree. However, on Mobile Safari the click would
// never bubble through the *DOM* tree unless an ancestor with onclick
// event exists. So we wouldn't see it and dispatch it.
// This is why we ensure that non React root containers have inline onclick
// defined.
// https://github.com/facebook/react/issues/11918
var reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.
retryIfBlockedOn(suspenseInstance);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.
// Retry if any event replaying was blocked on this.
retryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.
retryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we
// pass host context to this method?
instance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){var body=container.body;if(body!=null){body.textContent='';}}}// -------------------
function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a suspense node.
return instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.
for(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete
// when the legacy root API is removed.
var isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete
// when the legacy root API is removed.
var isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.
return null;}// Returns the SuspenseInstance if this node is a direct child of a
// SuspenseInstance. I.e. if its previous sibling is a Comment with
// SUSPENSE_x_START_DATA. Otherwise, null.
function getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.
retryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.
retryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.
var parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.
var parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.
var parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be
// able to remove it.
error('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of
// these fields are relevant.
delete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
// If the target node is part of a hydrated or not yet rendered subtree, then
// this may also return a SuspenseComponent or HostRoot to indicate that.
// Conceptually the HostRoot fiber is a child of the Container node. So if you
// pass the Container node as the targetNode, you will not actually get the
// HostRoot back. To get to the HostRoot, you need to pass a child of it.
// The same thing applies to Suspense boundaries.
function getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.
return targetInst;}// If the direct event target isn't a React owned DOM node, we need to look
// to see if one of its parents is a React owned DOM node.
var parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include
// React nodes in the future. We need to check this first because
// if we're a child of a dehydrated container, we need to first
// find that inner container before moving on to finding the parent
// instance. Note that we don't check this field on  the targetNode
// itself because the fibers are conceptually between the container
// node and the first child. It isn't surrounding the container node.
// If it's not a container, we check if it's an instance.
targetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have
// stepped past dehydrated DOM nodes to get here. However they could
// also have been non-React nodes. We need to answer which one.
// If we the instance doesn't have any children, then there can't be
// a nested suspense boundary within it. So we can use this as a fast
// bailout. Most of the time, when people add non-React children to
// the tree, it is using a ref to a child-less DOM node.
// Normally we'd only need to check one of the fibers because if it
// has ever gone from having children to deleting them or vice versa
// it would have deleted the dehydrated boundary nested inside already.
// However, since the HostRoot starts out with an alternate it might
// have one on the alternate so we need to check in case this was a
// root.
var alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is
// nested within a dehydrated boundary and if so, which one.
var suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't
// hydrated it yet. Even though we leave the comments in the
// DOM after hydrating, and there are boundaries in the DOM
// that could already be hydrated, we wouldn't have found them
// through this pass since if the target is hydrated it would
// have had an internalInstanceKey on it.
// Let's get the fiber associated with the SuspenseComponent
// as the deepest instance.
var targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because
// we haven't gotten to hydrate it yet. There might still be a
// parent boundary that hasn't above this one so we need to find
// the outer most that is known.
suspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent
// host component also hasn't hydrated yet. We can return it
// below since it will bail out on the isMounted check later.
}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
throw new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.
var has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to
// fail the render phase where it didn't fail before. So we log it.
// After these have been cleaned up, we'll let them throw.
try{// This is intentionally an invariant that gets caught. It's the same
// behavior as without this statement except with a better message.
if(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes
var err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+_typeof(typeSpecs[typeSpecName])+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,_typeof(error$1));setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the
// same error.
loggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context
// we may have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+".getChildContext(): key \""+contextKey+"\" is not defined in childContextTypes.");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
if(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in
// the next tick, or earlier if something calls `flushSyncCallbackQueue`.
if(syncQueue===null){syncQueue=[callback];}else{// Push onto existing queue. Don't need to schedule a callback because
// we already scheduled one when we created the queue.
syncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.
// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So
// it might make more sense for the queue to be a list of roots instead of a
// list of generic callbacks. Then we can have two: one for legacy roots, one
// for concurrent roots. And this method would only flush the legacy ones.
if(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.
isFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this
// queue is in the render or commit phases.
setCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.
if(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick
scheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function recordUnsafeLifecycleWarnings(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function flushPendingUnsafeLifecycleWarnings(){},recordLegacyContextWarning:function recordLegacyContextWarning(fiber,instance){},flushLegacyContextWarning:function flushLegacyContextWarning(){},discardPendingWarnings:function discardPendingWarnings(){}};{var findStrictRoot=function findStrictRoot(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};var setToSortedString=function setToSortedString(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.
var didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.
if(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.
instance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names
var componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings
// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
if(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'+'\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+"* If you're updating state whenever props change, "+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n'+'\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+'\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+"* If you're updating state whenever props change, refactor your "+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n'+'* Move data fetching code or side effects to componentDidUpdate.\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n'+'\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.
var didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.
if(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\n\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement
var props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context
rendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`
// cannot be called outside the render phase.
currentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.
var node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node.return;}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
fiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.
var list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.
if(dependency.context===context){// Match! Schedule an update on this fiber.
if(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.
var lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the
// update to the current fiber, too, which means it will persist even if
// this render is thrown away. Since it's a race condition, not sure it's
// worth fixing.
// Inlined `enqueueUpdate` to remove interleaved update check
var updateQueue=fiber.updateQueue;if(updateQueue===null);else{var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,workInProgress);// Mark the updated lanes on the list, too.
list.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the
// dependency list.
break;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider
nextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know
// if it will have any context consumers in it. The best we can do is
// mark it as having updates.
var parentSuspense=fiber.return;if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent
// because we want to schedule this fiber as having work
// on its children. We'll use the childLanes on
// this fiber to indicate that a context has changed.
scheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else{// Traverse down.
nextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
nextFiber.return=fiber;}else{// No child. Traverse to next sibling.
nextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.
nextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.
sibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.
nextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.
markWorkInProgressReceivedUpdate();}// Reset the work-in-progress list
dependencies.firstContext=null;}}}}function _readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.
// Unlike the class check below, it's not enforced in production for perf.
if(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else{var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.
lastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else{// Append a new context item.
lastContextDependency=lastContextDependency.next=contextItem;}}return value;}// An array of all update queues that received updates during the current
// render. When this render exits, either because it finishes or because it is
// interrupted, the interleaved updates will be transferred onto the main part
// of the queue.
var interleavedQueues=null;function pushInterleavedQueue(queue){if(interleavedQueues===null){interleavedQueues=[queue];}else{interleavedQueues.push(queue);}}function hasInterleavedUpdates(){return interleavedQueues!==null;}function enqueueInterleavedUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a
// `pending` field and an `interleaved` field. When they are not null, they
// point to the last node in a circular linked list. We need to append the
// interleaved list to the end of the pending list by joining them into a
// single, circular list.
if(interleavedQueues!==null){for(var i=0;i<interleavedQueues.length;i++){var queue=interleavedQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}interleavedQueues=null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.
var hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.
var queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.
return;}var sharedQueue=updateQueue.shared;if(isInterleavedUpdate(fiber)){var interleaved=sharedQueue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.
update.next=update;// At the end of the current render, this queue's interleaved updates will
// be transferred to the pending queue.
pushInterleavedQueue(sharedQueue);}else{update.next=interleaved.next;interleaved.next=update;}sharedQueue.interleaved=update;}else{var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.
return;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must
// have finished. We can remove them from the shared queue, which represents
// a superset of the actually pending lanes. In some cases we may entangle
// more than we need to, but that's OK. In fact it's worse if we *don't*
// entangle when we should.
queueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.
var newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if
// the lane finished since the last time we entangled it. So we need to
// entangle it again, just to be sure.
markRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render
// phase. They should be discarded if the render is aborted. Therefore,
// we should only put them on the work-in-progress queue, not the current one.
var queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.
var current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when
// we bail out on a parent fiber that then captures an error thrown by
// a child. Since we want to append the update only to the work-in
// -progress queue, we need to clone the updates. We usually clone during
// processUpdateQueue, but that didn't happen in this case because we
// skipped over the parent when we bailed out.
var newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.
var update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.
if(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.
newFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.
var lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function
{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object
return payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough
case UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function
{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else{// Partial state object
partialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.
return prevState;}// Merge the partial state and the previous state.
return assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot
var queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.
var pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first
// and last so that it's non-circular.
var lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue
if(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then
// we need to transfer the updates to that queue, too. Because the base
// queue is a singly-linked list with no cycles, we can append to both
// lists and take advantage of structural sharing.
// TODO: Pass `current` as argument
var current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot
var currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.
if(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.
var newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes
// from the original lanes.
var newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first
// skipped update, the previous update/state is the new base
// update/state.
var clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.
newLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.
if(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit
// it. Using NoLane works because 0 is a subset of all bitmasks, so
// this will never be skipped by the check above.
lane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.
newState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its
// callback again.
update.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new
// pending updates to the end of the list and keep processing.
var _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we
// unravel them when transferring them to the base queue.
var _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to
// process them during this render, but we do need to track which lanes
// are remaining.
var lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to
// zero once the queue is empty.
queue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.
// This should be fine because the only two other things that contribute to
// expiration time are props and context. We're already in the middle of the
// begin phase by the time we start processing the queue, so we've already
// dealt with the props. Context in components that specify
// shouldComponentUpdate is tricky; but we'll have to account for
// that regardless.
markSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+("received: "+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects
var effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var fakeInternalInstance={};// React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.
var emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function warnOnUndefinedDerivedState(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+"unstable_renderSubtreeIntoContainer, which isn't supported. Try "+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.
partialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.
var memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the
// base state.
if(workInProgress.lanes===NoLanes){// Queue is always non-null for classes
var updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function enqueueSetState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function enqueueReplaceState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function enqueueForceUpdate(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.
shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(_typeof(_state)!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&_typeof(ctor.childContextTypes)!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration
contextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>
if(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(_typeof(contextType)!=='object'){addendum=' However, it is set to a '+_typeof(contextType)+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>
addendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(_typeof(contextType)==='object'&&contextType!==null){context=_readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.
{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new
}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, "unsafe" lifecycles won't be called.
// Warn about these lifecycles if they are present.
// Don't warn about react-lifecycles-compat polyfilled methods though.
if(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n'+'The above lifecycles should be removed. Learn more about this warning here:\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?"\n  "+foundWillMountName:'',foundWillReceivePropsName!==null?"\n  "+foundWillReceivePropsName:'',foundWillUpdateName!==null?"\n  "+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(_typeof(contextType)==='object'&&contextType!==null){instance.context=_readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+"because updates to props won't be reflected in state. "+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
processUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the
// memoized state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,
// both before and after `shouldComponentUpdate` has been called. Not ideal,
// but I'm loath to refactor this function. This only happens for memoized
// components so it's not that common.
enableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// TODO: Use the unified fiber stack module instead of this local one?
// Intentionally not using it yet to derisk the initial implementation, because
// the way we push/pop these values is a bit unusual. If there's a mistake, I'd
// rather the ids be wrong than crash the whole reconciler.
var forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return(workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child
// fibers, because that's the only place where we know how many children in
// the whole set without doing extra work later, or storing addtional
// information on the fiber.
//
// That's why this function is separate from pushTreeId — it's called during
// the render phase of the fork parent, not the child, which is where we push
// the other context values.
//
// In the Fizz implementation this is much simpler because the child is
// rendered in the same callstack as the parent.
//
// It might be better to just add a `forks` field to the Fiber type. It would
// make this module simpler.
warnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part
// of the id; we use it to account for leading 0s.
var baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into
// consideration the leading 1 we use to mark the end of the sequence.
if(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.
// This branch assumes the length of the base id is greater than 5; it won't
// work for smaller ids, because you need 5 bits per character.
//
// We encode the id in multiple steps: first the base id, then the
// remaining digits.
//
// Each 5 bit sequence corresponds to a single base 32 character. So for
// example, if the current id is 23 bits long, we can convert 20 of those
// bits into a string of 4 characters, with 3 bits left over.
//
// First calculate how many bits in the base id represent a complete
// sequence of characters.
var numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.
var newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.
var newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.
var restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because
// we made more room, this time it won't overflow.
var restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else{// Normal path
var newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear
// in its children.
var returnFiber=workInProgress.return;if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.
// This is a bit more complicated than other context-like modules in Fiber
// because the same Fiber may appear on the stack multiple times and for
// different reasons. We have to keep popping until the work-in-progress is
// no longer at the top of the stack.
while(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return{id:treeContextId,overflow:treeContextOverflow};}else{return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches
// due to earlier mismatches or a suspended fiber.
var didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary
var hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.
isConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the
// siblings of a suspended node. The mismatch may be due to the missing
// data, so it's probably a false positive.
return;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.
isConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.
_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;var _props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.
nextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.
// This simplifies the code for getHostSibling and deleting nodes,
// since it doesn't have to consider all Suspense boundaries and
// check if they're dehydrated ones or not.
var dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment.return=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into
// it during the first pass. Instead, we'll reenter it later.
nextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.
isConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.
_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them. We also don't delete anything inside the root container.
if(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else{while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred
// during the hydration attempt are now recovered. We will log them in
// commit phase, once the entire tree has finished.
queueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else{hydrationErrors.push(error);}}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function warnForMissingKey(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function warnForMissingKey(child,returnFiber){if(child===null||_typeof(child)!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(_typeof(child._store)!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'"key" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&_typeof(mixedRef)!=='object'){{// TODO: Clean this up once we turn on the string ref warning for
// everyone, because the strict mode case will no longer be relevant
if((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs
// because these cannot be automatically converted to an arrow function
// using a codemod. Therefore, we don't have to warn about string refs again.
!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('A string ref, "%s", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error("Missing owner for string ref "+mixedRef+". This error is likely caused by a "+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure
var resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=resolvedInst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.
refs=resolvedInst.refs={};}if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error("Element ref was specified as a string ("+mixedRef+") but no owner was set. This could happen for one of"+' the following reasons:\n'+'1. You may be adding a ref to a function component\n'+"2. You may be adding a ref to a component that was not created inside a component's render method\n"+'3. You have multiple copies of React loaded\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error("Objects are not valid as a React child (found: "+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+"). "+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){var _s=$RefreshSig$(),_s2=$RefreshSig$(),_s3=$RefreshSig$(),_s4=$RefreshSig$(),_s5=$RefreshSig$(),_s6=$RefreshSig$(),_s7=$RefreshSig$();function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
// instead.
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are
// part of a list of children (arrays, iterators).
newFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.flags|=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){_s();if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent);existing.return=returnFiber;return existing;}}_s(updateTextNode,"kiHzbwuEosy3to0T/G280Ayd51Y=",false,function(){return[useFiber];});function updateElement(returnFiber,current,element,lanes){_s2();var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:
isCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.
// We need to do this after the Hot Reloading check above,
// because hot reloading has different semantics than prod because
// it doesn't resuspend. So we can't let the call below suspend.
_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index
var existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert
var created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}_s2(updateElement,"kiHzbwuEosy3to0T/G280Ayd51Y=",false,function(){return[useFiber];});function updatePortal(returnFiber,current,portal,lanes){_s3();if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[]);existing.return=returnFiber;return existing;}}_s3(updatePortal,"kiHzbwuEosy3to0T/G280Ayd51Y=",false,function(){return[useFiber];});function updateFragment(returnFiber,current,fragment,lanes,key){_s4();if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment);existing.return=returnFiber;return existing;}}_s4(updateFragment,"kiHzbwuEosy3to0T/G280Ayd51Y=",false,function(){return[useFiber];});function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created.return=returnFiber;return created;}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2.return=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(_typeof(child)!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.
// See https://github.com/facebook/react/issues/12995
if(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag
newChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children
if(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){_s5();// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}_s5(reconcileSingleTextNode,"kiHzbwuEosy3to0T/G280Ayd51Y=",false,function(){return[useFiber];});function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){_s6();var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else{if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:
isCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.
// We need to do this after the Hot Reloading check above,
// because hot reloading has different semantics than prod because
// it doesn't resuspend. So we can't let the call below suspend.
_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing.return=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.
deleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created.return=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}_s6(reconcileSingleElement,"y0O5sXhsgR6oBKBsNkmqU79kdOo=",false,function(){return[useFiber,useFiber];});function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){_s7();var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing.return=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
_s7(reconcileSinglePortal,"kiHzbwuEosy3to0T/G280Ayd51Y=",false,function(){return[useFiber];});function reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
var isUnkeyedTopLevelFragment=_typeof(newChild)==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types
if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.
return reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild.return=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.
function resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.
// However, we can't just call getRootHostContext() and push it because
// we'd have a different number of entries on the stack depending on
// whether getRootHostContext() throws somewhere in renderer code or not.
// So we push an empty value first. This lets us safely unwind on errors.
push(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.
pop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is
// inherited deeply down the subtree. The upper bits only affect
// this immediate suspense boundary and gets reset each new
// boundary or suspense list.
var SubtreeSuspenseContextMask=1;// Subtree Flags:
// InvisibleParentSuspenseContext indicates that one of our parent Suspense
// boundaries is not currently showing visible main content.
// Either because it is already showing a fallback or is not mounted at all.
// We can use this to determine if it is desirable to trigger a fallback at
// the parent. If not, then we might need to trigger undesirable boundaries
// and/or suspend the commit to avoid hiding the parent content.
var InvisibleParentSuspenseContext=1;// Shallow Flags:
// ForceSuspenseFallback can be used by SuspenseList to force newly added
// items into their fallback state during one of the render passes.
var ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the
// fallback. Otherwise, don't capture and bubble to the next boundary.
var nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.
return true;}return false;}var props=workInProgress.memoizedProps;// Regular boundaries always capture.
{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the
}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't
// keep track of whether it suspended or not.
node.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node.return===null||node.return===row){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.
var HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.
var Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.
// This tracks which mutable sources need to be reset after a render.
var workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one
// that is eventually read during hydration.
// If they don't match there's a potential tear and a full deopt render is required.
function registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.
// Retaining it forever may interfere with GC.
if(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.
var renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.
var currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.
var currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This
// does not get reset if we do another render pass; only when we're completely
// finished evaluating this component. This is an optimization so we know
// whether we need to clear render phase updates after a throw.
var didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This
// gets reset after each attempt.
// TODO: Maybe there's some way to consolidate this with
// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
var didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.
var localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during
// hydration). This counter is global, so client ids are not stable across
// render attempts.
var globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook
var currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.
// The list stores the order of hooks used during the initial render (mount).
// Subsequent renders (updates) reference this list.
var hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore
// the dependencies for Hooks that need them (e.g. useEffect or useMemo).
// When true, such Hooks will always be "remounted". Only used during hot reload.
var ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.
// It's unlikely their type would change as usually you define them inline.
error('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,_typeof(deps));}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+". "+oldHookName;// Extra space so second column lines up
// lol @ IE not supporting String#repeat
while(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n'+'   Previous render            Next render\n'+'   ------------------------------------------------------\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\n'+'2. You might be breaking the Rules of Hooks\n'+'3. You might have more than one copy of React in the same app\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.
return false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be
// passed inline.
if(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\n\n'+'Previous: %s\n'+'Incoming: %s',currentHookNameInDev,"["+prevDeps.join(', ')+"]","["+nextDeps.join(', ')+"]");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:
ignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset
// currentHook = null;
// workInProgressHook = null;
// didScheduleRenderPhaseUpdate = false;
// localIdCounter = 0;
// TODO Warn if no hooks are used at all during mount, then some are used during update.
// Currently we will identify the update render as a mount because memoizedState === null.
// This is tricky because it's valid for certain types of components (e.g. React.lazy)
// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
// Non-stateful hooks (e.g. context) don't get added to memoizedState,
// so memoizedState would be null during updates and mounts.
{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,
// but no stateful hooks have been used.
// We want to match the production code behavior (which will use HooksDispatcherOnMount),
// but with the extra DEV validation to ensure hooks ordering hasn't changed.
// This dispatcher does that.
ReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update
if(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to
// be scheduled. Use a counter to prevent infinite loops.
var numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize
// after first render to prevent infinite render phase updates.
ignorePreviousDependencies=false;}// Start over from the beginning of the list
currentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.
hookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it
// at the beginning of the render phase and there's no re-entrance.
ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.
// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
var didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last
// render. If this fires, it suggests that we incorrectly reset the static
// flags in some other part of the codebase. This has happened before, for
// example, in the SuspenseList implementation.
if(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird
// and creates false positives. To make this work in legacy mode, we'd
// need to mark fibers that commit in an incomplete state, somehow. For
// now I'll disable the warning that most of the bugs that would trigger
// it are either exclusive to concurrent mode or exist in both.
(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook
// localIdCounter = 0;
if(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.
// Conceptually, it's part of the return value of renderWithHooks; it's only a
// separate function to avoid using an array tuple.
var didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the
// complete phase (bubbleProperties).
if((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else{workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it
// at the beginning of the render phase and there's no re-entrance.
ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render
// phase, which we are now aborting. Remove the updates from the queues so
// they do not persist to the next render. Do not remove updates from hooks
// that weren't processed.
//
// Only reset the updates from the queue if it has a clone. If it does
// not have a clone, that means it wasn't processed, and the updates were
// scheduled before we entered the render phase.
var hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list
currentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list
workInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a
// render phase update. It assumes there is either a current hook we can
// clone, or a work-in-progress hook from a previous render pass that we can
// use as a base. When we reach the end of the base list, we must switch to
// the dispatcher used for mounts.
var nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.
workInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.
if(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.
currentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.
workInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types
return typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.
var baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.
var pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.
// We'll add them to the base queue.
if(baseQueue!==null){// Merge the pending queue and the base queue.
var baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in
// the future if we implement resuming, or some form of that.
error('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.
var first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first
// skipped update, the previous update/state is the new base
// update/state.
var clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.
// TODO: Don't need to accumulate this. Instead, we can remove
// renderLanes from the original lanes.
currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.
if(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit
// it. Using NoLane works because 0 is a subset of all bitmasks, so
// this will never be skipped by the check above.
lane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.
if(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,
// we can use the eagerly computed state
newState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is
// different from the current state.
if(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to
// process them during this render, but we do need to track which lanes
// are remaining.
var lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to
// zero once the queue is empty.
queue.lanes=NoLanes;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous
// work-in-progress hook.
var dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.
queue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the
// priority because it will always be the same as the current
// render's.
var action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is
// different from the current state.
if(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to
// the base state unless the queue is empty.
// TODO: Not sure if this is the desired semantics, but it's what we
// do for gDSFP. I can't remember why.
if(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else{nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.
// Right before committing, we will walk the tree and check if any of the
// stores were mutated.
//
// We won't do this if we're hydrating server-rendered content, because if
// the content is stale, it's already visible anyway. Instead we'll patch
// it up in a passive effect.
var root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the
// normal rules of React, and only works because store updates are
// always synchronous.
hook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.
mountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update
// this whenever subscribe, getSnapshot, or value changes. Because there's no
// clean-up function, and we track the deps correctly, we can call pushEffect
// directly, without storing any additional state. For the same reason, we
// don't need to set a static flag, either.
// TODO: We can move this to the passive phase once we add a pre-commit
// consistency check. See the next comment.
fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the
// normal rules of React, and only works because store updates are
// always synchronous.
var nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the
// commit phase if there was an interleaved mutation. In concurrent mode
// this can happen all the time, but even in synchronous mode, an earlier
// effect may have mutated the store.
if(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by
// checking whether we scheduled a subscription effect above.
workInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.
// Right before committing, we will walk the tree and check if any of the
// stores were mutated.
var root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else{var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else{stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase
inst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could
// have been in an event that fired before the passive effects, or it could
// have been in a layout effect. In that case, we would have used the old
// snapsho and getSnapshot values to bail out. We need to check one more time.
if(checkIfSnapshotChanged(inst)){// Force a re-render.
forceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function handleStoreChange(){// The store changed. Check if the snapshot changed since the last time we
// read from the store.
if(checkIfSnapshotChanged(inst)){// Force a re-render.
forceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.
return subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types
initialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular
next:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else{return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?
var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?
var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.
// The react-debug-hooks package injects its own implementation
// so that e.g. DevTools can display custom hook values.
}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.
if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.
hook.memoizedState=value;return value;}else{// This is a rerender during an update.
var prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the
// previous value and spawn a deferred render to update it later.
if(!objectIs(value,prevValue)){// Schedule a deferred render
var deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent
// from the latest value. The name "baseState" doesn't really match how we
// use it because we're reusing a state hook field instead of creating a
// new one.
hook.baseState=true;}// Reuse the previous value
return prevValue;}else{// This is not an urgent update, so we can use the latest value regardless
// of what it is. No need to defer it.
// However, if we're currently inside a spawned render, then we need to mark
// this as an update to prevent the fiber from bailing out.
//
// `baseState` is true when the current value is different from the rendered
// value. The name doesn't really match how we use it because we're reusing
// a state hook field instead of creating a new one.
if(hook.baseState){// Flip this back to false.
hook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.
var start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return[isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we
// should do this in Fiber, too? Deferring this decision for now because
// there's no other place to store the prefix except for an internal field on
// the public createRoot object, which the fiber tree does not currently have
// a reference to.
var identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.
id=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end
// that represents the position of this useId hook among all the useId
// hooks for this fiber.
var localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else{// Use a lowercase r prefix for client-generated ids.
var globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error("State updates from the useState() and useReducer() Hooks don't support the "+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{enqueueUpdate$1(fiber,queue,update);var eventTime=requestEventTime();var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error("State updates from the useState() and useReducer() Hooks don't support the "+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{enqueueUpdate$1(fiber,queue,update);var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the
// next state before entering the render phase. If the new state is the
// same as the current state, we may be able to bail out entirely.
var lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute
// it, on the update object. If the reducer hasn't changed by the
// time we enter the render phase, then the eager state can be used
// without calling the reducer again.
update.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.
// It's still possible that we'll need to rebase this update later,
// if the component re-renders for a different reason and by that
// time the reducer has changed.
return;}}catch(error){// Suppress the error. It will throw again in the render phase.
}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var eventTime=requestEventTime();var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of
// queue -> linked list of updates. After this render pass, we'll restart
// and apply the stashed updates on top of the work-in-progress hook.
didScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}function enqueueUpdate$1(fiber,queue,update,lane){if(isInterleavedUpdate(fiber)){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.
update.next=update;// At the end of the current render, this queue's interleaved updates will
// be transferred to the pending queue.
pushInterleavedQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}else{var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.
update.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}}function entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they
// must have finished. We can remove them from the shared queue, which
// represents a superset of the actually pending lanes. In some cases we
// may entangle more than we need to, but that's OK. In fact it's worse if
// we *don't* entangle when we should.
queueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.
var newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if
// the lane finished since the last time we entangled it. So we need to
// entangle it again, just to be sure.
markRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:_readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function warnInvalidContextAccess(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function warnInvalidHookAccess(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**
 * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).
 *
 * The overall sequence is:
 *   1. render
 *   2. commit (and call `onRender`, `onCommit`)
 *   3. check for nested updates
 *   4. flush passive effects (and call `onPostCommit`)
 *
 * Nested updates are identified in step 3 above,
 * but step 4 still applies to the work that was just committed.
 * We use two flags to track nested updates then:
 * one tracks whether the upcoming update is a nested update,
 * and the other tracks whether the current update was a nested update.
 * The first value gets synced to the second at the start of the render phase.
 */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor
// Or the root (for the DevTools Profiler to read)
var parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber.return;}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor
// Or the root (for the DevTools Profiler to read)
var parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.
// In this case, the return pointer is also cleared out,
// so we won't be able to report the time spent in this Profiler's subtree.
parentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber.return;}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it
// after we rerender. This is used as a helper in special cases
// where we should count the work of multiple passes.
var child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function createCapturedValue(value,source){// If the value is an error, call this function immediately after it is thrown
// so the stack is accurate.
return{value:value,source:source,stack:getStackByFiberInDevAndProd(source)};}// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling
// `preventDefault()` in window `error` handler.
// We record this information as an expando on the error.
if(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.
// Ignore it and don't print the stack addendum.
// This is handy for testing error boundaries without noise.
return;}// The error is fatal. Since the silencing might have
// been accidental, we'll surface it anyway.
// However, the browser would have silenced the original error
// so we'll print it first, and then print the stack addendum.
console['error'](error);// Don't transform to our wrapper
// For a more detailed description of this block, see:
// https://github.com/facebook/react/pull/13384
}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?"The above error occurred in the <"+componentName+"> component:":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else{var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage="React will try to recreate this component tree from scratch "+("using the error boundary you provided, "+errorBoundaryName+".");}var combinedMessage=componentNameMessage+"\n"+componentStack+"\n\n"+(""+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console['error'](combinedMessage);// Don't transform to our wrapper
}else{}}catch(e){// This method must not throw, or React internal state will get messed up.
// If console.error is overridden, or logCapturedError() shows a dialog that throws,
// we want to report this error outside of the normal stack as a last resort.
// https://github.com/facebook/react/issues/13188
setTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.
update.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,
// we keep track of which ones already failed during this batch.
// This gets reset before we yield back to the browser.
// TODO: Warn in strict mode if getDerivedStateFromError is
// not defined.
markLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,
// then it needs to call setState to recover from errors.
// If no state update is scheduled then the boundary will swallow the error.
if(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener
//
// The data might resolve before we have a chance to commit the fallback. Or,
// in the case of a refresh, we'll never commit a fallback. So we need to
// attach a listener now. When it resolves ("pings"), we can decide whether to
// try rendering the tree again.
//
// Only attach a listener if one does not already exist for the lanes
// we're currently rendering (which acts like a "thread ID" here).
//
// We only need to do this in concurrent mode. Legacy Suspense always
// commits fallbacks synchronously, so there are no pings.
var pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.
threadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters
restorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener
//
// If the fallback does commit, we need to attach a different type of
// listener. This one schedules an update on the Suspense boundary to turn
// the fallback state off.
//
// Stash the wakeable on the boundary fiber so we can access it in the
// commit phase.
//
// When the wakeable resolves, we'll attempt to render the boundary
// again ("retry").
var wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else{wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.
var tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next
// boundary.
node=node.return;}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,
// it captures the suspended "exception" and does a second (fallback) pass.
if((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense
//
// If the boundary is in legacy mode, we should *not*
// suspend the commit. Pretend as if the suspended component rendered
// null and keep rendering. When the Suspense boundary completes,
// we'll do a second pass to render the fallback.
if(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of
// a Suspense boundary's inner Offscreen wrapper fiber. This happens
// when a React.lazy component is a direct child of a
// Suspense boundary.
//
// Suspense boundaries are implemented as multiple fibers, but they
// are a single conceptual unit. The legacy mode behavior where we
// pretend the suspended fiber committed as `null` won't work,
// because in this case the "suspended" fiber is the inner
// Offscreen wrapper.
//
// Because the contents of the boundary haven't started rendering
// yet (i.e. nothing in the tree has partially rendered) we can
// switch to the regular, concurrent mode behavior: mark the
// boundary with ShouldCapture and enter the unwind phase.
suspenseBoundary.flags|=ShouldCapture;}else{suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.
// But we shouldn't call any lifecycle methods or callbacks. Remove
// all lifecycle effect tags.
sourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a
// completed class component. For example, we should not call
// componentWillUnmount if it is deleted.
sourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,
// since it's known to be in an inconsistent state. Use a force update to
// prevent a bail out.
var update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update);}}// The source fiber did not complete. Mark it with Sync priority to
// indicate that it still has pending work.
sourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue
// with the normal suspend path.
//
// After this we'll use a set of heuristics to determine whether this
// render pass will run to completion or restart or "suspend" the commit.
// The actual logic for this is spread out in different places.
//
// This first principle is that if we're going to suspend when we complete
// a root, then we should also restart if we get an update or ping that
// might unsuspend it, and vice versa. The only reason to suspend is
// because you think you might want to restart before committing. However,
// it doesn't make sense to restart only while in the period we're suspended.
//
// Restarting too aggressively is also not good because it starves out any
// intermediate loading state. So we use heuristics to determine when.
// Suspense Heuristics
//
// If nothing threw a Promise or all the same fallbacks are already showing,
// then don't suspend/restart.
//
// If this is an initial render of a new tree of Suspense boundaries and
// those trigger a fallback, then don't suspend/restart. We want to ensure
// that we can show the initial loading state as quickly as possible.
//
// If we hit a "Delayed" case, such as when we'd switch from content back into
// a fallback, then we should always suspend/restart. Transitions apply
// to this case. If none is defined, JND is used instead.
//
// If we're already showing a fallback and it gets "retried", allowing us to show
// another level, but there's still an inner boundary that would show a fallback,
// then we suspend/restart for 500ms since the last time we showed a fallback
// anywhere in the tree. This effectively throttles progressive loading into a
// consistent train of commits. This also gives us an opportunity to restart to
// get to the completed state slightly earlier.
//
// If there's ambiguity due to batching it's resolved in preference of:
// 1) "delayed", 2) "initial render", 3) "retry".
//
// We want to ensure that a "busy" state doesn't get force committed. We want to
// ensure that new initial loading states can commit as soon as possible.
suspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in
// the begin phase to prevent an early bailout.
suspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.
sourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters
restorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&_typeof(value)==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.
var wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always
// commits fallbacks synchronously, so there are no pings.
if(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else{// No boundary was found. Unless this is a sync update, this is OK.
// We can suspend and wait for more data to arrive.
if(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a
// Suspense boundary, this will unwind all the way to the root without
// performing a second pass to render a fallback. (This is arguably how
// refresh transitions should work, too, since we're not going to commit
// the fallbacks anyway.)
//
// This case also applies to initial hydration.
attachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error
// because discrete renders are expected to produce a complete tree
// synchronously to maintain consistency with external state.
var uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.
// The error will be caught by the nearest suspense boundary.
value=uncaughtSuspenseError;}}else{// This is a regular error, not a Suspense wakeable.
if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by
// discarding the dehydrated content and switching to a client render.
// Instead of surfacing the error, find the nearest Suspense boundary
// and render it again without hydration.
if(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal
// children again, not the fallback.
_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should
// still log it so it can be fixed.
queueHydrationError(value);return;}}}// We didn't find a boundary that could handle this type of exception. Start
// over and traverse parent path again, this time treating the exception
// as an error.
renderDidError(value);value=createCapturedValue(value,sourceFiber);var workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry
var errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state
var _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the
}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// a PlacementAndUpdate.
workInProgress.flags|=Update;}function markRef(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent;var updateHostText;{// Mutation mode
appendAllChildren=function appendAllChildren(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function updateHostContainer(current,workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because
// we won't touch this node even if children changed.
return;}// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host
// component is hitting the resume path. Figure out why. Possibly
// related to `hidden`.
var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can
// so we don't leave any behind.
return;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point
// should be invisible. If there are already mounted boundaries
// anything before them are not considered for collapsing.
// Therefore we need to go through the whole tail to find if
// there are any.
var tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the
// last rendered item.
if(lastTailNode===null){// All remaining items in the tail are insertions.
renderState.tail=null;}else{// Detach the insertion after the last node that was already
// inserted.
lastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point
// should be invisible. If there are already mounted boundaries
// anything before them are not considered for collapsing.
// Therefore we need to go through the whole tail to find if
// there are any.
var _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the
// last rendered item.
if(_lastTailNode===null){// All remaining items in the tail are insertions.
if(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one
// row at the tail. So we'll keep on and cut off the rest.
renderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already
// inserted.
_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.
if((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset
// profiler durations.
var actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will
// only be updated if work is done on the fiber (i.e. it doesn't bailout).
// When work is done, it should bubble to the parent's actualDuration. If
// the fiber has not been cloned though, (meaning no work was done), then
// this value will reflect the amount of time spent working on a previous
// render. In that case it should not bubble. We determine whether it was
// cloned by comparing the child pointer.
actualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code
// smell because it assumes the commit phase is never concurrent with
// the render phase. Will address during refactor to alternate model.
_child.return=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else{// Bubble up the earliest expiration time.
if((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset
// profiler durations.
var _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// "Static" flags share the lifetime of the fiber/hook they belong to,
// so we should bubble those up even during a bailout. All the other
// flags have a lifetime only of a single render + commit, so we should
// ignore them.
subtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else{var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// "Static" flags share the lifetime of the fiber/hook they belong to,
// so we should bubble those up even during a bailout. All the other
// flags have a lifetime only of a single render + commit, so we should
// ignore them.
subtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code
// smell because it assumes the commit phase is never concurrent with
// the render phase. Will address during refactor to alternate model.
_child3.return=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing
// to the current tree provider fiber is just as fast and less error-prone.
// Ideally we would have a special version of the work loop only
// for hydration.
popTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for
// the commit side-effects on the root.
markUpdate(workInProgress);}else{if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root
!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)
(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the
// next commit. This handles the case of React rendering into a
// container with previous children. It's also safe to do for
// updates too, because current.child would only be null if the
// previous render was null (so the container would already
// be empty).
workInProgress.flags|=Snapshot;// If this was a forced client render, there may have been
// recoverable errors during first hydration attempt. If so, add
// them to a queue so we can log them in the commit phase.
upgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.
bubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on whether we want to add them top->down or
// bottom->up. Top->down is faster in IE11.
var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.
}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return workInProgress;}if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this
// Suspense boundary, and also after we've reentered it for further hydration.
var _wasHydrated3=popHydrationState(workInProgress);if(current===null){if(!_wasHydrated3){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.
var primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator
workInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}else{// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration
// state since we're now exiting out of it. popHydrationState doesn't do that for us.
resetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.
workInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary
// as having hydrated so events know that they're free to be invoked.
// It's also a signal to replay events and the suspense callback.
// If something suspended, schedule an effect to attach retry listeners.
// So we might as well always mark this.
workInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.
var _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator
workInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return null;}}// Successfully completed this tree. If this was a forced client render,
// there may have been recoverable errors during first hydration
// attempt. If so, add them to a queue so we can log them in the
// commit phase.
upgradeHydrationErrorsToRecoverable();if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.
workInProgress.lanes=renderLanes;// Do not reset the effect list.
if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.
return workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=false;if(current===null){popHydrationState(workInProgress);}else{var _prevState=current.memoizedState;prevDidTimeout=_prevState!==null;}// a passive effect, which is when we process the transitions
if(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from
// fallback -> primary, the inner Offscreen fiber schedules this effect
// as part of its normal complete phase. But when we switch from
// primary -> fallback, the inner Offscreen fiber does not have a complete
// phase. So we need to schedule its effect here.
//
// We also use this flag to connect/disconnect the effects, but the same
// logic applies: when re-connecting, the Offscreen fiber's complete
// phase will handle scheduling the effect. It's only when the fallback
// is active that we have to do anything special.
if(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything
// in the concurrent tree already suspended during this render.
// This is a known bug.
if((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late
// if this is a large tree which is common for initial loads. We
// don't know if we should restart a render or not until we get
// this marker, and this is too late.
// If this render already had a ping or lower pri updates,
// and this is the first time we know we're going to suspend we
// should be able to immediately restart from within throwException.
var hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing
// this boundary is ok.
renderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should
// suspend for longer if possible.
renderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.
// TODO: Move to passive phase
workInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.
var _primaryChildFragment2=workInProgress.child;if(_primaryChildFragment2!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator
workInProgress.treeBaseDuration-=_primaryChildFragment2.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber
var context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are
// sequential to ensure this switch is compiled to a jump table.
var _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, "independent" mode.
// We don't do anything in this mode.
bubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.
if(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still
// suspended in the rendered set.
// If new content unsuspended, but there's still some content that
// didn't. Then we need to do a second pass that forces everything
// to keep showing their fallbacks.
// We might be suspended if something in this render pass suspended, or
// something in the previous committed pass suspended. Otherwise,
// there's no chance so we can skip the expensive call to
// findFirstSuspended.
var cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as
// part of the second pass. In that case nothing will subscribe to
// its thenables. Instead, we'll transfer its thenables to the
// SuspenseList so that it can retry if they resolve.
// There might be multiple of these in the list but since we're
// going to wait for all of them anyway, it doesn't really matter
// which ones gets to ping. In theory we could get clever and keep
// track of how many dependencies remain but it gets tricky because
// in the meantime, we can add/remove/change items and dependencies.
// We might bail out of the loop before finding any but that
// doesn't matter since that means that the other boundaries that
// we did find already has their listeners attached.
var newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks
// to stay in place.
// Reset the effect flags before doing the second pass since that's now invalid.
// Reset the child fibers to their original state.
workInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately
// rerender the children.
pushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.
return workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows
// left in the tail. We'll just give up further attempts to render
// the main content and only render fallbacks.
workInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this
// to get it started back up to attempt the next item. While in terms
// of priority this work has the same priority as this current render,
// it's not part of the same transition once the transition has
// committed. If it's sync, we still want to yield so that it can be
// painted. Conceptually, this is really the same as pinging.
// We can use any RetryLane even if it's the one currently rendering
// since we're leaving it behind on this node.
workInProgress.lanes=SomeRetryLane;}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.
}else{// Append the rendered row to the child list.
if(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't
// get lost if this row ends up dropped during a second pass.
var _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.
if(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.
){// We're done.
bubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining
// time we have to render. So rendering one more row would likely
// exceed it.
now()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further
// attempts to render the main content and only render fallbacks.
// The assumption is that this is usually faster.
workInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this
// to get it started back up to attempt the next item. While in terms
// of priority this work has the same priority as this current render,
// it's not part of the same transition once the transition has
// committed. If it's sync, we still want to yield so that it can be
// painted. Conceptually, this is really the same as pinging.
// We can use any RetryLane even if it's the one currently rendering
// since we're leaving it behind on this node.
workInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added
// to the end. This breaks the guarantee that life-cycles fire in
// sibling order but that isn't a strong guarantee promised by React.
// Especially since these might also just pop in during future commits.
// Append to the beginning of the list.
renderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.
// Pop a row.
var next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.
// TODO: We can probably just avoid popping it instead and only
// setting it the first time we go from not suspended to suspended.
var suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.
// Don't bubble properties in this case.
return next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState2=current.memoizedState;var prevIsHidden=_prevState2!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding — it only pre-renders.
!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else{// Don't bubble properties for hidden children unless we're rendering
// at offscreen priority.
if(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.
// If so, we need to hide those nodes in the commit phase, so
// schedule a visibility effect.
if(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in "+'React. Please file an issue.');}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we
// want to reconcile without matching against the existing set. This has the
// effect of all current children being unmounted; even if the type and key
// are the same, the old child is unmounted and a new child is created.
//
// To do this, we're going to go through the reconcile algorithm twice. In
// the first pass, we schedule a deletion for all the current children by
// passing null.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we
// pass null in place of where we usually pass the current child set. This has
// the effect of remounting all children regardless of whether their
// identities match.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component
// hasn't yet mounted. This happens after the first render suspends.
// We'll need to figure out if this is fine or can cause issues.
{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent
var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.
Component.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,
// and with only the default shallow comparison, we upgrade it
// to a SimpleMemoComponent to allow fast path updates.
workInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.
// We could move it there, but we'd still need this for lazy code path.
checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(type));}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.
// We could move it there, but we'd still need this for lazy code path.
checkPropTypes(_innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child
var hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,
// unlike current.memoizedProps which will be the unresolved ones.
var prevProps=currentChild.memoizedProps;// Default to shallow comparison
var compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component
// hasn't yet mounted. This happens when the inner render suspends.
// We'll need to figure out if this is fine or can cause issues.
{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()
// so let's just skip over it to find memo() outer wrapper.
// Inner props for memo are validated later.
var lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.
var outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)
'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.
workInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we
// would during a normal fiber bailout.
//
// We don't have strong guarantees that the props object is referentially
// equal during updates where we can't bail out anyway — like if the props
// are shallowly equal, but there's a local state or context update in the
// same batch.
//
// However, as a principle, we should aim to make the behavior consistent
// across different ways of memoizing a component. For example, React.memo
// has a different internal Fiber layout if you pass a normal function
// component (SimpleMemoComponent) versus if you pass a different type
// like forwardRef (MemoComponent). But this is an implementation detail.
// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't
// affect whether the props object is reused during a bailout.
workInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're
// about to bail out, but there might be other lanes that weren't
// included in the current render. Usually, the priority level of the
// remaining updates is accumulated during the evaluation of the
// component (i.e. when processing the update queue). But since since
// we're bailing out early *without* evaluating the component, we need
// to account for it here, too. Reset to the value of the current fiber.
// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
// because a MemoComponent fiber does not have hooks or an update queue;
// rather, it wraps around an inner component, which may or may not
// contains hooks.
// TODO: Move the reset at in beginWork out of the common path so that
// this is no longer necessary.
workInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.
// See https://github.com/facebook/react/pull/19216.
didReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.
if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.
// TODO: Consider how Offscreen should work with transitions in the future
var nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out
// and resume this tree later.
var nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.
workInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.
pushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// This is the second render. The surrounding visible content has already
// committed. Now we resume rendering the hidden tree.
// Rendering at offscreen, so we can clear the base lanes.
var _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.
var subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{// Rendering a visible tree.
var _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.
_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing
// special to do. Need to push to the stack regardless, though, to avoid
// a push/pop misalignment.
_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}{reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}}function updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.
// These are reset during render to allow the DevTools commit hook a chance to read them,
var stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef$1(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect
workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.
switch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.
// Is there a better way to do this?
var tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes
var error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state
var update=createClassErrorUpdate(workInProgress,createCapturedValue(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){if(current!==null){// A class component without an instance only mounts if it suspended
// inside a non-concurrent tree, in an inconsistent state. We want to
// treat it like a new mount, even though an empty version of it already
// committed. Disconnect the alternate pointers.
current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.
shouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false
markRef$1(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,
// unmount all the children. componentDidCatch will schedule an update to
// re-render a fallback. This is temporary until we migrate everyone to
// the new API.
// TODO: Warn in a future release.
nextChildren=null;{stopProfilerTimerIfRunning();}}else{{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of
// the existing children. Conceptually, the normal children and the children
// that are shown on error are two different sets, so we shouldn't reuse
// normal children even if their identities match.
forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
workInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;var root=workInProgress.stateNode;// being called "element".
var nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should
// attempt to hydrate.
// Flip isDehydrated to false to indicate that when this render
// finishes, the root will no longer be dehydrated.
var overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't
// have reducer functions so it doesn't need rebasing.
updateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we
// forced a client render.
var recoverableError=new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.');return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.');return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else{// The outermost shell has not hydrated yet. Start hydrating.
enterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this
// tree is part of a hydrating tree. This is used to determine if a child
// node has fully mounted yet, and for scheduling event replaying.
// Conceptually this is similar to Placement in that a new subtree is
// inserted into the React tree here. It just happens to not need DOM
// mutations because it already exists.
node.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else{// Root is not dehydrated. Either this is a client-only root, or it
// already hydrated.
resetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.
resetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent$1(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also has access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.flags|=ContentReset;}markRef$1(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText$1(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){if(_current!==null){// A lazy component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.
workInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only
'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too
renderLanes);return child;}}var hint='';{if(Component!==null&&_typeof(Component)==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent
// because the fact that it's a separate type of work is an
// implementation detail.
throw new Error("Element type is invalid. Received a promise that resolves to: "+Component+". "+("Lazy element type must resolve to a class or function."+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){if(_current!==null){// An incomplete component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}// Promote the fiber to a class and try rendering again.
workInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`
// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){if(_current!==null){// An indeterminate component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.flags|=Placement;}var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error("The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.
// Whether or not it would crash later, we want to show a good message in DEV first.
if(_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+"If you can't use a class try assigning the prototype on the function as a workaround. "+"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it "+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.
// Eventually we'll delete this branch altogether.
_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+"If you can't use a class try assigning the prototype on the function as a workaround. "+"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it "+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Throw out any hooks that were used.
workInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component
workInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(_typeof(Component.contextType)==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back
function shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to
// remain on that fallback regardless of whether the content has resolved.
// For example, SuspenseList coordinates when nested content appears.
if(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback
// is true. More precise name might be "ForceRemainSuspenseFallback".
// Note: This is a factoring smell. Can't remain on a fallback if there's
// no fallback to remain on.
return false;}}// Not currently showing content. Consult the Suspense context.
return hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render
return removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.
{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to
// rendering the fallback children.
showFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content
if(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.
// Mark this subtree context as having at least one invisible parent that could
// handle the fallback state.
// Avoided boundaries are not considered since they cannot handle preferred fallback states.
{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense
// boundary's children. This involves some custom reconciliation logic. Two
// main reasons this is so complicated.
//
// First, Legacy Mode has different semantics for backwards compatibility. The
// primary tree will commit in an inconsistent state, so when we do the
// second pass to render the fallback, we do some exceedingly, uh, clever
// hacks to make that not totally break. Like transferring effects and
// deletions from hidden tree. In Concurrent Mode, it's much simpler,
// because we bailout on the primary tree completely and leave it in its old
// state, no effects. Same as what we do for Offscreen (except that
// Offscreen doesn't have the first render pass).
//
// Second is hydration. During hydration, the Suspense fiber has a slightly
// different layout, where the child points to a dehydrated fragment, which
// contains the DOM rendered by the server.
//
// Third, even if you set all that aside, Suspense is like error boundaries in
// that we first we try to render one tree, and if that fails, we render again
// and switch to a different tree. Like a try/catch block. So we have to track
// which branch we're currently rendering. Ideally we would model this using
// a stack.
if(current===null){// Initial mount
// If we're currently hydrating, try to hydrate this boundary.
tryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.
var suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else{// This is an update.
// If the current fiber has a SuspenseState, that means it's already showing
// a fallback.
var prevState=current.memoizedState;if(prevState!==null){// The current tree is already showing a fallback
// Special path for hydration
var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){if(!didSuspend){return updateDehydratedSuspenseComponent(current,workInProgress,_dehydrated,prevState,renderLanes);}else if(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.
workInProgress.flags&=~ForceClientRender;return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.
// Leave the existing child in place.
workInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there
// but the normal suspense pass doesn't.
workInProgress.flags|=DidCapture;return null;}else{// Suspended but we should no longer be in dehydrated mode.
// Therefore we now have to render the fallback.
var _nextPrimaryChildren=nextProps.children;var _nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;_primaryChildFragment2.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}if(showFallback){var _nextFallbackChildren2=nextProps.fallback;var _nextPrimaryChildren2=nextProps.children;var _fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren2,_nextFallbackChildren2,renderLanes);var _primaryChildFragment3=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment3.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment3.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return _fallbackChildFragment;}else{var _nextPrimaryChildren3=nextProps.children;var _primaryChildFragment4=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren3,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment4;}}else{// The current tree is not already showing a fallback.
if(showFallback){// Timed out.
var _nextFallbackChildren3=nextProps.fallback;var _nextPrimaryChildren4=nextProps.children;var _fallbackChildFragment2=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren4,_nextFallbackChildren3,renderLanes);var _primaryChildFragment5=workInProgress.child;var _prevOffscreenState=current.child.memoizedState;_primaryChildFragment5.memoizedState=_prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(_prevOffscreenState,renderLanes);_primaryChildFragment5.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);// fallback children.
workInProgress.memoizedState=SUSPENDED_MARKER;return _fallbackChildFragment2;}else{// Still haven't timed out. Continue rendering the children, like we
// normally do.
var _nextPrimaryChildren5=nextProps.children;var _primaryChildFragment6=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren5,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment6;}}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment.return=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully
// completed, even though it's in an inconsistent state.
primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the
// final amounts. This seems counterintuitive, since we're intentionally
// not measuring part of the render phase, but this makes it match what we
// do in Concurrent Mode.
primaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use
// this wrapper function to constrain it.
return createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this
// wrapper function to constrain it.
return createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment
var deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else{deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully
// completed, even though it's in an inconsistent state.
(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was
// already cloned. In legacy mode, the only case where this isn't true is
// when DevTools forces us to display a fallback; we skip the first render
// pass entirely and go straight to rendering the fallback. (In Concurrent
// Mode, SuspenseList can also trigger this scenario, but this is a legacy-
// only codepath.)
workInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the
// final amounts. This seems counterintuitive, since we're intentionally
// not measuring part of the render phase, but this makes it match what we
// do in Concurrent Mode.
primaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// However, since we're going to remain on the fallback, we no longer want
// to delete it.
workInProgress.deletions=null;}else{primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// (We don't do this in legacy mode, because in legacy mode we don't re-use
// the current tree; see previous branch.)
primaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already
// mounted but this is a new fiber.
fallbackChildFragment.flags|=Placement;}fallbackChildFragment.return=workInProgress;primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance
// implications, it's considered a recoverable error, even though the user
// likely won't observe anything wrong with the UI.
//
// The error is passed in as an argument to enforce that every caller provide
// a custom message, or explicitly opt out (currently the only path that opts
// out is legacy mode; every concurrent path provides an error).
if(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list
reconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.
var nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already
// mounted but this is a new fiber.
primaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense
// boundary) already mounted but this is a new fiber.
fallbackChildFragment.flags|=Placement;primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the
// deletion. We need to reconcile to delete the current child.
reconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.
// Instead, we'll leave the content in place and try to hydrate it later.
if((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server
// for this, we need to schedule that at a higher priority based on when it would
// have timed out. In theory we could render it in this pass but it would have the
// wrong priority associated with it and will prevent hydration of parent path.
// Instead, we'll leave work left on it to render it in a separate commit.
// TODO This time should be the time at which the server rendered response that is
// a parent to this boundary was displayed. However, since we currently don't have
// a protocol to transfer that time, we'll just estimate it by using the current
// time. This will mean that Suspense timeouts are slightly shifted to later than
// they should be.
// Schedule a normal pri update to render this content.
workInProgress.lanes=laneToLanes(DefaultHydrationLane);}else{// We'll continue hydrating the rest at offscreen priority since we'll already
// be showing the right content coming from the server, it is no rush.
workInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,suspenseInstance,suspenseState,renderLanes){// We should never be hydrating at this point because it is the first pass,
// but after we've already committed once.
warnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument
// required — every concurrent mode path that causes hydration to
// de-opt to client rendering should have an error message.
null);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never
// get an update and we'll never be able to hydrate the final content. Let's just try the
// client side render instead.
return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: The server should serialize the error message so we can log it
// here on the client. Or, in production, a hash/id that corresponds to
// the error.
new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.'));}// any context has changed, we need to treat is as if the input might have changed.
var hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to
// hydrate it. We might still be able to hydrate it using a higher priority lane.
var root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This
// is one of the very rare times where we mutate the current tree
// during the render phase.
suspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render
var eventTime=NoTimestamp;scheduleUpdateOnFiber(current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render
// since we now have higher priority work, but in case it doesn't, we need to prepare to
// render something, if we time out. Even if that requires us to delete everything and
// skip hydration.
// Delay having to do this as long as the suspense timeout allows us.
renderDidSuspendDelayIfPossible();return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its
// content. We treat it as if this component suspended itself. It might seem as if
// we could just try to render it client-side instead. However, this will perform a
// lot of unnecessary work and is unlikely to complete since it often will suspend
// on missing data anyway. Additionally, the server might be able to render more
// than we can on the client yet. In that case we'd end up with more fallback states
// on the client than if we just leave it alone. If the server times out or errors
// these should update this boundary to the permanent Fallback state instead.
// Mark it as having captured (i.e. suspended).
workInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.
workInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.
var retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else{// This is the first attempt.
reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this
// tree is part of a hydrating tree. This is used to determine if a child
// node has fully mounted yet, and for scheduling event replaying.
// Conceptually this is similar to Placement in that a new subtree is
// inserted into the React tree here. It just happens to not need DOM
// mutations because it already exists.
primaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.
// If they were previously forced into fallbacks, they may now be able
// to unblock.
var node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries
// to schedule work on. In this case we have to schedule it on the
// list itself.
// We don't have to traverse to the children of the list since
// the list will propagate the change when it rerenders.
scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already
// showing content on the screen, as opposed to being in fallback state or
// new. If a row has multiple Suspense boundaries, any of them being in the
// fallback state, counts as the whole row being in a fallback state.
// Note that the "rows" will be workInProgress, but any nested children
// will still be current since we haven't rendered them yet. The mounted
// order may not be the same as the new order. We use the new order.
var row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.
if(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('"%s" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase "%s" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('"%s" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use "%ss" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('"%s" is not a supported revealOrder on <SuspenseList />. '+'Did you mean "together", "forwards" or "backwards"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean "together", "forwards" or "backwards"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('"%s" is not a supported value for tail on <SuspenseList />. '+'Did you mean "collapsed" or "hidden"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail="%s" /> is only valid if revealOrder is '+'"forwards" or "backwards". '+'Did you mean to specify revealOrder="forwards"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder="%s" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else{// We can reuse the existing object from previous renders.
renderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.
// The first pass splits the children fibers into two sets. A head and tail.
// We first render the head. If anything is in fallback state, we do another
// pass through beginWork to rerender all children (including the tail) with
// the force suspend context. If the first render didn't have anything in
// in fallback state. Then we render each row in the tail one-by-one.
// That happens in the completeWork phase without going back to beginWork.
function updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work
// on any nested boundaries to let them know to try to render
// again. This is the same as context updating.
propagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just
// use make it a noop by treating it as the default revealOrder.
workInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.
// TODO: We could fast path by just rendering the tail now.
tail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.
// We're going to render them separately later.
tail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards
tail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.
// At the same time we're going to reverse the list of everything
// we pass in the meantime. That's going to be our tail in reverse
// order.
var _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.
if(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.
workInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.
initSuspenseListRenderState(workInProgress,true,// isBackwards
_tail,null,// last
tailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards
null,// tail
null,// last
undefined);break;}default:{// The default reveal order is the same as not having
// a boundary.
workInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.
if(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule
// them to update.
propagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In
// DEV mode, we create a separate object for Context.Consumer that acts
// like a proxy to Context. This proxy object adds unnecessary code in PROD
// so we use the old behaviour (Context.Consumer references Context) to
// reduce size and overhead. The separate object references context via
// a property called "_context", which also gives us the ability to check
// in DEV mode if this property exists or not and warn if it does not.
{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).
// Or it may be because it's older React where they're the same thing.
// We only want to warn if we're sure it's a new React.
if(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+"that isn't a function. A context consumer expects a single child "+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=_readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.
workInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies
workInProgress.dependencies=current.dependencies;}{// Don't update "base" render times for bailouts.
stopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.
if(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.
// TODO: Once we add back resuming, we should check if the children are
// a work-in-progress set. If so, we need to transfer their effects.
{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child
// fibers and continue.
cloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes
throw new Error('Cannot swap the root fiber.');}// Disconnect from the old current.
// It will get deleted.
current.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.
newWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress.return=oldWorkInProgress.return;newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.
if(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes
throw new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes
throw new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.
// Since the old fiber is disconnected, we have to schedule it manually.
var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else{deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.
return newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending
// updates or context.
var updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need
return false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering
// the begin phase. There's still some bookkeeping we that needs to be done
// in this optimized path, mostly pushing stuff onto the stack.
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);var root=workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.
var hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.
// These are reset during render to allow the DevTools commit hook a chance to read them,
var stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has
// been unsuspended it has committed as a resolved Suspense component.
// If it needs to be retried, it should have work scheduled on it.
workInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we
// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.
return null;}// If this boundary is currently timed out, we need to decide
// whether to retry the primary children, or to skip over it and
// go straight to the fallback. Check the priority of the primary
// child fragment.
var primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path
// to attempt to render the primary children again.
return updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked
// on it
pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient
// priority. Bailout.
var child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the
// primary children and work on the fallback.
return child.sibling;}else{// Note: We can return `null` here because we already checked
// whether there were nested context consumers, via the call to
// `bailoutOnAlreadyFinishedWork` above.
return null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the
// same children then we're still in progressive loading state.
// Something might get unblocked by state updates or retries in the
// tree which will affect the tail. So we need to use the normal
// path to compute the correct tail.
return updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of
// them got retried so they'll still be blocked in the same way
// as before. We can fast bail out.
workInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,
// then the tail doesn't matter. Anything new that suspends will work
// in the "together" mode, so we can continue from the state we had.
var renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the "together" mode in case we've started a different
// update in the past but didn't complete it.
renderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of
// them got retried so they'll still be blocked in the same way
// as before. We can fast bail out.
return null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is
// almost identical to the logic used in the normal update path,
// so we'll just enter that. The only difference is we'll bail out
// at the next level instead of this one, because the child props
// have not changed. Which is fine.
// TODO: Probably should refactor `beginWork` to split the bailout
// path from the normal path. I'm tempted to do a labeled break here
// but I won't :)
workInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.
return remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:
workInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.
// This may be unset if the props are determined to be equal later (memo).
didReceiveUpdate=true;}else{// Neither props nor legacy context changes. Check if there's a pending
// update or context change.
var hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there
// may not be work scheduled on `current`, so we check for this flag.
(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.
didReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.
// See https://github.com/facebook/react/pull/19216.
didReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props
// nor legacy context. Set this to false. If an update queue or context
// consumer produces a changed value, it will set this to true. Otherwise,
// the component will assume the children have not changed and bail out.
didReceiveUpdate=false;}}}else{didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in
// its parent.
//
// In a true multi-threaded implementation, we would render children on
// parallel threads. This would represent the beginning of a new render
// thread for this subtree.
//
// We only use this for id generation during hydration, which is why the
// logic is located in this special branch.
var slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.
// TODO: This assumes that we're about to evaluate the component and process
// the update queue. However, there's an exception: SimpleMemoComponent
// sometimes bails out later in the begin phase. This indicates that we should
// move this assignment out of the common path and into each branch.
workInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent$1(current,workInProgress,renderLanes);case HostText:return updateHostText$1(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.
var _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only
'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in "+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing
// to the current tree provider fiber is just as fast and less error-prone.
// Ideally we would have a special version of the work loop only
// for hydration.
popTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{var root=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense
// boundary. Do a second pass on the root to unmount the children.
workInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.
return null;}case HostComponent:{// TODO: popHydrationState
popHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.
if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been
// caught by a nested boundary. If not, it should bubble through.
return null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing
// to the current tree provider fiber is just as fast and less error-prone.
// Ideally we would have a special version of the work loop only
// for hydration.
popTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{var root=interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.
// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.
// Only used when enableSuspenseLayoutEffectSemantics is enabled.
var offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.
var inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded
// callback is a bit too slow (https://github.com/facebook/react/pull/21666).
// But we rely on it to surface errors to DEV tools like overlays
// (https://github.com/facebook/react/issues/21712).
// As a compromise, rethrow only caught errors in a guard.
{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else{instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.
function safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.
function safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.
function safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else{retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else{ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){focusedInstanceHandle=prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber
var shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;focusedInstanceHandle=null;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.
var child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else{commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types
break;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount
var destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount
var create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else{hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\n\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\n\n'+hookName+'(() => {\n'+'  async function fetchData() {\n'+'    // You can await here\n'+'    const response = await MyAPI.getData(someId);\n'+'    // ...\n'+'  }\n'+'  fetchData();\n'+"}, [someId]); // Or [] if effect doesn't need props or state\n\n"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.
if((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.
// It does not get reset until the start of the next commit phase.
var commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.
// After we process that Profiler, we'll bubble further up.
var parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber.return;}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).
// This is done to prevent sibling component effects from interfering with each other,
// e.g. a destroy function in one component should never override a ref set
// by a create function in another component during the same commit.
if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the
// commit phase. Consider removing the type check.
var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
commitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the
// commit phase. Consider removing the type check.
var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.
break;}case HostPortal:{// We have no life-cycles associated with portals.
break;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.
// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,
// because the effect is also where times bubble to parent Profilers.
enqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.
// Do not reset these values until the next render so DevTools has a chance to read them first.
var parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber.return;}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.
// TODO (Offscreen) Check: flags & LayoutStatic
switch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node.return);}finally{recordLayoutEffectDuration(node);}}else{safelyCallCommitHookLayoutEffectListMount(node,node.return);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node.return,instance);}safelyAttachRef(node,node.return);break;}case HostComponent:{safelyAttachRef(node,node.return);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.
var hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node.return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag
if(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else{retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.
// This enables us to detect and warn against state updates on an unmounted component.
// It also prevents events from bubbling from within disconnected components.
//
// Ideally, we should also clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child.
// This child itself will be GC:ed when the parent updates the next time.
//
// Note that we can't clear child or sibling pointers yet.
// They're needed for passive effects and for findDOMNode.
// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).
//
// Don't reset the alternate yet, either. We need that so we can detach the
// alternate's fields in the passive phase. Clearing the return pointer is
// sufficient for findDOMNode semantics.
var alternate=fiber.alternate;if(alternate!==null){alternate.return=null;}fiber.return=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case
// `deletedTreeCleanUpLevel` is undefined.
{// Clear cyclical Fiber fields. This level alone is designed to roughly
// approximate the planned Fiber refactor. In that world, `setState` will be
// bound to a special "instance" object instead of a Fiber. The Instance
// object will not have any of these fields. It will only be connected to
// the fiber tree via a single link at the root. So if this level alone is
// sufficient to fix memory issues, that bodes well for our plans.
fiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host
// tree, which has its own pointers to children, parents, and siblings.
// The other host nodes also point back to fibers, so we should detach that
// one, too.
if(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We
// already disconnect the `return` pointer at the root of the deleted
// subtree (in `detachFiberMutation`). Besides, `return` by itself is not
// cyclical — it's only cyclical when combined with `child`, `sibling`, and
// `alternate`. But we'll clear it in the next level anyway, just in case.
{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already
// disconnected the fiber from the tree. So even if something leaks this
// particular fiber, it won't leak anything else
//
// The purpose of this branch is to be super aggressive so we can measure
// if there's any difference in memory impact. If there is, that could
// indicate a React leak we don't know about.
fiber.return=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.
fiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
// TODO: Find a more efficient way to do this.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.flags&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.flags&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.
switch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its
// children to find all the terminal nodes.
insertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough
default:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a
// deleted subtree.
// TODO: Update these during the whole mutation phase, not just during
// a deletion.
var hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its
// children to find all the terminal nodes.
// Recursively delete all host nodes from the parent, detach refs, clean
// up mounted layout effects, and call componentWillUnmount.
// We only need to remove the topmost host child in each branch. But then we
// still need to keep traversing to unmount effects, refs, and cWU. TODO: We
// could split this into two separate traversals functions, where the second
// one doesn't include any removeChild logic. This is maybe the same
// function as "disappearLayoutEffects" (or whatever that turns into after
// the layout phase is refactored to use recursion).
// Before starting, find the nearest host parent on the stack so we know
// which instance/container to remove the children from.
// TODO: Instead of searching up the fiber return path on every deletion, we
// can track the nearest host component on the JS stack as we traverse the
// tree during the commit phase. This would make insertions faster, too.
var parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent.return;}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects
var child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse
// into their subtree. There are simpler cases in the inner switch
// that don't modify the stack.
switch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch
}// eslint-disable-next-line-no-fallthrough
case HostText:{// We only need to remove the nearest host child. Set the host parent
// to `null` on the stack to indicate that nested children don't
// need to be removed.
{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the
// node from the tree.
if(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else{removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.
{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else{clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.
var _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else{safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag
deletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before
// deleting the children, track that it's already unmounted so that we
// don't attempt to unmount the effects again.
// TODO: If the tree is hidden, in most cases we should be able to skip
// over the nested children entirely. An exception is we haven't yet found
// the topmost host node to delete, which we already track on the stack.
// But the other case is portals, which need to be detached no matter how
// deeply they are nested. We should use a subtree flag to track whether a
// subtree includes a nested portal.
var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase
var newState=finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.
// For each wakeable, attach a listener so that when it resolves, React
// attempts to re-render the boundary in the primary (pre-timeout) state.
var wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.
var retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.
restorePendingUpdaters(inProgressRoot,inProgressLanes);}else{throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.
function commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen
// before the children effects hae fired.
var deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,
// because the fiber tag is more specific. An exception is any flag related
// to reconcilation, because those can be set on all fiber types.
switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Layout effects are destroyed during the mutation phase so that all
// destroy functions for all fibers are called before any create functions.
// This prevents sibling component effects from interfering with each other,
// e.g. a destroy function in one component should never override a ref set
// by a create function in another component during the same commit.
if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}recordLayoutEffectDuration(finishedWork);}else{try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}{// TODO: ContentReset gets cleared by the children during the commit
// phase. This is a refactor hazard because it means we must read
// flags the flags after `commitReconciliationEffects` has already run;
// the order matters. We should refactor so that ContentReset does not
// rely on mutating the flag during commit. Like by setting a flag
// during the render phase instead.
if(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase
markCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag
finishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this
// offscreen subtree was already hidden, so that we don't unmount the
// effects again.
var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;{// TODO: This needs to run whenever there's an insertion or update
// inside a hidden Offscreen tree.
hideOrUnhideAllChildren(offscreenBoundary,_isHidden);}{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber
// type. They needs to happen after the children effects have fired, but
// before the effects on this fiber have fired.
var flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Clear the "placement" from effect tag so that we know that this is
// inserted, before any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted does
// and isMounted is deprecated anyway so we should be able to kill this.
finishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.
var isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.
var isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.
commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else{// TODO (Offscreen) Also check: subtreeFlags & LayoutMask
var current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.
offscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects
// back on.
nextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.
root,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.
nextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)
switch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber.return);}finally{recordLayoutEffectDuration(fiber);}}else{commitHookEffectListUnmount(Layout,fiber,fiber.return);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic
safelyDetachRef(fiber,fiber.return);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber.return);break;}case OffscreenComponent:{// Check if this is a
var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear
// its effects.
disappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic
if(firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.
reappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic
if(firstChild!==null){// This node may have been reused from a previous render, so we can't
// assume its return pointer is correct.
firstChild.return=fiber;nextEffect=firstChild;}else{reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic
setCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't
// assume its return pointer is correct.
sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else{commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of
// the previous (alternate) parent fiber's list of children. Because
// children are a linked list, an earlier sibling that's still alive
// will be connected to the deleted fiber via its `alternate`:
//
//   live fiber
//   --alternate--> previous live fiber
//   --sibling--> deleted fiber
//
// We can't disconnect `alternate` on nodes that haven't been deleted
// yet, but we can disconnect the `sibling` and `child` pointers.
var previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else{commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);recordPassiveEffectDuration(finishedWork);}else{commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order
// TODO: Check if fiber has a PassiveStatic flag
setCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we
// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)
if(child!==null){child.return=fiber;nextEffect=child;}else{commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber.return;{// Recursively traverse the entire deleted tree and clean up fiber fields.
// This is more aggressive than ideal, and the long term goal is to only
// have to detach the deleted tree at the root.
detachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling.return=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else{commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?
function invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}}}}}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol.for){var symbolFor=Symbol.for;COMPONENT_TYPE=symbolFor('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor('selector.has_pseudo_class');ROLE_TYPE=symbolFor('selector.role');TEST_NAME_TYPE=symbolFor('selector.test_id');TEXT_TYPE=symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an
// act environment whenever `jest` is defined, but you can still turn off
// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly
// to false.
var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
typeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest
var jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
typeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.
error('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack
var executionContext=NoContext;// The root we're working on
var workInProgressRoot=null;// The fiber we're working on
var workInProgress=null;// The lanes we're rendering
var workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree
// This is a superset of the lanes we started working on at the root. The only
// case where it's different from `workInProgressRootRenderLanes` is when we
// enter a subtree that is hidden and needs to be unhidden: Suspense and
// Offscreen component.
//
// Most things in the work loop should deal with workInProgressRootRenderLanes.
// Most things in begin/complete phases should deal with subtreeRenderLanes.
var subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.
var workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown
var workInProgressRootFatalError=null;// "Included" lanes refer to lanes that were worked on during this render. It's
// slightly different than `renderLanes` because `renderLanes` can change as you
// enter and exit an Offscreen tree. This value is the combination of all render
// lanes for the entire render phase.
var workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only
// includes unprocessed updates, not work in bailed out children.
var workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.
var workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).
var workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.
var workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.
// We will log them once the tree commits.
var workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train
// model where we don't commit new loading states in too quick succession.
var globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering
// more and prefer CPU suspense heuristics instead.
var workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU
// suspense heuristics and opt out of rendering more content.
var RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;
var rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their
// event times as simultaneous, even if the actual clock time has advanced
// between the first and second call.
var currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.
return now();}// We're not inside React, so we may be in the middle of a browser event.
if(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.
return currentEventTime;}// This is the first update since React yielded. Compute a new start time.
currentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases
var mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The
// old behavior is to give this the same "thread" (lanes) as
// whatever is currently rendering. So if you call `setState` on a component
// that happens later in the same render, it will flush. Ideally, we want to
// remove the special case and treat them as if they came from an
// interleaved event. Regardless, this pattern is not officially supported.
// This behavior is only a fallback. The flag only exists until we can roll
// out the setState warning, since existing code might accidentally rely on
// the current behavior.
return pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all
// updates at the same priority within the same event. To do this, the
// inputs to the algorithm must be the same.
//
// The trick we use is to cache the first of each of these inputs within an
// event. Then reset the cached values once we can be sure the event is
// over. Our heuristic for that is whenever we enter a concurrent work loop.
if(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.
currentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have
// their priority set by tracking it with a context variable.
//
// The opaque type returned by the host config is internally a lane, so we can
// use that directly.
// TODO: Move this type conversion to the event priority module.
var updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an
// appropriate priority, based on the type of event.
//
// The opaque type returned by the host config is internally a lane, so we can
// use that directly.
// TODO: Move this type conversion to the event priority module.
var eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense
// "retries" — a special update that attempts to flip a Suspense boundary
// from its placeholder state to its primary/resolved state.
// Special cases
var mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}var root=markUpdateLaneFromFiberToRoot(fiber,lane);if(root===null){return null;}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.
markRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake
// if the update originates from user space (with the exception of local
// hook updates, which are handled differently and don't reach this
// function), but there are some internal React features that use this as
// an implementation detail, like selective hydration.
warnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase
}else{// This is a normal update, scheduled from outside the render phase. For
// example, during an input event.
{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// TODO: Consolidate with `isInterleavedUpdate` check
// Received an update to a tree that's in the middle of rendering. Mark
// that there was an interleaved update work on this root. Unless the
// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
// phase update. In that case, we don't treat render phase updates as if
// they were interleaved, for backwards compat reasons.
if((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render
// definitely won't finish. Since we have a new update, let's mark it as
// suspended now, right before marking the incoming update. This has the
// effect of interrupting the current render and switching to the update.
// TODO: Make sure this doesn't override pings that happen while we've
// already started rendering.
markRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside
// a batch. This is intentionally inside scheduleUpdateOnFiber instead of
// scheduleCallbackForFiber to preserve the ability to schedule a callback
// without immediately flushing it. We only do this for user-initiated
// updates, to preserve historical behavior of legacy mode.
resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}return root;}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to
// schedule the initial hydration of a root that has just been created. Most
// of the stuff in scheduleUpdateOnFiber can be skipped.
//
// The main reason for this separate path, though, is to distinguish the
// initial children from subsequent updates. In fully client-rendered roots
// (createRoot instead of hydrateRoot), all top-level renders are modeled as
// updates, but hydration roots are special because the initial render must
// match what was rendered on the server.
var current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}// This is split into a separate function so we can mark a fiber with pending
// work without treating it as a typical update that originates from an event;
// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
// on a fiber.
function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes
sourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.
var node=sourceFiber;var parent=sourceFiber.return;while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent.return;}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}function isInterleavedUpdate(fiber,lane){return(// TODO: Optimize slightly by comparing to root that fiber belongs to.
// Requires some refactoring. Not a big deal though since it's rare for
// concurrent apps to have more than a single root.
(workInProgressRoot!==null||// If the interleaved updates queue hasn't been cleared yet, then
// we should treat this as an interleaved update, too. This is also a
// defensive coding measure in case a new update comes in between when
// rendering has finished and when the interleaved updates are transferred
// to the main queue.
hasInterleavedUpdates())&&(fiber.mode&ConcurrentMode)!==NoMode&&// If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
// then don't treat this as an interleaved update. This pattern is
// accompanied by a warning but we haven't fully deprecated it yet. We can
// remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
(executionContext&RenderContext)===NoContext);}// Use this function to schedule a task for a root. There's only one task per
// root; if a task was already scheduled, we'll check to make sure the priority
// of the existing task is the same as the priority of the next level that the
// root has work on. This function is called on every update, and right before
// exiting a task.
function ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as
// expired so we know to work on those next.
markStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.
var nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.
if(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.
var newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.
var existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a
// Scheduler task, rather than an `act` task, cancel it and re-scheduled
// on the `act` queue.
!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.
// Assume that discrete update microtasks are non-cancellable and null.
// TODO: Temporary until we confirm this warning is not fired.
if(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.
return;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.
cancelCallback$1(existingCallbackNode);}// Schedule a new callback.
var newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special
// internal queue
if(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else{scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.
if(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed
// at the end of the current scope even when using the sync version
// of `act`.
ReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else{scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.
// https://github.com/facebook/react/issues/22459
// We don't support running callbacks in the middle of render
// or commit so we need to check against that.
if(executionContext===NoContext){// It's only safe to do this conditionally because we always
// check for pending work before we exit the task.
flushSyncCallbacks();}});}}newCallbackNode=null;}else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.
function performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current
// event time. The next update will compute a new event time.
currentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,
// in case they schedule additional work.
var originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.
// Check if the task node for this root was changed.
if(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call
// `ensureRootIsScheduled` because the check above implies either that
// there's a new task, or that there's no remaining work on this root.
return null;}}// Determine the next lanes to work on, using the fields stored
// on the root.
var lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.
return null;}// We disable time-slicing in some cases: if the work has been CPU-bound
// for too long ("expired" work, to prevent starvation), or we're in
// sync-updates-by-default mode.
// TODO: We only check `didTimeout` defensively, to account for a Scheduler
// bug we're still investigating. Once the bug in Scheduler is fixed,
// we can remove this, since we track expiration ourselves.
var shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll
// render synchronously to block concurrent data mutations, and we'll
// includes all pending updates are included. If it still fails after
// the second attempt, we'll give up and commit the resulting tree.
var errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special
// cases where need to exit the current render without producing a
// consistent tree or committing.
//
// This should only happen during a concurrent render, not a discrete or
// synchronous update. We should have already checked for this when we
// unwound the stack.
markRootSuspended$1(root,lanes);}else{// The render completed.
// Check if this render may have yielded to a concurrent event, and if so,
// confirm that any newly rendered stores are consistent.
// TODO: It's possible that even a concurrent render may never have yielded
// to the main thread, if it was fast enough, or if it expired. We could
// skip the consistency check in that case, too.
var renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,
// synchronously, to block further mutations.
exitStatus=renderRootSync(root,lanes);// We need to check again if something threw
if(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any
// concurrent events.
}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,
// or, if something suspended, wait to commit it after a timeout.
root.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's
// currently executed. Need to return a continuation.
return performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall
// back to client side render.
// Before rendering again, save the errors from the previous attempt.
var errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering
// during the next attempt. To do this, we call prepareFreshStack now
// to create the root work-in-progress fiber. This is a bit weird in terms
// of factoring, because it relies on renderRootSync not calling
// prepareFreshStack again in the call below, which happens because the
// root and lanes haven't changed.
//
// TODO: I think what we should do is set ForceClientRender inside
// throwException, like we do for nested Suspense boundaries. The reason
// it's here instead is so we can switch to the synchronous work loop, too.
// Something to consider for a future refactor.
var rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry
// The errors from the failed first attempt have been recovered. Add
// them to the collection of recoverable errors. We'll log them in the
// commit phase.
var errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors
// from the first attempt, to preserve the causal sequence.
if(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else{workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break
// statement, but eslint doesn't know about invariant, so it complains
// if I do. eslint-disable-next-line no-fallthrough
case RootErrored:{// We should have already attempted to retry this tree. If we reached
// this point, it errored again. Commit it.
commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we
// should immediately commit it or wait a bit.
if(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope
!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing
// retries so that we don't show too many loading states too quickly.
var msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.
if(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.
break;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last
// suspended level. Ping the last suspended level to try
// rendering it again.
// FIXME: What if the suspended lanes are Idle? Should not restart.
var eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no
// lower priority work to do. Instead of committing the fallback
// immediately, wait for more data to arrive.
root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.
commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a
// placeholder and without scheduling a timeout. Delay indefinitely
// until we receive more data.
break;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.
// Schedule a placeholder to display after a short delay, using the Just
// Noticeable Difference.
// TODO: Is the JND optimization worth the added complexity? If this is
// the only reason we track the event time, then probably not.
// Consider removing.
var mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.
if(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data
// to arrive.
root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.
commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.
commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the
// stores were mutated in a concurrent event. Intentionally using an iterative
// loop instead of recursion so we can exit early.
var node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.
return false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule
// a re-render, and the error will be rethrown during render.
return false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child.return=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return true;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does
// eslint-disable-next-line no-unreachable
return true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more
// rarely, since we try to avoid it) updated during the render phase.
// TODO: Lol maybe there's a better way to factor this besides this
// obnoxiously named function :)
suspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go
// through Scheduler
function performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.
ensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render
// synchronously to block concurrent data mutations, and we'll includes
// all pending updates are included. If it still fails after the second
// attempt, we'll give up and commit the resulting tree.
var errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we
// will commit it even if something suspended.
var finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next
// pending level.
ensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer
// most batchedUpdates-like method.
if(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.
// Warning, this opts-out of checking the function body.
// eslint-disable-next-line no-redeclare
function flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the
// next event, not at the end of the previous one.
if(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else{return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.
// Note that this will happen even if batchedUpdates is higher up
// the stack.
if((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from
// the wrong context.
return(executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback
// state. Now that we have additional work, cancel the timeout.
root.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
cancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress.return;while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork.return;}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;enqueueInterleavedUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.
resetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a
// separate issue. Write a regression test using string refs.
ReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork.return===null){// Expected to be working on a non-root fiber. This is a fatal error
// because there's no ancestor that can handle it; the root is
// supposed to capture all errors that weren't caught by an error
// boundary.
workInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next
// sibling, or the parent if there are no siblings. But since the root
// has no siblings nor a parent, we set it to null. Usually this is
// handled by `completeUnitOfWork` or `unwindWork`, but since we're
// intentionally not calling those, we need set it here.
// TODO: Consider calling `unwindWork` to pop the contexts.
workInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This
// avoids inaccurate Profiler durations in the case of a
// suspended render.
stopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&_typeof(thrownValue)==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else{markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.
thrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing
// the error. Bubble it to the next boundary.
erroredWork=erroredWork.return;workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.
return;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.
// Instead the first renderer will lazily attach one, in order to give
// nicer error messages.
return ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked
// this render.
if(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on
// the updates that were skipped. Usually we only suspend at the end of
// the render phase.
// TODO: We should probably always mark the root as suspended immediately
// (inside this function), since by suspending at the end of the render
// phase introduces a potential mistake where we suspend lanes that were
// pinged or updated while we were rendering.
markRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else{workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.
// Returns false if we're not sure.
function renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,
// so those are false.
return workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack
// and prepare a fresh one. Otherwise we'll continue where we left off.
if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.
// If we bailout on this work, we'll move them back (like above).
// It's important to move them now in case the work spawns more work at the same priority with different updaters.
// That way we can keep the current update and future updates separate.
movePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.
throw new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.
workInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.
/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.
while(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack
// and prepare a fresh one. Otherwise we'll continue where we left off.
if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.
// If we bailout on this work, we'll move them back (like above).
// It's important to move them now in case the work spawns more work at the same priority with different updaters.
// That way we can keep the current update and future updates separate.
movePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.
{markRenderYielded();}return RootInProgress;}else{// Completed the tree.
{markRenderStopped();}// Set this to null to indicate there's no in-progress render.
workInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.
return workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield
while(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally
// nothing should rely on this, but relying on it here means that we don't
// need an additional field on the work in progress.
var current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.
completeUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next
// sibling. If there are no more siblings, return to the parent fiber.
var completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally
// nothing should rely on this, but relying on it here means that we don't
// need an additional field on the work in progress.
var current=completedWork.alternate;var returnFiber=completedWork.return;// Check if the work completed or if something threw.
if((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.
stopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.
workInProgress=next;return;}}else{// This fiber did not complete because something threw. Pop values off
// the stack without entering the complete phase. If this is a boundary,
// capture values if possible.
var _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.
if(_next!==null){// If completing this work spawned new work, do that next. We'll come
// back here again.
// Since we're restarting, remove anything that is not a host effect
// from the effect tag.
_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.
stopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.
var actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.
returnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else{// We've unwound all the way to the root.
workInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
workInProgress=siblingFiber;return;}// Otherwise, return to the parent
completedWork=returnFiber;// Update the next thing we're working on in case something throws.
workInProgress=completedWork;}while(completedWork!==null);// We've reached the root.
if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and
// layout phases. Should be able to remove.
var previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
// means `flushPassiveEffects` will sometimes result in additional
// passive effects. So we need to keep flushing in a loop until there are
// no more pending effects.
// TODO: Might be better if `flushPassiveEffects` did not automatically
// flush synchronous work at the end, to avoid factoring hazards like this.
flushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else{{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.
// So we can clear these now to allow a new callback to be scheduled.
root.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first
// pending time is whatever is left on the root fiber.
var remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.
workInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.
// Do this as early as possible, so it is queued before anything else that
// might get scheduled in the commit phase. (See #16714.)
// TODO: Delete all other places that schedule the passive effect callback
// They're redundant.
if((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed
// We need to pass this through as an argument to commitRoot
// because workInProgressTransitions might have changed between
// the previous render and commit if we throttle the commit
// with setTimeout
pendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool
// *after* passive effects fire to avoid freeing a cache pool that may
// be referenced by a node in the tree (HostRoot, Cache boundary etc)
return null;});}}// Check if there are any effects in the whole tree.
// TODO: This is left over from the effect list implementation, where we had
// to check for the existence of `firstEffect` to satisfy Flow. I think the
// only other reason this optimization exists is because it affects profiling.
// Reconsider whether this is necessary.
var subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles
ReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass
// of the effect list for each phase: all mutation effects come before all
// layout effects, and so on.
// The first phase a "before mutation" phase. We use this phase to read the
// state of the host tree right before we mutate it. This is where
// getSnapshotBeforeUpdate is called.
var shouldFireAfterActiveInstanceBlur=commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this
// batch. This enables them to be grouped later.
recordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after
// the mutation phase, so that the previous tree is still current during
// componentWillUnmount, but before the layout phase, so that the finished
// work is current during componentDidMount/Update.
root.current=finishedWork;// The next phase is the layout phase, where we call effects that read
{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.
requestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.
setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else{// No effects.
root.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were
// no effects.
// TODO: Maybe there's a better way to report this.
{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't
// schedule a callback until after flushing layout work.
rootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else{{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it
remainingLanes=root.pendingLanes;// Check if there's remaining work on this root
// TODO: This is part of the `componentDidCatch` implementation. Its purpose
// is to detect whether something might have called setState inside
// `componentDidCatch`. The mechanism is known to be flawed because `setState`
// inside `componentDidCatch` is itself flawed — that's why we recommend
// `getDerivedStateFromError` instead. However, it could be improved by
// checking if remainingLanes includes Sync work, instead of whether there's
// any work remaining at all (which would also include stuff like Suspense
// retries or transitions). It's been like this for a while, though, so fixing
// it probably isn't that urgent.
if(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed
// error boundaries.
legacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any
// additional work on this root is scheduled.
ensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without
// needing to surface it to the UI. We log them here.
var onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];onRecoverableError(recoverableError);}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them
// synchronously at the end of the current task so that the result is
// immediately observable. Otherwise, we assume that they are not
// order-dependent and do not need to be observed by external systems, so we
// can wait until after paint.
// TODO: We can optimize this by not scheduling the callback earlier. Since we
// currently schedule the callback in multiple places, will wait until those
// are consolidated.
if(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it
remainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without
// finishing. If there are too many, it indicates an infinite update loop.
if(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}// If layout work was scheduled, flush it now.
flushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.
// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should
// probably just combine the two functions. I believe they were only separate
// in the first place because we used to wrap it with
// `Scheduler.runWithPriority`, which accepts a function. But now we track the
// priority within React itself, so we can mutate the variable directly.
if(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a
}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag
var transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.
// Figure out why and fix it. It's not causing any known issues (probably
// because it's only used for profiling), but it's a refactor hazard.
pendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects
{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this
// exceeds the limit, we'll fire a warning.
if(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else{nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects
onPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValue(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);enqueueUpdate(rootFiber,update);var eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(rootFiber,SyncLane);if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root
// itself should capture it.
captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValue(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);enqueueUpdate(fiber,update);var eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(fiber,SyncLane);if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber.return;}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning
// will fire for errors that are thrown by destroy functions inside deleted
// trees. What it should instead do is propagate the error to the parent of
// the deleted tree. In the meantime, do not add this warning to the
// allowlist; this is only for our internal use.
error('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\n\n'+'Error message:\n\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will
// never be thrown again.
pingCache.delete(wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently
// rendering. We might want to restart this render. This should mirror
// the logic of whether or not a root suspends once it completes.
// TODO: If we're rendering sync either due to Sync, Batched or expired,
// we should probably never restart.
// If we're suspended with delay, or if it's a retry, we'll always suspend
// so we can always restart.
if(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.
prepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an
// opportunity later. So we mark this render as having a ping.
workInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)
// previously was rendered in its fallback state. One of the promises that
// suspended it has resolved, which means at least part of the tree was
// likely unblocked. Try rendering again, at a new lanes.
if(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid
// unnecessary entanglement?
retryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?
var eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default
var retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will
// never be thrown again.
retryCache.delete(wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.
// The theory is that a person can't tell the difference between small differences in time.
// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
// difference in the experience. However, waiting for longer might mean that we can avoid
// showing an intermediate loading state. The longer we have already waited, the harder it
// is to tell small differences in time. Therefore, the longer we've already waited,
// the longer we can wait additionally. At some point we have to give up though.
// We pick a train model where the next boundary commits at a consistent schedule.
// These particular numbers are vague estimates. We expect to adjust them based on research.
function jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+"calls setState inside useEffect, but useEffect either doesn't "+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects
// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.
// Maybe not a big deal since this is DEV only behavior.
setCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.
// This function is only called if that check has already passed.
var current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else{if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else{current=subtreeRoot=current.return;}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.
return;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.
return;}// We show the whole stack but dedupe on the top component's name because
// the problematic code almost always lies inside that component.
var componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error("Can't perform a React state update on a component that hasn't mounted yet. "+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function beginWork$1(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously
// dispatched event, so that the debugger will treat it as an uncaught
// error See ReactErrorUtils for more information.
// Before entering the begin phase, copy the work-in-progress onto a dummy
// fiber. If beginWork throws, we'll use this to reset the state.
var originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(originalError!==null&&_typeof(originalError)==='object'&&typeof originalError.then==='function'){// Don't replay promises. Treat everything else like an error.
throw originalError;}// Keep this code in sync with handleError; any changes here must have
// corresponding changes there.
resetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the
// same fiber again.
// Unwind the failed stack frame
unwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.
assignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.
startProfilerTimer(unitOfWork);}// Run beginWork again.
invokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(_typeof(replayError)==='object'&&replayError!==null&&replayError._suppressLogging&&_typeof(originalError)==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.
originalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.
// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.
throw originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.
var dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.
// Those may still be relevant to the current commit
// and a future one (e.g. Suspense).
}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to
// the `act` queue instead.
var actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else{return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.
return cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.
return ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.
return;}}else{// Legacy mode has additional cases where we suppress a warning.
if(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.
return;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.
// batchedUpdates or flushSync.
return;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only
// warns for updates that originate from a hook.
return;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\n\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\n\n'+'act(() => {\n'+'  /* fire events that update state */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see "+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\n\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\n\n'+'act(() => {\n'+'  /* finish loading suspended data */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see "+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.
var failedBoundaries=null;var setRefreshHandler=function setRefreshHandler(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.
return type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.
return family.current;}}function resolveClassForHotReloading(type){// No implementation differences.
return resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.
return type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.
if(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,
// but it's possible that we only have its inner render function in the map.
// If that inner render function is different, we'll build a new forwardRef type.
var currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.
return family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.
return false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.
var needsCompareFamilies=false;var $$typeofNextType=_typeof(nextType)==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.
// We're going to assume that the lazy inner type is stable,
// and so it is sufficient to avoid reconciling it away.
// We're not going to unwrap or actually use the new lazy type.
needsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,
// we shouldn't set this.
needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.
if(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.
// This means both of them need to be registered to preserve state.
// If we unwrapped and compared the inner types for wrappers instead,
// then we would risk falsely saying two separate memo(Foo)
// calls are equivalent because they wrap the same Foo function.
var prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.
return;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function scheduleRefresh(root,update){{if(resolveFamily===null){// Hot reloading is disabled.
return;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function scheduleRoot(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context
// but we don't know the parentComponent so we can't pass it.
// Just ignore. We'll delete this with _renderSubtree code path later.
return;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function findHostInstancesForRefresh(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.
// There's no need to search deeper because for the purpose of giving
// visual feedback, "flashing" outermost parent rectangles is sufficient.
findHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.
if(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.
var node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node.return===null){throw new Error('Expected to reach root first.');}node=node.return;}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.
foundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.
}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node.return===null||node.return===fiber){return foundHostInstances;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance
this.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber
this.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects
this.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.
//
// Initializing the fields below to smis and later updating them with
// double values will cause Fibers to end up having separate shapes.
// This behavior/bug has something to do with Object.preventExtension().
// Fortunately this only impacts DEV builds.
// Unfortunately it makes React unusably slow for some applications.
// To work around this, initialize the fields below with doubles.
//
// Learn more about this here:
// https://github.com/facebook/react/issues/14365
// https://bugs.chromium.org/p/v8/issues/detail?id=8538
this.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.
// This won't trigger the performance cliff mentioned above,
// and it simplifies other profiler code (including DevTools).
this.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:
this._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.
workInProgress.type=current.type;// We already have an alternate.
// Reset the effect tag.
workInProgress.flags=NoFlags;// The effects are no longer valid.
workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.
// This prevents time from endlessly accumulating in new commits.
// This has the downside of resetting values for different priority renders,
// But works for yielding (the common case) and should support resuming.
workInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.
// Static effects are not specific to a render.
workInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so
// it cannot be shared with the current fiber.
var currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.
function resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would
// have set the values to before during the first pass. Ideally this wouldn't
// be necessary but unfortunately many code paths reads from the workInProgress
// when they should be reading from current and writing to workInProgress.
// We assume pendingProps, index, key, ref, return are still untouched to
// avoid doing another reconciliation.
// Reset the effect flags but keep any Placement tags, since that's something
// that child fiber is setting, not the reconciliation.
workInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.
var current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.
workInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate
// actual time across multiple render passes.
workInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.
workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.
workInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so
// it cannot be shared with the current fiber.
var currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate
// actual time across multiple render passes.
workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.
// This enables DevTools to start capturing timing at any point–
// Without some nodes in the tree having empty base times.
mode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType
key,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.
var resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots
mode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough
case REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough
case REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough
case REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough
case REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough
default:{if(_typeof(type)==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer
fiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||_typeof(type)==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and "+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+("but got: "+(type==null?type:_typeof(type))+"."+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',_typeof(pendingProps.id));}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.
function assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.
// We only use a Fiber to ensure the same hidden class so DEV isn't slow.
target=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.
// We tried to use Object.assign() instead but this is called in
// the hottest path, and Object.assign() was too slow:
// https://github.com/facebook/react/issues/12502
// This code is DEV-only so size is not a concern.
target.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the
// host config, but because they are passed in at runtime, we have to thread
// them through the root constructor. Perhaps we should put them all into a
// single type, like a DynamicHostConfig that is defined by the renderer.
identifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.
var uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet
transitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.1.0';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else{var keys=Object.keys(component).join(',');throw new Error("Argument appears to not be a ReactComponent. Keys: "+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in
// render and there's another warning for that anyway.
if(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.
callback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor
root.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from
// a regular update because the initial render must match was was rendered
// on the server.
// NOTE: This update intentionally doesn't have a payload. We're only using
// the update to schedule work on the root fiber (and, for legacy roots, to
// enqueue the callback if one is provided).
var current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}enqueueUpdate(current$1,update);var root=scheduleUpdateOnFiber(current$1,lane,eventTime);if(root!==null){entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled "update".
var lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;case SuspenseComponent:var eventTime=requestEventTime();flushSync(function(){return scheduleUpdateOnFiber(fiber,SyncLane,eventTime);});// If we're still blocked after this, we need to increase
// the priority of any promises resolving within this
// boundary so that they next attempt also has higher pri.
var retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.
function markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
// their priority and they should not suspend on I/O,
// since you have to wrap anything that might suspend in
// Suspense.
return;}var eventTime=requestEventTime();var lane=SelectiveHydrationLane;scheduleUpdateOnFiber(fiber,lane,eventTime);markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase
// their priority other than synchronously flush it.
return;}var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);scheduleUpdateOnFiber(fiber,lane,eventTime);markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function shouldErrorImpl(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function shouldSuspendImpl(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function copyWithDeleteImpl(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here
updated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function copyWithDelete(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function copyWithRenameImpl(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here
updated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here
updated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here
obj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function copyWithRename(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function copyWithSetImpl(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here
updated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function copyWithSet(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function findHook(fiber,id){// For now, the "id" of stateful hooks is just the stateful hook index.
// This may change in the future with e.g. nested hooks.
var currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.
overrideHookState=function overrideHookState(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};overrideHookStateDeletePath=function overrideHookStateDeletePath(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};overrideHookStateRenamePath=function overrideHookStateRenamePath(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,
// because there is no update we can add for useReducer hooks that won't trigger an error.
// (There's no appropriate action type for DevTools overrides.)
// As a result though, React will see the scheduled update as a noop and bailout.
// Shallow cloning props works as a workaround for now to bypass the bailout check.
fiber.memoizedProps=assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};// Support DevTools props for function components, forwardRef, memo, host components, etc.
overrideProps=function overrideProps(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};overridePropsDeletePath=function overridePropsDeletePath(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};overridePropsRenamePath=function overridePropsRenamePath(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};scheduleUpdate=function scheduleUpdate(fiber){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};setErrorHandler=function setErrorHandler(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function setSuspenseHandler(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh
findHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.
getCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version
// which may not match for third party renderers.
reconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,
// emulating an uncaught JavaScript error.
reportError:function(error){// In older browsers and test environments, fallback to console.error.
// eslint-disable-next-line react-internal/no-production-logging
console['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+"You don't need to pass it again since you already passed it to create the root.");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+"root.unmount() to empty a root's container.");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;var transitionCallbacks=null;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else{if(_typeof(options)==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\n\n'+'  let root = createRoot(domContainer);\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){transitionCallbacks=options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain
// the hydration callbacks.
var hydrationCallbacks=options!=null?options:null;// TODO: Delete this option
var mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.
listenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.
// We only use it in places that are currently more relaxed.
function isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else{error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function topLevelUpdateWarnings(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the
// legacy API.
}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks
false,// isStrictMode
false,// concurrentUpdatesByDefaultOverride,
'',// identifierPrefix
noopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else{// First clear any existing content.
var rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks
false,// isStrictMode
false,// concurrentUpdatesByDefaultOverride,
'',// identifierPrefix
noopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.
flushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount
root=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else{root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update
updateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+"if it's running React 17. Learn "+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?
return legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+"if it's running React 17. Learn "+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+"the createRoot API, your app will behave as if it's running React "+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}function unmountComponentAtNode(container){if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error("unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}}// Unmount should not be batched.
flushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`
container._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error("unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype
Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype
Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument
// $FlowFixMe The Flow type is opaque but there's no way to actually create it.
return createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.
// This is an array for better minification.
Events:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from "react-dom" which is not supported. '+'You should instead import it from "react-dom/client".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from "react-dom" which is not supported. '+'You should instead import it from "react-dom/client".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.
// Warning, this opts-out of checking the function body.
// eslint-disable-next-line no-redeclare
function flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging
console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.createRoot=createRoot$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync$1;exports.hydrate=hydrate;exports.hydrateRoot=hydrateRoot$1;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}

/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



var m = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");

if (false) {} else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  exports.createRoot = function (c, o) {
    i.usingClientEntryPoint = true;

    try {
      return m.createRoot(c, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };

  exports.hydrateRoot = function (c, h, o) {
    i.usingClientEntryPoint = true;

    try {
      return m.hydrateRoot(c, h, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
}

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }

  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }

  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}

/***/ }),

/***/ "./node_modules/react-router-dom/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-router-dom/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserRouter": function() { return /* binding */ BrowserRouter; },
/* harmony export */   "HashRouter": function() { return /* binding */ HashRouter; },
/* harmony export */   "Link": function() { return /* binding */ Link; },
/* harmony export */   "MemoryRouter": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.MemoryRouter; },
/* harmony export */   "NavLink": function() { return /* binding */ NavLink; },
/* harmony export */   "Navigate": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Navigate; },
/* harmony export */   "NavigationType": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Action; },
/* harmony export */   "Outlet": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Outlet; },
/* harmony export */   "Route": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Route; },
/* harmony export */   "Router": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Router; },
/* harmony export */   "Routes": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Routes; },
/* harmony export */   "UNSAFE_LocationContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_LocationContext; },
/* harmony export */   "UNSAFE_NavigationContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_NavigationContext; },
/* harmony export */   "UNSAFE_RouteContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_RouteContext; },
/* harmony export */   "createPath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createPath; },
/* harmony export */   "createRoutesFromChildren": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createRoutesFromChildren; },
/* harmony export */   "createSearchParams": function() { return /* binding */ createSearchParams; },
/* harmony export */   "generatePath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath; },
/* harmony export */   "matchPath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath; },
/* harmony export */   "matchRoutes": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes; },
/* harmony export */   "parsePath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.parsePath; },
/* harmony export */   "renderMatches": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.renderMatches; },
/* harmony export */   "resolvePath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath; },
/* harmony export */   "unstable_HistoryRouter": function() { return /* binding */ HistoryRouter; },
/* harmony export */   "useHref": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useHref; },
/* harmony export */   "useInRouterContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useInRouterContext; },
/* harmony export */   "useLinkClickHandler": function() { return /* binding */ useLinkClickHandler; },
/* harmony export */   "useLocation": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation; },
/* harmony export */   "useMatch": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useMatch; },
/* harmony export */   "useNavigate": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate; },
/* harmony export */   "useNavigationType": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigationType; },
/* harmony export */   "useOutlet": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useOutlet; },
/* harmony export */   "useOutletContext": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useOutletContext; },
/* harmony export */   "useParams": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useParams; },
/* harmony export */   "useResolvedPath": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath; },
/* harmony export */   "useRoutes": function() { return /* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useRoutes; },
/* harmony export */   "useSearchParams": function() { return /* binding */ useSearchParams; }
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router */ "./node_modules/history/index.js");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router */ "./node_modules/react-router/index.js");
var _s2 = $RefreshSig$(),
    _s3 = $RefreshSig$(),
    _s4 = $RefreshSig$(),
    _s5 = $RefreshSig$(),
    _s6 = $RefreshSig$(),
    _s7 = $RefreshSig$(),
    _s8 = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * React Router DOM v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */





function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"],
    _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
} ////////////////////////////////////////////////////////////////////////////////
// COMPONENTS
////////////////////////////////////////////////////////////////////////////////

/**
 * A `<Router>` for use in web browsers. Provides the cleanest URLs.
 */


function BrowserRouter(_ref) {
  _s2();

  var basename = _ref.basename,
      children = _ref.children,
      window = _ref.window;
  var historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({
      window: window
    });
  }

  var history = historyRef.current;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(function () {
    return history.listen(setState);
  }, [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` for use in web browsers. Stores the location in the hash
 * portion of the URL so it is not sent to the server.
 */


_s2(BrowserRouter, "xBkllX203w11M5ursQOw/eiFREA=");

_c = BrowserRouter;

function HashRouter(_ref2) {
  _s3();

  var basename = _ref2.basename,
      children = _ref2.children,
      window = _ref2.window;
  var historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({
      window: window
    });
  }

  var history = historyRef.current;

  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  }),
      _useState4 = _slicedToArray(_useState3, 2),
      state = _useState4[0],
      setState = _useState4[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(function () {
    return history.listen(setState);
  }, [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * A `<Router>` that accepts a pre-instantiated history object. It's important
 * to note that using your own history object is highly discouraged and may add
 * two versions of the history library to your bundles unless you use the same
 * version of the history library that React Router uses internally.
 */


_s3(HashRouter, "xBkllX203w11M5ursQOw/eiFREA=");

_c2 = HashRouter;

function HistoryRouter(_ref3) {
  _s4();

  var basename = _ref3.basename,
      children = _ref3.children,
      history = _ref3.history;

  var _useState5 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  }),
      _useState6 = _slicedToArray(_useState5, 2),
      state = _useState6[0],
      setState = _useState6[1];

  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(function () {
    return history.listen(setState);
  }, [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}

_s4(HistoryRouter, "OGpdbS2RMHnauIKqLfMDc/MR36A=");

_c3 = HistoryRouter;

if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
/**
 * The public API for rendering a history-aware <a>.
 */


var Link = /*#__PURE__*/_s5( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c4 = _s5(function LinkWithRef(_ref4, ref) {
  _s5();

  var onClick = _ref4.onClick,
      reloadDocument = _ref4.reloadDocument,
      _ref4$replace = _ref4.replace,
      replace = _ref4$replace === void 0 ? false : _ref4$replace,
      state = _ref4.state,
      target = _ref4.target,
      to = _ref4.to,
      rest = _objectWithoutPropertiesLoose(_ref4, _excluded);

  var href = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useHref)(to);
  var internalOnClick = useLinkClickHandler(to, {
    replace: replace,
    state: state,
    target: target
  });

  function handleClick(event) {
    if (onClick) onClick(event);

    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }

  return (
    /*#__PURE__*/
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("a", _extends({}, rest, {
      href: href,
      onClick: handleClick,
      ref: ref,
      target: target
    }))
  );
}, "pEvj8SbOacfqVwYI9UN72A3R6gk=", false, function () {
  return [react_router__WEBPACK_IMPORTED_MODULE_1__.useHref, useLinkClickHandler];
})), "pEvj8SbOacfqVwYI9UN72A3R6gk=", false, function () {
  return [react_router__WEBPACK_IMPORTED_MODULE_1__.useHref, useLinkClickHandler];
});

_c5 = Link;

if (true) {
  Link.displayName = "Link";
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


var NavLink = /*#__PURE__*/_s6( /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c6 = _s6(function NavLinkWithRef(_ref5, ref) {
  _s6();

  var _ref5$ariaCurrent = _ref5["aria-current"],
      ariaCurrentProp = _ref5$ariaCurrent === void 0 ? "page" : _ref5$ariaCurrent,
      _ref5$caseSensitive = _ref5.caseSensitive,
      caseSensitive = _ref5$caseSensitive === void 0 ? false : _ref5$caseSensitive,
      _ref5$className = _ref5.className,
      classNameProp = _ref5$className === void 0 ? "" : _ref5$className,
      _ref5$end = _ref5.end,
      end = _ref5$end === void 0 ? false : _ref5$end,
      styleProp = _ref5.style,
      to = _ref5.to,
      children = _ref5.children,
      rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);

  var location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  var path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath)(to);
  var locationPathname = location.pathname;
  var toPathname = path.pathname;

  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }

  var isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  var ariaCurrent = isActive ? ariaCurrentProp : undefined;
  var className;

  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive: isActive
    });
  } else {
    // If the className prop is not a function, we use a default `active`
    // class for <NavLink />s that are active. In v5 `active` was the default
    // value for `activeClassName`, but we are removing that API and can still
    // use the old default behavior for a cleaner upgrade path and keep the
    // simple styling rules working as they currently do.
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }

  var style = typeof styleProp === "function" ? styleProp({
    isActive: isActive
  }) : styleProp;
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className: className,
    ref: ref,
    style: style,
    to: to
  }), typeof children === "function" ? children({
    isActive: isActive
  }) : children);
}, "9me60qxxw1L7CgxSsArJGVzGyJk=", false, function () {
  return [react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation, react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath];
})), "9me60qxxw1L7CgxSsArJGVzGyJk=", false, function () {
  return [react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation, react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath];
});

_c7 = NavLink;

if (true) {
  NavLink.displayName = "NavLink";
} ////////////////////////////////////////////////////////////////////////////////
// HOOKS
////////////////////////////////////////////////////////////////////////////////

/**
 * Handles the click behavior for router `<Link>` components. This is useful if
 * you need to create custom `<Link>` components with the same click behavior we
 * use in our exported `<Link>`.
 */


function useLinkClickHandler(to, _temp) {
  _s7();

  var _ref6 = _temp === void 0 ? {} : _temp,
      target = _ref6.target,
      replaceProp = _ref6.replace,
      state = _ref6.state;

  var navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();
  var location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  var path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath)(to);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (event) {
    if (event.button === 0 && ( // Ignore everything but left clicks
    !target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event) // Ignore clicks with modifier keys
    ) {
      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of
      // a push, so do the same here.

      var replace = !!replaceProp || (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);
      navigate(to, {
        replace: replace,
        state: state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}
/**
 * A convenient wrapper for reading and writing search parameters via the
 * URLSearchParams interface.
 */


_s7(useLinkClickHandler, "BZYjyGAa1ZxLRntdbX23tSdFTkI=", false, function () {
  return [react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate, react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation, react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath];
});

function useSearchParams(defaultInit) {
  _s8();

   true ? warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not " + "support the URLSearchParams API. If you need to support Internet " + "Explorer 11, we recommend you load a polyfill such as " + "https://github.com/ungap/url-search-params\n\n" + "If you're unsure how to load polyfills, we recommend you check out " + "https://polyfill.io/v3/ which provides some recommendations about how " + "to load polyfills only for users that need them, instead of for every " + "user.") : 0;
  var defaultSearchParamsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(createSearchParams(defaultInit));
  var location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  var searchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {
    var searchParams = createSearchParams(location.search);

    var _iterator = _createForOfIteratorHelper(defaultSearchParamsRef.current.keys()),
        _step;

    try {
      var _loop = function _loop() {
        var key = _step.value;

        if (!searchParams.has(key)) {
          defaultSearchParamsRef.current.getAll(key).forEach(function (value) {
            searchParams.append(key, value);
          });
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return searchParams;
  }, [location.search]);
  var navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();
  var setSearchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (nextInit, navigateOptions) {
    navigate("?" + createSearchParams(nextInit), navigateOptions);
  }, [navigate]);
  return [searchParams, setSearchParams];
}
/**
 * Creates a URLSearchParams object using the given initializer.
 *
 * This is identical to `new URLSearchParams(init)` except it also
 * supports arrays as values in the object form of the initializer
 * instead of just strings. This is convenient when you need multiple
 * values for a given key, but don't want to use an array initializer.
 *
 * For example, instead of:
 *
 *   let searchParams = new URLSearchParams([
 *     ['sort', 'name'],
 *     ['sort', 'price']
 *   ]);
 *
 * you can do:
 *
 *   let searchParams = createSearchParams({
 *     sort: ['name', 'price']
 *   });
 */


_s8(useSearchParams, "IxGGklaZRZ8iX7wVums0r91Bix0=", false, function () {
  return [react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation, react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate];
});

function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }

  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce(function (memo, key) {
    var value = init[key];
    return memo.concat(Array.isArray(value) ? value.map(function (v) {
      return [key, v];
    }) : [[key, value]]);
  }, []));
}



var _c, _c2, _c3, _c4, _c5, _c6, _c7;

$RefreshReg$(_c, "BrowserRouter");
$RefreshReg$(_c2, "HashRouter");
$RefreshReg$(_c3, "HistoryRouter");
$RefreshReg$(_c4, "Link$forwardRef");
$RefreshReg$(_c5, "Link");
$RefreshReg$(_c6, "NavLink$forwardRef");
$RefreshReg$(_c7, "NavLink");

/***/ }),

/***/ "./node_modules/react-router/index.js":
/*!********************************************!*\
  !*** ./node_modules/react-router/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MemoryRouter": function() { return /* binding */ MemoryRouter; },
/* harmony export */   "Navigate": function() { return /* binding */ Navigate; },
/* harmony export */   "NavigationType": function() { return /* reexport safe */ history__WEBPACK_IMPORTED_MODULE_0__.Action; },
/* harmony export */   "Outlet": function() { return /* binding */ Outlet; },
/* harmony export */   "Route": function() { return /* binding */ Route; },
/* harmony export */   "Router": function() { return /* binding */ Router; },
/* harmony export */   "Routes": function() { return /* binding */ Routes; },
/* harmony export */   "UNSAFE_LocationContext": function() { return /* binding */ LocationContext; },
/* harmony export */   "UNSAFE_NavigationContext": function() { return /* binding */ NavigationContext; },
/* harmony export */   "UNSAFE_RouteContext": function() { return /* binding */ RouteContext; },
/* harmony export */   "createPath": function() { return /* reexport safe */ history__WEBPACK_IMPORTED_MODULE_0__.createPath; },
/* harmony export */   "createRoutesFromChildren": function() { return /* binding */ createRoutesFromChildren; },
/* harmony export */   "generatePath": function() { return /* binding */ generatePath; },
/* harmony export */   "matchPath": function() { return /* binding */ matchPath; },
/* harmony export */   "matchRoutes": function() { return /* binding */ matchRoutes; },
/* harmony export */   "parsePath": function() { return /* reexport safe */ history__WEBPACK_IMPORTED_MODULE_0__.parsePath; },
/* harmony export */   "renderMatches": function() { return /* binding */ renderMatches; },
/* harmony export */   "resolvePath": function() { return /* binding */ resolvePath; },
/* harmony export */   "useHref": function() { return /* binding */ useHref; },
/* harmony export */   "useInRouterContext": function() { return /* binding */ useInRouterContext; },
/* harmony export */   "useLocation": function() { return /* binding */ useLocation; },
/* harmony export */   "useMatch": function() { return /* binding */ useMatch; },
/* harmony export */   "useNavigate": function() { return /* binding */ useNavigate; },
/* harmony export */   "useNavigationType": function() { return /* binding */ useNavigationType; },
/* harmony export */   "useOutlet": function() { return /* binding */ useOutlet; },
/* harmony export */   "useOutletContext": function() { return /* binding */ useOutletContext; },
/* harmony export */   "useParams": function() { return /* binding */ useParams; },
/* harmony export */   "useResolvedPath": function() { return /* binding */ useResolvedPath; },
/* harmony export */   "useRoutes": function() { return /* binding */ useRoutes; }
/* harmony export */ });
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
var _s2 = $RefreshSig$(),
    _s3 = $RefreshSig$(),
    _s4 = $RefreshSig$(),
    _s5 = $RefreshSig$(),
    _s6 = $RefreshSig$(),
    _s7 = $RefreshSig$(),
    _s8 = $RefreshSig$(),
    _s9 = $RefreshSig$(),
    _s10 = $RefreshSig$(),
    _s11 = $RefreshSig$(),
    _s12 = $RefreshSig$(),
    _s13 = $RefreshSig$(),
    _s14 = $RefreshSig$(),
    _s15 = $RefreshSig$(),
    _s16 = $RefreshSig$(),
    _s17 = $RefreshSig$();

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/**
 * React Router v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



var NavigationContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);

if (true) {
  NavigationContext.displayName = "Navigation";
}

var LocationContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);

if (true) {
  LocationContext.displayName = "Location";
}

var RouteContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({
  outlet: null,
  matches: []
});

if (true) {
  RouteContext.displayName = "Route";
}

function invariant(cond, message) {
  if (!cond) throw new Error(message);
}

function warning(cond, message) {
  if (!cond) {
    // eslint-disable-next-line no-console
    if (typeof console !== "undefined") console.warn(message);

    try {
      // Welcome to debugging React Router!
      //
      // This error is thrown as a convenience so you can more easily
      // find the source for a warning that appears in the console by
      // enabling "pause on exceptions" in your JavaScript debugger.
      throw new Error(message); // eslint-disable-next-line no-empty
    } catch (e) {}
  }
}

var alreadyWarned = {};

function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     true ? warning(false, message) : 0;
  }
}
/**
 * Returns a path with params interpolated.
 *
 * @see https://reactrouter.com/docs/en/v6/api#generatepath
 */


function generatePath(path, params) {
  if (params === void 0) {
    params = {};
  }

  return path.replace(/:(\w+)/g, function (_, key) {
    !(params[key] != null) ?  true ? invariant(false, "Missing \":" + key + "\" param") : 0 : void 0;
    return params[key];
  }).replace(/\/*\*$/, function (_) {
    return params["*"] == null ? "" : params["*"].replace(/^\/*/, "/");
  });
}
/**
 * A RouteMatch contains info about how a route matched a URL.
 */

/**
 * Matches the given routes to a location and returns the match data.
 *
 * @see https://reactrouter.com/docs/en/v6/api#matchroutes
 */


function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }

  var location = typeof locationArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationArg) : locationArg;
  var pathname = stripBasename(location.pathname || "/", basename);

  if (pathname == null) {
    return null;
  }

  var branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  var matches = null;

  for (var i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }

  return matches;
}

function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }

  if (parentsMeta === void 0) {
    parentsMeta = [];
  }

  if (parentPath === void 0) {
    parentPath = "";
  }

  routes.forEach(function (route, index) {
    var meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route: route
    };

    if (meta.relativePath.startsWith("/")) {
      !meta.relativePath.startsWith(parentPath) ?  true ? invariant(false, "Absolute route path \"" + meta.relativePath + "\" nested under path " + ("\"" + parentPath + "\" is not valid. An absolute child route path ") + "must start with the combined path of all its parent routes.") : 0 : void 0;
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }

    var path = joinPaths([parentPath, meta.relativePath]);
    var routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the
    // route tree depth-first and child routes appear before their parents in
    // the "flattened" version.

    if (route.children && route.children.length > 0) {
      !(route.index !== true) ?  true ? invariant(false, "Index routes must not have child routes. Please remove " + ("all child routes from route path \"" + path + "\".")) : 0 : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    } // Routes without a path shouldn't ever match by themselves unless they are
    // index routes, so don't add them to the list of possible branches.


    if (route.path == null && !route.index) {
      return;
    }

    branches.push({
      path: path,
      score: computeScore(path, route.index),
      routesMeta: routesMeta
    });
  });
  return branches;
}

function rankRouteBranches(branches) {
  branches.sort(function (a, b) {
    return a.score !== b.score ? b.score - a.score // Higher score first
    : compareIndexes(a.routesMeta.map(function (meta) {
      return meta.childrenIndex;
    }), b.routesMeta.map(function (meta) {
      return meta.childrenIndex;
    }));
  });
}

var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;

var isSplat = function isSplat(s) {
  return s === "*";
};

function computeScore(path, index) {
  var segments = path.split("/");
  var initialScore = segments.length;

  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }

  if (index) {
    initialScore += indexRouteValue;
  }

  return segments.filter(function (s) {
    return !isSplat(s);
  }).reduce(function (score, segment) {
    return score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue);
  }, initialScore);
}

function compareIndexes(a, b) {
  var siblings = a.length === b.length && a.slice(0, -1).every(function (n, i) {
    return n === b[i];
  });
  return siblings ? // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}

function matchRouteBranch(branch, pathname) {
  var routesMeta = branch.routesMeta;
  var matchedParams = {};
  var matchedPathname = "/";
  var matches = [];

  for (var i = 0; i < routesMeta.length; ++i) {
    var meta = routesMeta[i];
    var end = i === routesMeta.length - 1;
    var remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    var match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end
    }, remainingPathname);
    if (!match) return null;
    Object.assign(matchedParams, match.params);
    var route = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route: route
    });

    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }

  return matches;
}
/**
 * A PathPattern is used to match on some portion of a URL pathname.
 */

/**
 * Performs pattern matching on a URL pathname and returns information about
 * the match.
 *
 * @see https://reactrouter.com/docs/en/v6/api#matchpath
 */


function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }

  var _compilePath = compilePath(pattern.path, pattern.caseSensitive, pattern.end),
      _compilePath2 = _slicedToArray(_compilePath, 2),
      matcher = _compilePath2[0],
      paramNames = _compilePath2[1];

  var match = pathname.match(matcher);
  if (!match) return null;
  var matchedPathname = match[0];
  var pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  var captureGroups = match.slice(1);
  var params = paramNames.reduce(function (memo, paramName, index) {
    // We need to compute the pathnameBase here using the raw splat value
    // instead of using params["*"] later because it will be decoded then
    if (paramName === "*") {
      var splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }

    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params: params,
    pathname: matchedPathname,
    pathnameBase: pathnameBase,
    pattern: pattern
  };
}

function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }

  if (end === void 0) {
    end = true;
  }

   true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), "Route path \"" + path + "\" will be treated as if it were " + ("\"" + path.replace(/\*$/, "/*") + "\" because the `*` character must ") + "always follow a `/` in the pattern. To get rid of this warning, " + ("please change the route path to \"" + path.replace(/\*$/, "/*") + "\".")) : 0;
  var paramNames = [];
  var regexpSource = "^" + path.replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
  .replace(/^\/*/, "/") // Make sure it has a leading /
  .replace(/[\\.*+^$?{}|()[\]]/g, "\\$&") // Escape special regex chars
  .replace(/:(\w+)/g, function (_, paramName) {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });

  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" // Already matched the initial /, just match the rest
    : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
  } else {
    regexpSource += end ? "\\/*$" // When matching to the end, ignore trailing slashes
    : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts
    // parent routes to matching only their own words and nothing more, e.g. parent
    // route "/home" should not match "/home2".
    // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,
    // but do not consume the character in the matched path so they can match against
    // nested paths.
    "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
  }

  var matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
  return [matcher, paramNames];
}

function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
     true ? warning(false, "The value for the URL param \"" + paramName + "\" will not be decoded because" + (" the string \"" + value + "\" is a malformed URL segment. This is probably") + (" due to a bad percent encoding (" + error + ").")) : 0;
    return value;
  }
}
/**
 * Returns a resolved path object relative to the given pathname.
 *
 * @see https://reactrouter.com/docs/en/v6/api#resolvepath
 */


function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }

  var _ref5 = typeof to === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(to) : to,
      toPathname = _ref5.pathname,
      _ref5$search = _ref5.search,
      search = _ref5$search === void 0 ? "" : _ref5$search,
      _ref5$hash = _ref5.hash,
      hash = _ref5$hash === void 0 ? "" : _ref5$hash;

  var pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname: pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}

function resolvePathname(relativePath, fromPathname) {
  var segments = fromPathname.replace(/\/+$/, "").split("/");
  var relativeSegments = relativePath.split("/");
  relativeSegments.forEach(function (segment) {
    if (segment === "..") {
      // Keep the root "" segment so the pathname starts at /
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}

function resolveTo(toArg, routePathnames, locationPathname) {
  var to = typeof toArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(toArg) : toArg;
  var toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname; // If a pathname is explicitly provided in `to`, it should be relative to the
  // route context. This is explained in `Note on `<Link to>` values` in our
  // migration guide from v5 as a means of disambiguation between `to` values
  // that begin with `/` and those that do not. However, this is problematic for
  // `to` values that do not provide a pathname. `to` can simply be a search or
  // hash string, in which case we should assume that the navigation is relative
  // to the current location's pathname and *not* the route pathname.

  var from;

  if (toPathname == null) {
    from = locationPathname;
  } else {
    var routePathnameIndex = routePathnames.length - 1;

    if (toPathname.startsWith("..")) {
      var toSegments = toPathname.split("/"); // Each leading .. segment means "go up one route" instead of "go up one
      // URL segment".  This is a key difference from how <a href> works and a
      // major reason we call this a "to" value instead of a "href".

      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }

      to.pathname = toSegments.join("/");
    } // If there are more ".." segments than parent routes, resolve relative to
    // the root / URL.


    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }

  var path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original to value had one.

  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }

  return path;
}

function getToPathname(to) {
  // Empty strings should be treated the same as / paths
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(to).pathname : to.pathname;
}

function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;

  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }

  var nextChar = pathname.charAt(basename.length);

  if (nextChar && nextChar !== "/") {
    // pathname does not start with basename/
    return null;
  }

  return pathname.slice(basename.length) || "/";
}

var joinPaths = function joinPaths(paths) {
  return paths.join("/").replace(/\/\/+/g, "/");
};

var normalizePathname = function normalizePathname(pathname) {
  return pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
};

var normalizeSearch = function normalizeSearch(search) {
  return !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
};

var normalizeHash = function normalizeHash(hash) {
  return !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
};
/**
 * Returns the full href for the given "to" value. This is useful for building
 * custom links that are also accessible and preserve right-click behavior.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usehref
 */


function useHref(to) {
  _s2();

  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useHref() may be used only in the context of a <Router> component.") : 0 : void 0;

  var _useContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NavigationContext),
      basename = _useContext.basename,
      navigator = _useContext.navigator;

  var _useResolvedPath = useResolvedPath(to),
      hash = _useResolvedPath.hash,
      pathname = _useResolvedPath.pathname,
      search = _useResolvedPath.search;

  var joinedPathname = pathname;

  if (basename !== "/") {
    var toPathname = getToPathname(to);
    var endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }

  return navigator.createHref({
    pathname: joinedPathname,
    search: search,
    hash: hash
  });
}
/**
 * Returns true if this component is a descendant of a <Router>.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext
 */


_s2(useHref, "rGGf6evAqoN3mWGkxXhzdvQMWyw=", false, function () {
  return [useInRouterContext, useResolvedPath];
});

function useInRouterContext() {
  _s3();

  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocationContext) != null;
}
/**
 * Returns the current location object, which represents the current URL in web
 * browsers.
 *
 * Note: If you're using this it may mean you're doing some of your own
 * "routing" in your app, and we'd like to know what your use case is. We may
 * be able to provide something higher-level to better suit your needs.
 *
 * @see https://reactrouter.com/docs/en/v6/api#uselocation
 */


_s3(useInRouterContext, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

function useLocation() {
  _s4();

  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useLocation() may be used only in the context of a <Router> component.") : 0 : void 0;
  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocationContext).location;
}
/**
 * Returns the current navigation action which describes how the router came to
 * the current location, either by a pop, push, or replace on the history stack.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype
 */


_s4(useLocation, "pnBsrBzOSKrTAsifUkfhXR0cM+Y=", false, function () {
  return [useInRouterContext];
});

function useNavigationType() {
  _s5();

  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(LocationContext).navigationType;
}
/**
 * Returns true if the URL for the given "to" value matches the current URL.
 * This is useful for components that need to know "active" state, e.g.
 * <NavLink>.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usematch
 */


_s5(useNavigationType, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

function useMatch(pattern) {
  _s6();

  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useMatch() may be used only in the context of a <Router> component.") : 0 : void 0;

  var _useLocation = useLocation(),
      pathname = _useLocation.pathname;

  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {
    return matchPath(pattern, pathname);
  }, [pathname, pattern]);
}
/**
 * The interface for the navigate() function returned from useNavigate().
 */

/**
 * Returns an imperative method for changing the location. Used by <Link>s, but
 * may also be used by other elements to change the location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#usenavigate
 */


_s6(useMatch, "nQeQy8ml7gNYO2EbpP3HWNGpSDs=", false, function () {
  return [useInRouterContext, useLocation];
});

function useNavigate() {
  _s7();

  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useNavigate() may be used only in the context of a <Router> component.") : 0 : void 0;

  var _useContext2 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NavigationContext),
      basename = _useContext2.basename,
      navigator = _useContext2.navigator;

  var _useContext3 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext),
      matches = _useContext3.matches;

  var _useLocation2 = useLocation(),
      locationPathname = _useLocation2.pathname;

  var routePathnamesJson = JSON.stringify(matches.map(function (match) {
    return match.pathnameBase;
  }));
  var activeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    activeRef.current = true;
  });
  var navigate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (to, options) {
    if (options === void 0) {
      options = {};
    }

     true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when " + "your component is first rendered.") : 0;
    if (!activeRef.current) return;

    if (typeof to === "number") {
      navigator.go(to);
      return;
    }

    var path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);

    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }

    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}

_s7(useNavigate, "MlTGUpTEqKWdu1Z5b4+GfXtSXcc=", false, function () {
  return [useInRouterContext, useLocation];
});

var OutletContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);
/**
 * Returns the context (if provided) for the child route at this level of the route
 * hierarchy.
 * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext
 */

function useOutletContext() {
  _s8();

  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(OutletContext);
}
/**
 * Returns the element for the child route at this level of the route
 * hierarchy. Used internally by <Outlet> to render child routes.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useoutlet
 */


_s8(useOutletContext, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

function useOutlet(context) {
  _s9();

  var outlet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext).outlet;

  if (outlet) {
    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }

  return outlet;
}
/**
 * Returns an object of key/value pairs of the dynamic params from the current
 * URL that were matched by the route path.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useparams
 */


_s9(useOutlet, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

function useParams() {
  _s10();

  var _useContext4 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext),
      matches = _useContext4.matches;

  var routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
/**
 * Resolves the pathname of the given `to` value against the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath
 */


_s10(useParams, "KZfdG8ZL0oSOy0/P9JYAG6JDDJw=");

function useResolvedPath(to) {
  _s11();

  var _useContext5 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext),
      matches = _useContext5.matches;

  var _useLocation3 = useLocation(),
      locationPathname = _useLocation3.pathname;

  var routePathnamesJson = JSON.stringify(matches.map(function (match) {
    return match.pathnameBase;
  }));
  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {
    return resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
  }, [to, routePathnamesJson, locationPathname]);
}
/**
 * Returns the element of the route that matched the current location, prepared
 * with the correct context to render the remainder of the route tree. Route
 * elements in the tree must render an <Outlet> to render their child route's
 * element.
 *
 * @see https://reactrouter.com/docs/en/v6/api#useroutes
 */


_s11(useResolvedPath, "1kUG8VoyxD8cfQsTbrrtTZ4fufw=", false, function () {
  return [useLocation];
});

function useRoutes(routes, locationArg) {
  _s12();

  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  "useRoutes() may be used only in the context of a <Router> component.") : 0 : void 0;

  var _useContext6 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(RouteContext),
      parentMatches = _useContext6.matches;

  var routeMatch = parentMatches[parentMatches.length - 1];
  var parentParams = routeMatch ? routeMatch.params : {};
  var parentPathname = routeMatch ? routeMatch.pathname : "/";
  var parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  var parentRoute = routeMatch && routeMatch.route;

  if (true) {
    // You won't get a warning about 2 different <Routes> under a <Route>
    // without a trailing *, but this is a best-effort warning anyway since we
    // cannot even give the warning unless they land at the parent route.
    //
    // Example:
    //
    // <Routes>
    //   {/* This route path MUST end with /* because otherwise
    //       it will never match /blog/post/123 */}
    //   <Route path="blog" element={<Blog />} />
    //   <Route path="blog/feed" element={<BlogFeed />} />
    // </Routes>
    //
    // function Blog() {
    //   return (
    //     <Routes>
    //       <Route path="post/:id" element={<Post />} />
    //     </Routes>
    //   );
    // }
    var parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ("\"" + parentPathname + "\" (under <Route path=\"" + parentPath + "\">) but the ") + "parent route path has no trailing \"*\". This means if you navigate " + "deeper, the parent won't match anymore and therefore the child " + "routes will never render.\n\n" + ("Please change the parent <Route path=\"" + parentPath + "\"> to <Route ") + ("path=\"" + (parentPath === "/" ? "*" : parentPath + "/*") + "\">."));
  }

  var locationFromContext = useLocation();
  var location;

  if (locationArg) {
    var _parsedLocationArg$pa;

    var parsedLocationArg = typeof locationArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, " + "the location pathname must begin with the portion of the URL pathname that was " + ("matched by all parent routes. The current pathname base is \"" + parentPathnameBase + "\" ") + ("but pathname \"" + parsedLocationArg.pathname + "\" was given in the `location` prop.")) : 0 : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }

  var pathname = location.pathname || "/";
  var remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  var matches = matchRoutes(routes, {
    pathname: remainingPathname
  });

  if (true) {
     true ? warning(parentRoute || matches != null, "No routes matched location \"" + location.pathname + location.search + location.hash + "\" ") : 0;
     true ? warning(matches == null || matches[matches.length - 1].route.element !== undefined, "Matched leaf route at location \"" + location.pathname + location.search + location.hash + "\" does not have an element. " + "This means it will render an <Outlet /> with a null value by default resulting in an \"empty\" page.") : 0;
  }

  return _renderMatches(matches && matches.map(function (match) {
    return Object.assign({}, match, {
      params: Object.assign({}, parentParams, match.params),
      pathname: joinPaths([parentPathnameBase, match.pathname]),
      pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
    });
  }), parentMatches);
}

_s12(useRoutes, "w8JqxFLeP9zqA8TFhHy6eLF/IK8=", false, function () {
  return [useInRouterContext, useLocation];
});

function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }

  if (matches == null) return null;
  return matches.reduceRight(function (outlet, match, index) {
    return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(RouteContext.Provider, {
      children: match.route.element !== undefined ? match.route.element : outlet,
      value: {
        outlet: outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
/**
 * A <Router> that stores all entries in memory.
 *
 * @see https://reactrouter.com/docs/en/v6/api#memoryrouter
 */


function MemoryRouter(_ref) {
  _s13();

  var basename = _ref.basename,
      children = _ref.children,
      initialEntries = _ref.initialEntries,
      initialIndex = _ref.initialIndex;
  var historyRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();

  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_0__.createMemoryHistory)({
      initialEntries: initialEntries,
      initialIndex: initialIndex
    });
  }

  var history = historyRef.current;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({
    action: history.action,
    location: history.location
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  (0,react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect)(function () {
    return history.listen(setState);
  }, [history]);
  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(Router, {
    basename: basename,
    children: children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
/**
 * Changes the current location.
 *
 * Note: This API is mostly useful in React.Component subclasses that are not
 * able to use hooks. In functional components, we recommend you use the
 * `useNavigate` hook instead.
 *
 * @see https://reactrouter.com/docs/en/v6/api#navigate
 */


_s13(MemoryRouter, "xBkllX203w11M5ursQOw/eiFREA=");

_c = MemoryRouter;

function Navigate(_ref2) {
  _s14();

  var to = _ref2.to,
      replace = _ref2.replace,
      state = _ref2.state;
  !useInRouterContext() ?  true ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of
  // the router loaded. We can help them understand how to avoid that.
  "<Navigate> may be used only in the context of a <Router> component.") : 0 : void 0;
   true ? warning(!(0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. " + "This is a no-op, but you should modify your code so the <Navigate> is " + "only ever rendered in response to some user interaction or state change.") : 0;
  var navigate = useNavigate();
  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {
    navigate(to, {
      replace: replace,
      state: state
    });
  });
  return null;
}
/**
 * Renders the child route's element, if there is one.
 *
 * @see https://reactrouter.com/docs/en/v6/api#outlet
 */


_s14(Navigate, "Nobqhn8JsyIowAd5acb/Xa2DBmg=", false, function () {
  return [useInRouterContext, useNavigate];
});

_c2 = Navigate;

function Outlet(props) {
  _s15();

  return useOutlet(props.context);
}
/**
 * Declares an element that should be rendered at a certain URL path.
 *
 * @see https://reactrouter.com/docs/en/v6/api#route
 */


_s15(Outlet, "UOsMKhZRqBWgnX+NkNBlxu0sfe8=", false, function () {
  return [useOutlet];
});

_c3 = Outlet;

function Route(_props) {
   true ? invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, " + "never rendered directly. Please wrap your <Route> in a <Routes>.") : 0;
}
/**
 * Provides location context for the rest of the app.
 *
 * Note: You usually won't render a <Router> directly. Instead, you'll render a
 * router that is more specific to your environment such as a <BrowserRouter>
 * in web browsers or a <StaticRouter> for server rendering.
 *
 * @see https://reactrouter.com/docs/en/v6/api#router
 */


_c4 = Route;

function Router(_ref3) {
  _s16();

  var _ref3$basename = _ref3.basename,
      basenameProp = _ref3$basename === void 0 ? "/" : _ref3$basename,
      _ref3$children = _ref3.children,
      children = _ref3$children === void 0 ? null : _ref3$children,
      locationProp = _ref3.location,
      _ref3$navigationType = _ref3.navigationType,
      navigationType = _ref3$navigationType === void 0 ? history__WEBPACK_IMPORTED_MODULE_0__.Action.Pop : _ref3$navigationType,
      navigator = _ref3.navigator,
      _ref3$static = _ref3.static,
      staticProp = _ref3$static === void 0 ? false : _ref3$static;
  !!useInRouterContext() ?  true ? invariant(false, "You cannot render a <Router> inside another <Router>." + " You should never have more than one in your app.") : 0 : void 0;
  var basename = normalizePathname(basenameProp);
  var navigationContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {
    return {
      basename: basename,
      navigator: navigator,
      static: staticProp
    };
  }, [basename, navigator, staticProp]);

  if (typeof locationProp === "string") {
    locationProp = (0,history__WEBPACK_IMPORTED_MODULE_0__.parsePath)(locationProp);
  }

  var _locationProp = locationProp,
      _locationProp$pathnam = _locationProp.pathname,
      pathname = _locationProp$pathnam === void 0 ? "/" : _locationProp$pathnam,
      _locationProp$search = _locationProp.search,
      search = _locationProp$search === void 0 ? "" : _locationProp$search,
      _locationProp$hash = _locationProp.hash,
      hash = _locationProp$hash === void 0 ? "" : _locationProp$hash,
      _locationProp$state = _locationProp.state,
      state = _locationProp$state === void 0 ? null : _locationProp$state,
      _locationProp$key = _locationProp.key,
      key = _locationProp$key === void 0 ? "default" : _locationProp$key;
  var location = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {
    var trailingPathname = stripBasename(pathname, basename);

    if (trailingPathname == null) {
      return null;
    }

    return {
      pathname: trailingPathname,
      search: search,
      hash: hash,
      state: state,
      key: key
    };
  }, [basename, pathname, search, hash, state, key]);
   true ? warning(location != null, "<Router basename=\"" + basename + "\"> is not able to match the URL " + ("\"" + pathname + search + hash + "\" because it does not start with the ") + "basename, so the <Router> won't render anything.") : 0;

  if (location == null) {
    return null;
  }

  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(LocationContext.Provider, {
    children: children,
    value: {
      location: location,
      navigationType: navigationType
    }
  }));
}
/**
 * A container for a nested tree of <Route> elements that renders the branch
 * that best matches the current location.
 *
 * @see https://reactrouter.com/docs/en/v6/api#routes
 */


_s16(Router, "yhF7EA8Qp/tpu2yWVn5n08IeS9U=", false, function () {
  return [useInRouterContext];
});

_c5 = Router;

function Routes(_ref4) {
  _s17();

  var children = _ref4.children,
      location = _ref4.location;
  return useRoutes(createRoutesFromChildren(children), location);
} ///////////////////////////////////////////////////////////////////////////////
// UTILS
///////////////////////////////////////////////////////////////////////////////

/**
 * Creates a route config from a React "children" object, which is usually
 * either a `<Route>` element or an array of them. Used internally by
 * `<Routes>` to create a route config from its children.
 *
 * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren
 */


_s17(Routes, "mNBMh7IZrKf5fDyw9x3t8azefmI=", false, function () {
  return [useRoutes];
});

_c6 = Routes;

function createRoutesFromChildren(children) {
  var routes = [];
  react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, function (element) {
    if (! /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(element)) {
      // Ignore non-elements. This allows people to more easily inline
      // conditionals in their route config.
      return;
    }

    if (element.type === react__WEBPACK_IMPORTED_MODULE_1__.Fragment) {
      // Transparently support React.Fragment and its children.
      routes.push.apply(routes, createRoutesFromChildren(element.props.children));
      return;
    }

    !(element.type === Route) ?  true ? invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : 0 : void 0;
    var route = {
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path
    };

    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children);
    }

    routes.push(route);
  });
  return routes;
}
/**
 * Renders the result of `matchRoutes()` into a React element.
 */


function renderMatches(matches) {
  return _renderMatches(matches);
}



var _c, _c2, _c3, _c4, _c5, _c6;

$RefreshReg$(_c, "MemoryRouter");
$RefreshReg$(_c2, "Navigate");
$RefreshReg$(_c3, "Outlet");
$RefreshReg$(_c4, "Route");
$RefreshReg$(_c5, "Router");
$RefreshReg$(_c6, "Routes");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

if (true) {
  (function () {
    'use strict';
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

    var _s = $RefreshSig$(),
        _s2 = $RefreshSig$(),
        _s3 = $RefreshSig$(),
        _s4 = $RefreshSig$(),
        _s5 = $RefreshSig$(),
        _s6 = $RefreshSig$(),
        _s7 = $RefreshSig$(),
        _s8 = $RefreshSig$(),
        _s9 = $RefreshSig$(),
        _s10 = $RefreshSig$(),
        _s11 = $RefreshSig$(),
        _s12 = $RefreshSig$(),
        _s13 = $RefreshSig$(),
        _s14 = $RefreshSig$(),
        _s15 = $RefreshSig$();

    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    }

    var ReactVersion = '18.1.0'; // -----------------------------------------------------------------------------

    var enableScopeAPI = false; // Experimental Create Event Handle API.

    var enableCacheElement = false;
    var enableTransitionTracing = false; // No known bugs, but needs performance testing

    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
    // stuff. Intended to enable React core members to more easily debug scheduling
    // issues in DEV builds.

    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.
    // ATTENTION

    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
    var REACT_PORTAL_TYPE = Symbol.for('react.portal');
    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
    var REACT_CONTEXT_TYPE = Symbol.for('react.context');
    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
    var REACT_MEMO_TYPE = Symbol.for('react.memo');
    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {
        return null;
      }

      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }

      return null;
    }
    /**
     * Keeps track of the current dispatcher.
     */


    var ReactCurrentDispatcher = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };
    /**
     * Keeps track of the current batch's configuration such as how long an update
     * should suspend for if it needs to.
     */

    var ReactCurrentBatchConfig = {
      transition: null
    };
    var ReactCurrentActQueue = {
      current: null,
      // Used to reproduce behavior of `batchedUpdates` in legacy mode.
      isBatchingLegacy: false,
      didScheduleLegacyUpdate: false
    };
    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */

    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };
    var ReactDebugCurrentFrame = {};
    var currentExtraStackFrame = null;

    function setExtraStackFrame(stack) {
      {
        currentExtraStackFrame = stack;
      }
    }

    {
      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
        {
          currentExtraStackFrame = stack;
        }
      }; // Stack implementation injected by the current renderer.


      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var stack = ''; // Add an extra top frame while an element is being validated

        if (currentExtraStackFrame) {
          stack += currentExtraStackFrame;
        } // Delegate to the injected renderer-specific implementation


        var impl = ReactDebugCurrentFrame.getCurrentStack;

        if (impl) {
          stack += impl() || '';
        }

        return stack;
      };
    }
    var ReactSharedInternals = {
      ReactCurrentDispatcher: ReactCurrentDispatcher,
      ReactCurrentBatchConfig: ReactCurrentBatchConfig,
      ReactCurrentOwner: ReactCurrentOwner
    };
    {
      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
    } // by calls to these methods by a Babel plugin.
    //
    // In PROD (or in packages without access to React internals),
    // they are left as they are instead.

    function warn(format) {
      {
        {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          printWarning('warn', format, args);
        }
      }
    }

    function error(format) {
      {
        {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          printWarning('error', format, args);
        }
      }
    }

    function printWarning(level, format, args) {
      // When changing this logic, you might want to also
      // update consoleWithStackDev.www.js as well.
      {
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum();

        if (stack !== '') {
          format += '%s';
          args = args.concat([stack]);
        } // eslint-disable-next-line react-internal/safe-string-coercion


        var argsWithFormat = args.map(function (item) {
          return String(item);
        }); // Careful: RN currently depends on this prefix

        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
        // breaks IE9: https://github.com/facebook/react/issues/13610
        // eslint-disable-next-line react-internal/no-production-logging

        Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
        var warningKey = componentName + "." + callerName;

        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }

        error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }
    /**
     * This is the abstract API for an update queue.
     */


    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };
    var assign = Object.assign;
    var emptyObject = {};
    {
      Object.freeze(emptyObject);
    }
    /**
     * Base class helpers for the updating state of a component.
     */

    function Component(props, context, updater) {
      this.props = props;
      this.context = context; // If a component has string refs, we will assign a different object later.

      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};
    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */

    Component.prototype.setState = function (partialState, callback) {
      if (_typeof(partialState) !== 'object' && typeof partialState !== 'function' && partialState != null) {
        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
      }

      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };
    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */


    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };
    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */


    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };

      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };

      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    function ComponentDummy() {}

    ComponentDummy.prototype = Component.prototype;
    /**
     * Convenience component with default shallow equality check for sCU.
     */

    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context; // If a component has string refs, we will assign a different object later.

      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true; // an immutable object with a single mutable value

    function createRef() {
      var refObject = {
        current: null
      };
      {
        Object.seal(refObject);
      }
      return refObject;
    }

    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

    function isArray(a) {
      return isArrayImpl(a);
    }
    /*
     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
     *
     * The functions in this module will throw an easier-to-understand,
     * easier-to-debug exception with a clear errors message message explaining the
     * problem. (Instead of a confusing exception thrown inside the implementation
     * of the `value` object).
     */
    // $FlowFixMe only called in DEV, so void return is not possible.


    function typeName(value) {
      {
        // toStringTag is needed for namespaced types like Temporal.Instant
        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
        return type;
      }
    } // $FlowFixMe only called in DEV, so void return is not possible.


    function willCoercionThrow(value) {
      {
        try {
          testStringCoercion(value);
          return false;
        } catch (e) {
          return true;
        }
      }
    }

    function testStringCoercion(value) {
      // If you ended up here by following an exception call stack, here's what's
      // happened: you supplied an object or symbol value to React (as a prop, key,
      // DOM attribute, CSS property, string ref, etc.) and when React tried to
      // coerce it to a string using `'' + value`, an exception was thrown.
      //
      // The most common types that will cause this exception are `Symbol` instances
      // and Temporal objects like `Temporal.Instant`. But any object that has a
      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
      // exception. (Library authors do this to prevent users from using built-in
      // numeric operators like `+` or comparison operators like `>=` because custom
      // methods are needed to perform accurate arithmetic or comparison.)
      //
      // To fix the problem, coerce this object or symbol value to a string before
      // passing it to React. The most reliable way is usually `String(value)`.
      //
      // To find which value is throwing, check the browser or debugger console.
      // Before this exception was thrown, there should be `console.error` output
      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
      // problem and how that type was used: key, atrribute, input value prop, etc.
      // In most cases, this console output also shows the component and its
      // ancestor components where the exception happened.
      //
      // eslint-disable-next-line react-internal/safe-string-coercion
      return '' + value;
    }

    function checkKeyStringCoercion(value) {
      {
        if (willCoercionThrow(value)) {
          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
        }
      }
    }

    function getWrappedName(outerType, innerType, wrapperName) {
      var displayName = outerType.displayName;

      if (displayName) {
        return displayName;
      }

      var functionName = innerType.displayName || innerType.name || '';
      return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
    } // Keep in sync with react-reconciler/getComponentNameFromFiber


    function getContextName(type) {
      return type.displayName || 'Context';
    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


    function getComponentNameFromType(type) {
      if (type == null) {
        // Host root, text node or just invalid type.
        return null;
      }

      {
        if (typeof type.tag === 'number') {
          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
        }
      }

      if (typeof type === 'function') {
        return type.displayName || type.name || null;
      }

      if (typeof type === 'string') {
        return type;
      }

      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return 'Fragment';

        case REACT_PORTAL_TYPE:
          return 'Portal';

        case REACT_PROFILER_TYPE:
          return 'Profiler';

        case REACT_STRICT_MODE_TYPE:
          return 'StrictMode';

        case REACT_SUSPENSE_TYPE:
          return 'Suspense';

        case REACT_SUSPENSE_LIST_TYPE:
          return 'SuspenseList';
      }

      if (_typeof(type) === 'object') {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type;
            return getContextName(context) + '.Consumer';

          case REACT_PROVIDER_TYPE:
            var provider = type;
            return getContextName(provider._context) + '.Provider';

          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, 'ForwardRef');

          case REACT_MEMO_TYPE:
            var outerName = type.displayName || null;

            if (outerName !== null) {
              return outerName;
            }

            return getComponentNameFromType(type.type) || 'Memo';

          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;

              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          // eslint-disable-next-line no-fallthrough
        }
      }

      return null;
    }

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
    {
      didWarnAboutStringRefs = {};
    }

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        {
          if (!specialPropKeyWarningShown) {
            specialPropKeyWarningShown = true;
            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        }
      };

      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        {
          if (!specialPropRefWarningShown) {
            specialPropRefWarningShown = true;
            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
          }
        }
      };

      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    function warnIfStringRefCannotBeAutoConverted(config) {
      {
        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

          if (!didWarnAboutStringRefs[componentName]) {
            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
            didWarnAboutStringRefs[componentName] = true;
          }
        }
      }
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, instanceof check
     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} props
     * @param {*} key
     * @param {string|object} ref
     * @param {*} owner
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @internal
     */


    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });

        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */


    function createElement(type, config, children) {
      var propName; // Reserved names are extracted

      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
          {
            warnIfStringRefCannotBeAutoConverted(config);
          }
        }

        if (hasValidKey(config)) {
          {
            checkKeyStringCoercion(config.key);
          }
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      } // Resolve default props


      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;

        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }

      {
        if (key || ref) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }

          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      return newElement;
    }
    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */


    function cloneElement(element, config, children) {
      if (element === null || element === undefined) {
        throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
      }

      var propName; // Original props are copied

      var props = assign({}, element.props); // Reserved names are extracted

      var key = element.key;
      var ref = element.ref; // Self is preserved since the owner is preserved.

      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.

      var source = element._source; // Owner will be preserved, unless ref is overridden

      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }

        if (hasValidKey(config)) {
          {
            checkKeyStringCoercion(config.key);
          }
          key = '' + config.key;
        } // Remaining properties override existing props


        var defaultProps;

        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a ReactElement.
     * @final
     */


    function isValidElement(object) {
      return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */

    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = key.replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });
      return '$' + escapedString;
    }
    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */


    var didWarnAboutMaps = false;
    var userProvidedKeyEscapeRegex = /\/+/g;

    function escapeUserProvidedKey(text) {
      return text.replace(userProvidedKeyEscapeRegex, '$&/');
    }
    /**
     * Generate a key string that identifies a element within a set.
     *
     * @param {*} element A element that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */


    function getElementKey(element, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if (_typeof(element) === 'object' && element !== null && element.key != null) {
        // Explicit key
        {
          checkKeyStringCoercion(element.key);
        }
        return escape('' + element.key);
      } // Implicit key determined by the index in the set


      return index.toString(36);
    }

    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;

          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }

        }
      }

      if (invokeCallback) {
        var _child = children;
        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows:

        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

        if (isArray(mappedChild)) {
          var escapedChildKey = '';

          if (childKey != null) {
            escapedChildKey = escapeUserProvidedKey(childKey) + '/';
          }

          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
            return c;
          });
        } else if (mappedChild != null) {
          if (isValidElement(mappedChild)) {
            {
              // The `if` statement here prevents auto-disabling of the safe
              // coercion ESLint rule, so we must manually disable it below.
              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                checkKeyStringCoercion(mappedChild.key);
              }
            }
            mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
            // eslint-disable-next-line react-internal/safe-string-coercion
            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
          }

          array.push(mappedChild);
        }

        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.

      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getElementKey(child, i);
          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          var iterableChildren = children;
          {
            // Warn about using Maps as children
            if (iteratorFn === iterableChildren.entries) {
              if (!didWarnAboutMaps) {
                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
              }

              didWarnAboutMaps = true;
            }
          }
          var iterator = iteratorFn.call(iterableChildren);
          var step;
          var ii = 0;

          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getElementKey(child, ii++);
            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
          }
        } else if (type === 'object') {
          // eslint-disable-next-line react-internal/safe-string-coercion
          var childrenString = String(children);
          throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
        }
      }

      return subtreeCount;
    }
    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenmap
     *
     * The provided mapFunction(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */


    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }

      var result = [];
      var count = 0;
      mapIntoArray(children, result, '', '', function (child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrencount
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */


    function countChildren(children) {
      var n = 0;
      mapChildren(children, function () {
        n++; // Don't return anything
      });
      return n;
    }
    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */


    function forEachChildren(children, forEachFunc, forEachContext) {
      mapChildren(children, function () {
        forEachFunc.apply(this, arguments); // Don't return anything.
      }, forEachContext);
    }
    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
     */


    function toArray(children) {
      return mapChildren(children, function (child) {
        return child;
      }) || [];
    }
    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenonly
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */


    function onlyChild(children) {
      if (!isValidElement(children)) {
        throw new Error('React.Children.only expected to receive a single React element child.');
      }

      return children;
    }

    function createContext(defaultValue) {
      // TODO: Second argument used to be an optional `calculateChangedBits`
      // function. Warn to reserve for future use?
      var context = {
        $$typeof: REACT_CONTEXT_TYPE,
        // As a workaround to support multiple concurrent renderers, we categorize
        // some renderers as primary and others as secondary. We only expect
        // there to be two concurrent renderers at most: React Native (primary) and
        // Fabric (secondary); React DOM (primary) and React ART (secondary).
        // Secondary renderers store their context values on separate fields.
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        // Used to track how many concurrent renderers this context currently
        // supports within in a single renderer. Such as parallel server rendering.
        _threadCount: 0,
        // These are circular
        Provider: null,
        Consumer: null,
        // Add these to use same hidden class in VM as ServerContext
        _defaultValue: null,
        _globalName: null
      };
      context.Provider = {
        $$typeof: REACT_PROVIDER_TYPE,
        _context: context
      };
      var hasWarnedAboutUsingNestedContextConsumers = false;
      var hasWarnedAboutUsingConsumerProvider = false;
      var hasWarnedAboutDisplayNameOnConsumer = false;
      {
        // A separate object, but proxies back to the original context object for
        // backwards compatibility. It has a different $$typeof, so we can properly
        // warn for the incorrect usage of Context as a Consumer.
        var Consumer = {
          $$typeof: REACT_CONTEXT_TYPE,
          _context: context
        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

        Object.defineProperties(Consumer, {
          Provider: {
            get: function get() {
              if (!hasWarnedAboutUsingConsumerProvider) {
                hasWarnedAboutUsingConsumerProvider = true;
                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
              }

              return context.Provider;
            },
            set: function set(_Provider) {
              context.Provider = _Provider;
            }
          },
          _currentValue: {
            get: function get() {
              return context._currentValue;
            },
            set: function set(_currentValue) {
              context._currentValue = _currentValue;
            }
          },
          _currentValue2: {
            get: function get() {
              return context._currentValue2;
            },
            set: function set(_currentValue2) {
              context._currentValue2 = _currentValue2;
            }
          },
          _threadCount: {
            get: function get() {
              return context._threadCount;
            },
            set: function set(_threadCount) {
              context._threadCount = _threadCount;
            }
          },
          Consumer: {
            get: function get() {
              if (!hasWarnedAboutUsingNestedContextConsumers) {
                hasWarnedAboutUsingNestedContextConsumers = true;
                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
              }

              return context.Consumer;
            }
          },
          displayName: {
            get: function get() {
              return context.displayName;
            },
            set: function set(displayName) {
              if (!hasWarnedAboutDisplayNameOnConsumer) {
                warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                hasWarnedAboutDisplayNameOnConsumer = true;
              }
            }
          }
        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

        context.Consumer = Consumer;
      }
      {
        context._currentRenderer = null;
        context._currentRenderer2 = null;
      }
      return context;
    }

    var Uninitialized = -1;
    var Pending = 0;
    var Resolved = 1;
    var Rejected = 2;

    function lazyInitializer(payload) {
      if (payload._status === Uninitialized) {
        var ctor = payload._result;
        var thenable = ctor(); // Transition to the next state.
        // This might throw either because it's missing or throws. If so, we treat it
        // as still uninitialized and try again next time. Which is the same as what
        // happens if the ctor or any wrappers processing the ctor throws. This might
        // end up fixing it if the resolution was a concurrency bug.

        thenable.then(function (moduleObject) {
          if (payload._status === Pending || payload._status === Uninitialized) {
            // Transition to the next state.
            var resolved = payload;
            resolved._status = Resolved;
            resolved._result = moduleObject;
          }
        }, function (error) {
          if (payload._status === Pending || payload._status === Uninitialized) {
            // Transition to the next state.
            var rejected = payload;
            rejected._status = Rejected;
            rejected._result = error;
          }
        });

        if (payload._status === Uninitialized) {
          // In case, we're still uninitialized, then we're waiting for the thenable
          // to resolve. Set it as pending in the meantime.
          var pending = payload;
          pending._status = Pending;
          pending._result = thenable;
        }
      }

      if (payload._status === Resolved) {
        var moduleObject = payload._result;
        {
          if (moduleObject === undefined) {
            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
          }
        }
        {
          if (!('default' in moduleObject)) {
            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        }
        return moduleObject.default;
      } else {
        throw payload._result;
      }
    }

    function lazy(ctor) {
      var payload = {
        // We use these fields to store the result.
        _status: Uninitialized,
        _result: ctor
      };
      var lazyType = {
        $$typeof: REACT_LAZY_TYPE,
        _payload: payload,
        _init: lazyInitializer
      };
      {
        // In production, this would just set it on the object.
        var defaultProps;
        var propTypes; // $FlowFixMe

        Object.defineProperties(lazyType, {
          defaultProps: {
            configurable: true,
            get: function get() {
              return defaultProps;
            },
            set: function set(newDefaultProps) {
              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
              defaultProps = newDefaultProps; // Match production behavior more closely:
              // $FlowFixMe

              Object.defineProperty(lazyType, 'defaultProps', {
                enumerable: true
              });
            }
          },
          propTypes: {
            configurable: true,
            get: function get() {
              return propTypes;
            },
            set: function set(newPropTypes) {
              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
              propTypes = newPropTypes; // Match production behavior more closely:
              // $FlowFixMe

              Object.defineProperty(lazyType, 'propTypes', {
                enumerable: true
              });
            }
          }
        });
      }
      return lazyType;
    }

    function forwardRef(render) {
      {
        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
        } else if (typeof render !== 'function') {
          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : _typeof(render));
        } else {
          if (render.length !== 0 && render.length !== 2) {
            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
          }
        }

        if (render != null) {
          if (render.defaultProps != null || render.propTypes != null) {
            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
          }
        }
      }
      var elementType = {
        $$typeof: REACT_FORWARD_REF_TYPE,
        render: render
      };
      {
        var ownName;
        Object.defineProperty(elementType, 'displayName', {
          enumerable: false,
          configurable: true,
          get: function get() {
            return ownName;
          },
          set: function set(name) {
            ownName = name; // The inner component shouldn't inherit this display name in most cases,
            // because the component may be used elsewhere.
            // But it's nice for anonymous functions to inherit the name,
            // so that our component-stack generation logic will display their frames.
            // An anonymous function generally suggests a pattern like:
            //   React.forwardRef((props, ref) => {...});
            // This kind of inner function is not used elsewhere so the side effect is okay.

            if (!render.name && !render.displayName) {
              render.displayName = name;
            }
          }
        });
      }
      return elementType;
    }

    var REACT_MODULE_REFERENCE;
    {
      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
    }

    function isValidElementType(type) {
      if (typeof type === 'string' || typeof type === 'function') {
        return true;
      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
        return true;
      }

      if (_typeof(type) === 'object' && type !== null) {
        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
          return true;
        }
      }

      return false;
    }

    function memo(type, compare) {
      {
        if (!isValidElementType(type)) {
          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : _typeof(type));
        }
      }
      var elementType = {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: compare === undefined ? null : compare
      };
      {
        var ownName;
        Object.defineProperty(elementType, 'displayName', {
          enumerable: false,
          configurable: true,
          get: function get() {
            return ownName;
          },
          set: function set(name) {
            ownName = name; // The inner component shouldn't inherit this display name in most cases,
            // because the component may be used elsewhere.
            // But it's nice for anonymous functions to inherit the name,
            // so that our component-stack generation logic will display their frames.
            // An anonymous function generally suggests a pattern like:
            //   React.memo((props) => {...});
            // This kind of inner function is not used elsewhere so the side effect is okay.

            if (!type.name && !type.displayName) {
              type.displayName = name;
            }
          }
        });
      }
      return elementType;
    }

    function resolveDispatcher() {
      var dispatcher = ReactCurrentDispatcher.current;
      {
        if (dispatcher === null) {
          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
        }
      } // Will result in a null access error if accessed outside render phase. We
      // intentionally don't throw our own error because this is in a hot path.
      // Also helps ensure this is inlined.

      return dispatcher;
    }

    function useContext(Context) {
      _s();

      var dispatcher = resolveDispatcher();
      {
        // TODO: add a more generic warning for invalid values.
        if (Context._context !== undefined) {
          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
          // and nobody should be using this in existing code.

          if (realContext.Consumer === Context) {
            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
          } else if (realContext.Provider === Context) {
            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
          }
        }
      }
      return dispatcher.useContext(Context);
    }

    _s(useContext, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

    function useState(initialState) {
      _s2();

      var dispatcher = resolveDispatcher();
      return dispatcher.useState(initialState);
    }

    _s2(useState, "ivzlgorP4GeLgLCP2g2oo8lrHBQ=");

    function useReducer(reducer, initialArg, init) {
      _s3();

      var dispatcher = resolveDispatcher();
      return dispatcher.useReducer(reducer, initialArg, init);
    }

    _s3(useReducer, "UB8b1SLMookzcOV5tTvlJ/kwReQ=");

    function useRef(initialValue) {
      _s4();

      var dispatcher = resolveDispatcher();
      return dispatcher.useRef(initialValue);
    }

    _s4(useRef, "J9pzIsEOVEZ74gjFtMkCj+5Po7s=");

    function useEffect(create, deps) {
      _s5();

      var dispatcher = resolveDispatcher();
      return dispatcher.useEffect(create, deps);
    }

    _s5(useEffect, "OD7bBpZva5O2jO+Puf00hKivP7c=");

    function useInsertionEffect(create, deps) {
      _s6();

      var dispatcher = resolveDispatcher();
      return dispatcher.useInsertionEffect(create, deps);
    }

    _s6(useInsertionEffect, "KP04oOqX3NbUYDsTwGwlE3GUn5Y=", false, function () {
      return [dispatcher.useInsertionEffect];
    });

    function useLayoutEffect(create, deps) {
      _s7();

      var dispatcher = resolveDispatcher();
      return dispatcher.useLayoutEffect(create, deps);
    }

    _s7(useLayoutEffect, "n7/vCynhJvM+pLkyL2DMQUF0odM=");

    function useCallback(callback, deps) {
      _s8();

      var dispatcher = resolveDispatcher();
      return dispatcher.useCallback(callback, deps);
    }

    _s8(useCallback, "epj4qY15NHsef74wNqHIp5fdZmg=");

    function useMemo(create, deps) {
      _s9();

      var dispatcher = resolveDispatcher();
      return dispatcher.useMemo(create, deps);
    }

    _s9(useMemo, "nwk+m61qLgjDVUp4IGV/072DDN4=");

    function useImperativeHandle(ref, create, deps) {
      _s10();

      var dispatcher = resolveDispatcher();
      return dispatcher.useImperativeHandle(ref, create, deps);
    }

    _s10(useImperativeHandle, "PYzlZ2AGFM0KxtNOGoZVRb5EOEw=");

    function useDebugValue(value, formatterFn) {
      _s11();

      {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDebugValue(value, formatterFn);
      }
    }

    _s11(useDebugValue, "GhvPrRYADeIBc0kER6M56ZZ9cIU=");

    function useTransition() {
      _s12();

      var dispatcher = resolveDispatcher();
      return dispatcher.useTransition();
    }

    _s12(useTransition, "28mb38mkSsMdKhDodgMEJ1axbVA=", false, function () {
      return [dispatcher.useTransition];
    });

    function useDeferredValue(value) {
      _s13();

      var dispatcher = resolveDispatcher();
      return dispatcher.useDeferredValue(value);
    }

    _s13(useDeferredValue, "4U68yWucejOUMGrZQU+1Y6yEx1c=", false, function () {
      return [dispatcher.useDeferredValue];
    });

    function useId() {
      _s14();

      var dispatcher = resolveDispatcher();
      return dispatcher.useId();
    }

    _s14(useId, "xfMyHNFebGjSN1/YPqrD8z5EdLc=", false, function () {
      return [dispatcher.useId];
    });

    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      _s15();

      var dispatcher = resolveDispatcher();
      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    } // Helpers to patch console.logs to avoid logging during side-effect free
    // replaying on render function. This currently only patches the object
    // lazily which won't cover if the log function was extracted eagerly.
    // We could also eagerly patch the method.


    _s15(useSyncExternalStore, "FpwL93IKMLJZuQQXefVtWynbBPQ=", false, function () {
      return [dispatcher.useSyncExternalStore];
    });

    var disabledDepth = 0;
    var prevLog;
    var prevInfo;
    var prevWarn;
    var prevError;
    var prevGroup;
    var prevGroupCollapsed;
    var prevGroupEnd;

    function disabledLog() {}

    disabledLog.__reactDisabledLog = true;

    function disableLogs() {
      {
        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          prevLog = console.log;
          prevInfo = console.info;
          prevWarn = console.warn;
          prevError = console.error;
          prevGroup = console.group;
          prevGroupCollapsed = console.groupCollapsed;
          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

          var props = {
            configurable: true,
            enumerable: true,
            value: disabledLog,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        disabledDepth++;
      }
    }

    function reenableLogs() {
      {
        disabledDepth--;

        if (disabledDepth === 0) {
          /* eslint-disable react-internal/no-production-logging */
          var props = {
            configurable: true,
            enumerable: true,
            writable: true
          }; // $FlowFixMe Flow thinks console is immutable.

          Object.defineProperties(console, {
            log: assign({}, props, {
              value: prevLog
            }),
            info: assign({}, props, {
              value: prevInfo
            }),
            warn: assign({}, props, {
              value: prevWarn
            }),
            error: assign({}, props, {
              value: prevError
            }),
            group: assign({}, props, {
              value: prevGroup
            }),
            groupCollapsed: assign({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: assign({}, props, {
              value: prevGroupEnd
            })
          });
          /* eslint-enable react-internal/no-production-logging */
        }

        if (disabledDepth < 0) {
          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
        }
      }
    }

    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
    var prefix;

    function describeBuiltInComponentFrame(name, source, ownerFn) {
      {
        if (prefix === undefined) {
          // Extract the VM specific prefix used by each line.
          try {
            throw Error();
          } catch (x) {
            var match = x.stack.trim().match(/\n( *(at )?)/);
            prefix = match && match[1] || '';
          }
        } // We use the prefix to ensure our stacks line up with native stack frames.


        return '\n' + prefix + name;
      }
    }

    var reentry = false;
    var componentFrameCache;
    {
      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }

    function describeNativeComponentFrame(fn, construct) {
      // If something asked for a stack inside a fake render, it should get ignored.
      if (!fn || reentry) {
        return '';
      }

      {
        var frame = componentFrameCache.get(fn);

        if (frame !== undefined) {
          return frame;
        }
      }
      var control;
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

      Error.prepareStackTrace = undefined;
      var previousDispatcher;
      {
        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
        // for warnings.

        ReactCurrentDispatcher$1.current = null;
        disableLogs();
      }

      try {
        // This should throw.
        if (construct) {
          // Something should be setting the props in the constructor.
          var Fake = function Fake() {
            throw Error();
          }; // $FlowFixMe


          Object.defineProperty(Fake.prototype, 'props', {
            set: function set() {
              // We use a throwing setter instead of frozen or non-writable props
              // because that won't throw in a non-strict mode function.
              throw Error();
            }
          });

          if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' && Reflect.construct) {
            // We construct a different control for this case to include any extra
            // frames added by the construct call.
            try {
              Reflect.construct(Fake, []);
            } catch (x) {
              control = x;
            }

            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x) {
              control = x;
            }

            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x) {
            control = x;
          }

          fn();
        }
      } catch (sample) {
        // This is inlined manually because closure doesn't do it for us.
        if (sample && control && typeof sample.stack === 'string') {
          // This extracts the first frame from the sample that isn't also in the control.
          // Skipping one frame that we assume is the frame that calls the two.
          var sampleLines = sample.stack.split('\n');
          var controlLines = control.stack.split('\n');
          var s = sampleLines.length - 1;
          var c = controlLines.length - 1;

          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
            // We expect at least one stack frame to be shared.
            // Typically this will be the root most one. However, stack frames may be
            // cut off due to maximum stack limits. In this case, one maybe cut off
            // earlier than the other. We assume that the sample is longer or the same
            // and there for cut off earlier. So we should find the root most frame in
            // the sample somewhere in the control.
            c--;
          }

          for (; s >= 1 && c >= 0; s--, c--) {
            // Next we find the first one that isn't the same which should be the
            // frame that called our sample function and the control.
            if (sampleLines[s] !== controlLines[c]) {
              // In V8, the first line is describing the message but other VMs don't.
              // If we're about to return the first line, and the control is also on the same
              // line, that's a pretty good indicator that our sample threw at same line as
              // the control. I.e. before we entered the sample frame. So we ignore this result.
              // This can happen if you passed a class to function component, or non-function.
              if (s !== 1 || c !== 1) {
                do {
                  s--;
                  c--; // We may still have similar intermediate frames from the construct call.
                  // The next one that isn't the same should be our match though.

                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                    // but we have a user-provided "displayName"
                    // splice it in to make the stack more readable.


                    if (fn.displayName && _frame.includes('<anonymous>')) {
                      _frame = _frame.replace('<anonymous>', fn.displayName);
                    }

                    {
                      if (typeof fn === 'function') {
                        componentFrameCache.set(fn, _frame);
                      }
                    } // Return the line we found.

                    return _frame;
                  }
                } while (s >= 1 && c >= 0);
              }

              break;
            }
          }
        }
      } finally {
        reentry = false;
        {
          ReactCurrentDispatcher$1.current = previousDispatcher;
          reenableLogs();
        }
        Error.prepareStackTrace = previousPrepareStackTrace;
      } // Fallback to just using the name if we couldn't make it throw.


      var name = fn ? fn.displayName || fn.name : '';
      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
      {
        if (typeof fn === 'function') {
          componentFrameCache.set(fn, syntheticFrame);
        }
      }
      return syntheticFrame;
    }

    function describeFunctionComponentFrame(fn, source, ownerFn) {
      {
        return describeNativeComponentFrame(fn, false);
      }
    }

    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }

    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
      if (type == null) {
        return '';
      }

      if (typeof type === 'function') {
        {
          return describeNativeComponentFrame(type, shouldConstruct(type));
        }
      }

      if (typeof type === 'string') {
        return describeBuiltInComponentFrame(type);
      }

      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame('Suspense');

        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame('SuspenseList');
      }

      if (_typeof(type) === 'object') {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type.render);

          case REACT_MEMO_TYPE:
            // Memo may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

          case REACT_LAZY_TYPE:
            {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;

              try {
                // Lazy may contain any component type so we recursively resolve it.
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
        }
      }

      return '';
    }

    var loggedTypeFailures = {};
    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

    function setCurrentlyValidatingElement(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
        } else {
          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
        }
      }
    }

    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        // $FlowFixMe This is okay but Flow doesn't know it.
        var has = Function.call.bind(hasOwnProperty);

        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
            // fail the render phase where it didn't fail before. So we log it.
            // After these have been cleaned up, we'll let them throw.

            try {
              // This is intentionally an invariant that gets caught. It's the same
              // behavior as without this statement except with a better message.
              if (typeof typeSpecs[typeSpecName] !== 'function') {
                // eslint-disable-next-line react-internal/prod-error-codes
                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                err.name = 'Invariant Violation';
                throw err;
              }

              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
            } catch (ex) {
              error$1 = ex;
            }

            if (error$1 && !(error$1 instanceof Error)) {
              setCurrentlyValidatingElement(element);
              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, _typeof(error$1));
              setCurrentlyValidatingElement(null);
            }

            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
              // Only monitor this failure once because there tends to be a lot of the
              // same error.
              loggedTypeFailures[error$1.message] = true;
              setCurrentlyValidatingElement(element);
              error('Failed %s type: %s', location, error$1.message);
              setCurrentlyValidatingElement(null);
            }
          }
        }
      }
    }

    function setCurrentlyValidatingElement$1(element) {
      {
        if (element) {
          var owner = element._owner;
          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
          setExtraStackFrame(stack);
        } else {
          setExtraStackFrame(null);
        }
      }
    }

    var propTypesMisspellWarningShown;
    {
      propTypesMisspellWarningShown = false;
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentNameFromType(ReactCurrentOwner.current.type);

        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }

      return '';
    }

    function getSourceInfoErrorAddendum(source) {
      if (source !== undefined) {
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }

      return '';
    }

    function getSourceInfoErrorAddendumForProps(elementProps) {
      if (elementProps !== null && elementProps !== undefined) {
        return getSourceInfoErrorAddendum(elementProps.__source);
      }

      return '';
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */


    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

        if (parentName) {
          info = "\n\nCheck the top-level render call using <" + parentName + ">.";
        }
      }

      return info;
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */


    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }

      element._store.validated = true;
      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }

      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.

      var childOwner = '';

      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
      }

      {
        setCurrentlyValidatingElement$1(element);
        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
        setCurrentlyValidatingElement$1(null);
      }
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */


    function validateChildKeys(node, parentType) {
      if (_typeof(node) !== 'object') {
        return;
      }

      if (isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];

          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);

        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;

            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */


    function validatePropTypes(element) {
      {
        var type = element.type;

        if (type === null || type === undefined || typeof type === 'string') {
          return;
        }

        var propTypes;

        if (typeof type === 'function') {
          propTypes = type.propTypes;
        } else if (_typeof(type) === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        type.$$typeof === REACT_MEMO_TYPE)) {
          propTypes = type.propTypes;
        } else {
          return;
        }

        if (propTypes) {
          // Intentionally inside to avoid triggering lazy initializers:
          var name = getComponentNameFromType(type);
          checkPropTypes(propTypes, element.props, 'prop', name, element);
        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

          var _name = getComponentNameFromType(type);

          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
        }

        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
        }
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */


    function validateFragmentProps(fragment) {
      {
        var keys = Object.keys(fragment.props);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (key !== 'children' && key !== 'key') {
            setCurrentlyValidatingElement$1(fragment);
            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
            setCurrentlyValidatingElement$1(null);
            break;
          }
        }

        if (fragment.ref !== null) {
          setCurrentlyValidatingElement$1(fragment);
          error('Invalid attribute `ref` supplied to `React.Fragment`.');
          setCurrentlyValidatingElement$1(null);
        }
      }
    }

    function createElementWithValidation(type, props, children) {
      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.

      if (!validType) {
        var info = '';

        if (type === undefined || _typeof(type) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendumForProps(props);

        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        var typeString;

        if (type === null) {
          typeString = 'null';
        } else if (isArray(type)) {
          typeString = 'array';
        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
          typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
          info = ' Did you accidentally export a JSX literal instead of a component?';
        } else {
          typeString = _typeof(type);
        }

        {
          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
        }
      }

      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.

      if (element == null) {
        return element;
      } // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)


      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if (type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    var didWarnAboutDeprecatedCreateFactory = false;

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      validatedFactory.type = type;
      {
        if (!didWarnAboutDeprecatedCreateFactory) {
          didWarnAboutDeprecatedCreateFactory = true;
          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
        } // Legacy hook: remove it


        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);

      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }

      validatePropTypes(newElement);
      return newElement;
    }

    function startTransition(scope, options) {
      var prevTransition = ReactCurrentBatchConfig.transition;
      ReactCurrentBatchConfig.transition = {};
      var currentTransition = ReactCurrentBatchConfig.transition;
      {
        ReactCurrentBatchConfig.transition._updatedFibers = new Set();
      }

      try {
        scope();
      } finally {
        ReactCurrentBatchConfig.transition = prevTransition;
        {
          if (prevTransition === null && currentTransition._updatedFibers) {
            var updatedFibersCount = currentTransition._updatedFibers.size;

            if (updatedFibersCount > 10) {
              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
            }

            currentTransition._updatedFibers.clear();
          }
        }
      }
    }

    var didWarnAboutMessageChannel = false;
    var enqueueTaskImpl = null;

    function enqueueTask(task) {
      if (enqueueTaskImpl === null) {
        try {
          // read require off the module object to get around the bundlers.
          // we don't want them to detect a require and bundle a Node polyfill.
          var requireString = ('require' + Math.random()).slice(0, 7);
          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's
          // version of setImmediate, bypassing fake timers if any.

          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
        } catch (_err) {
          // we're in a browser
          // we can't use regular timers because they may still be faked
          // so we try MessageChannel+postMessage instead
          enqueueTaskImpl = function enqueueTaskImpl(callback) {
            {
              if (didWarnAboutMessageChannel === false) {
                didWarnAboutMessageChannel = true;

                if (typeof MessageChannel === 'undefined') {
                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
                }
              }
            }
            var channel = new MessageChannel();
            channel.port1.onmessage = callback;
            channel.port2.postMessage(undefined);
          };
        }
      }

      return enqueueTaskImpl(task);
    }

    var actScopeDepth = 0;
    var didWarnNoAwaitAct = false;

    function act(callback) {
      {
        // `act` calls can be nested, so we track the depth. This represents the
        // number of `act` scopes on the stack.
        var prevActScopeDepth = actScopeDepth;
        actScopeDepth++;

        if (ReactCurrentActQueue.current === null) {
          // This is the outermost `act` scope. Initialize the queue. The reconciler
          // will detect the queue and use it instead of Scheduler.
          ReactCurrentActQueue.current = [];
        }

        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
        var result;

        try {
          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only
          // set to `true` while the given callback is executed, not for updates
          // triggered during an async event, because this is how the legacy
          // implementation of `act` behaved.
          ReactCurrentActQueue.isBatchingLegacy = true;
          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,
          // which flushed updates immediately after the scope function exits, even
          // if it's an async function.

          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
            var queue = ReactCurrentActQueue.current;

            if (queue !== null) {
              ReactCurrentActQueue.didScheduleLegacyUpdate = false;
              flushActQueue(queue);
            }
          }
        } catch (error) {
          popActScope(prevActScopeDepth);
          throw error;
        } finally {
          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
        }

        if (result !== null && _typeof(result) === 'object' && typeof result.then === 'function') {
          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait
          // for it to resolve before exiting the current scope.

          var wasAwaited = false;
          var thenable = {
            then: function then(resolve, reject) {
              wasAwaited = true;
              thenableResult.then(function (returnValue) {
                popActScope(prevActScopeDepth);

                if (actScopeDepth === 0) {
                  // We've exited the outermost act scope. Recursively flush the
                  // queue until there's no remaining work.
                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                } else {
                  resolve(returnValue);
                }
              }, function (error) {
                // The callback threw an error.
                popActScope(prevActScopeDepth);
                reject(error);
              });
            }
          };
          {
            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {
              // eslint-disable-next-line no-undef
              Promise.resolve().then(function () {}).then(function () {
                if (!wasAwaited) {
                  didWarnNoAwaitAct = true;
                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
                }
              });
            }
          }
          return thenable;
        } else {
          var returnValue = result; // The callback is not an async function. Exit the current scope
          // immediately, without awaiting.

          popActScope(prevActScopeDepth);

          if (actScopeDepth === 0) {
            // Exiting the outermost act scope. Flush the queue.
            var _queue = ReactCurrentActQueue.current;

            if (_queue !== null) {
              flushActQueue(_queue);
              ReactCurrentActQueue.current = null;
            } // Return a thenable. If the user awaits it, we'll flush again in
            // case additional work was scheduled by a microtask.


            var _thenable = {
              then: function then(resolve, reject) {
                // Confirm we haven't re-entered another `act` scope, in case
                // the user does something weird like await the thenable
                // multiple times.
                if (ReactCurrentActQueue.current === null) {
                  // Recursively flush the queue until there's no remaining work.
                  ReactCurrentActQueue.current = [];
                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                } else {
                  resolve(returnValue);
                }
              }
            };
            return _thenable;
          } else {
            // Since we're inside a nested `act` scope, the returned thenable
            // immediately resolves. The outer scope will flush the queue.
            var _thenable2 = {
              then: function then(resolve, reject) {
                resolve(returnValue);
              }
            };
            return _thenable2;
          }
        }
      }
    }

    function popActScope(prevActScopeDepth) {
      {
        if (prevActScopeDepth !== actScopeDepth - 1) {
          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
        }

        actScopeDepth = prevActScopeDepth;
      }
    }

    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      {
        var queue = ReactCurrentActQueue.current;

        if (queue !== null) {
          try {
            flushActQueue(queue);
            enqueueTask(function () {
              if (queue.length === 0) {
                // No additional work was scheduled. Finish.
                ReactCurrentActQueue.current = null;
                resolve(returnValue);
              } else {
                // Keep flushing work until there's none left.
                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              }
            });
          } catch (error) {
            reject(error);
          }
        } else {
          resolve(returnValue);
        }
      }
    }

    var isFlushing = false;

    function flushActQueue(queue) {
      {
        if (!isFlushing) {
          // Prevent re-entrance.
          isFlushing = true;
          var i = 0;

          try {
            for (; i < queue.length; i++) {
              var callback = queue[i];

              do {
                callback = callback(true);
              } while (callback !== null);
            }

            queue.length = 0;
          } catch (error) {
            // If something throws, leave the remaining callbacks on the queue.
            queue = queue.slice(i + 1);
            throw error;
          } finally {
            isFlushing = false;
          }
        }
      }
    }

    var createElement$1 = createElementWithValidation;
    var cloneElement$1 = cloneElementWithValidation;
    var createFactory = createFactoryWithValidation;
    var Children = {
      map: mapChildren,
      forEach: forEachChildren,
      count: countChildren,
      toArray: toArray,
      only: onlyChild
    };
    exports.Children = Children;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
    exports.cloneElement = cloneElement$1;
    exports.createContext = createContext;
    exports.createElement = createElement$1;
    exports.createFactory = createFactory;
    exports.createRef = createRef;
    exports.forwardRef = forwardRef;
    exports.isValidElement = isValidElement;
    exports.lazy = lazy;
    exports.memo = memo;
    exports.startTransition = startTransition;
    exports.unstable_act = act;
    exports.useCallback = useCallback;
    exports.useContext = useContext;
    exports.useDebugValue = useDebugValue;
    exports.useDeferredValue = useDeferredValue;
    exports.useEffect = useEffect;
    exports.useId = useId;
    exports.useImperativeHandle = useImperativeHandle;
    exports.useInsertionEffect = useInsertionEffect;
    exports.useLayoutEffect = useLayoutEffect;
    exports.useMemo = useMemo;
    exports.useReducer = useReducer;
    exports.useRef = useRef;
    exports.useState = useState;
    exports.useSyncExternalStore = useSyncExternalStore;
    exports.useTransition = useTransition;
    exports.version = ReactVersion;
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }
  })();
}

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

if (true) {
  (function () {
    'use strict';
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    }

    var enableSchedulerDebugging = false;
    var enableProfiling = false;
    var frameYieldMs = 5;

    function push(heap, node) {
      var index = heap.length;
      heap.push(node);
      siftUp(heap, node, index);
    }

    function peek(heap) {
      return heap.length === 0 ? null : heap[0];
    }

    function pop(heap) {
      if (heap.length === 0) {
        return null;
      }

      var first = heap[0];
      var last = heap.pop();

      if (last !== first) {
        heap[0] = last;
        siftDown(heap, last, 0);
      }

      return first;
    }

    function siftUp(heap, node, i) {
      var index = i;

      while (index > 0) {
        var parentIndex = index - 1 >>> 1;
        var parent = heap[parentIndex];

        if (compare(parent, node) > 0) {
          // The parent is larger. Swap positions.
          heap[parentIndex] = node;
          heap[index] = parent;
          index = parentIndex;
        } else {
          // The parent is smaller. Exit.
          return;
        }
      }
    }

    function siftDown(heap, node, i) {
      var index = i;
      var length = heap.length;
      var halfLength = length >>> 1;

      while (index < halfLength) {
        var leftIndex = (index + 1) * 2 - 1;
        var left = heap[leftIndex];
        var rightIndex = leftIndex + 1;
        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

        if (compare(left, node) < 0) {
          if (rightIndex < length && compare(right, left) < 0) {
            heap[index] = right;
            heap[rightIndex] = node;
            index = rightIndex;
          } else {
            heap[index] = left;
            heap[leftIndex] = node;
            index = leftIndex;
          }
        } else if (rightIndex < length && compare(right, node) < 0) {
          heap[index] = right;
          heap[rightIndex] = node;
          index = rightIndex;
        } else {
          // Neither child is smaller. Exit.
          return;
        }
      }
    }

    function compare(a, b) {
      // Compare sort index first, then task id.
      var diff = a.sortIndex - b.sortIndex;
      return diff !== 0 ? diff : a.id - b.id;
    } // TODO: Use symbols?


    var ImmediatePriority = 1;
    var UserBlockingPriority = 2;
    var NormalPriority = 3;
    var LowPriority = 4;
    var IdlePriority = 5;

    function markTaskErrored(task, ms) {}
    /* eslint-disable no-var */


    var hasPerformanceNow = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === 'object' && typeof performance.now === 'function';

    if (hasPerformanceNow) {
      var localPerformance = performance;

      exports.unstable_now = function () {
        return localPerformance.now();
      };
    } else {
      var localDate = Date;
      var initialTime = localDate.now();

      exports.unstable_now = function () {
        return localDate.now() - initialTime;
      };
    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
    // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111


    var maxSigned31BitInt = 1073741823; // Times out immediately

    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
    var NORMAL_PRIORITY_TIMEOUT = 5000;
    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

    var taskQueue = [];
    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.

    var currentTask = null;
    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.

    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.

    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;
    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;
    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom

    var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;

    function advanceTimers(currentTime) {
      // Check for tasks that are no longer delayed and add them to the queue.
      var timer = peek(timerQueue);

      while (timer !== null) {
        if (timer.callback === null) {
          // Timer was cancelled.
          pop(timerQueue);
        } else if (timer.startTime <= currentTime) {
          // Timer fired. Transfer to the task queue.
          pop(timerQueue);
          timer.sortIndex = timer.expirationTime;
          push(taskQueue, timer);
        } else {
          // Remaining timers are pending.
          return;
        }

        timer = peek(timerQueue);
      }
    }

    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);

      if (!isHostCallbackScheduled) {
        if (peek(taskQueue) !== null) {
          isHostCallbackScheduled = true;
          requestHostCallback(flushWork);
        } else {
          var firstTimer = peek(timerQueue);

          if (firstTimer !== null) {
            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
        }
      }
    }

    function flushWork(hasTimeRemaining, initialTime) {
      isHostCallbackScheduled = false;

      if (isHostTimeoutScheduled) {
        // We scheduled a timeout but it's no longer needed. Cancel it.
        isHostTimeoutScheduled = false;
        cancelHostTimeout();
      }

      isPerformingWork = true;
      var previousPriorityLevel = currentPriorityLevel;

      try {
        if (enableProfiling) {
          try {
            return workLoop(hasTimeRemaining, initialTime);
          } catch (error) {
            if (currentTask !== null) {
              var currentTime = exports.unstable_now();
              markTaskErrored(currentTask, currentTime);
              currentTask.isQueued = false;
            }

            throw error;
          }
        } else {
          // No catch in prod code path.
          return workLoop(hasTimeRemaining, initialTime);
        }
      } finally {
        currentTask = null;
        currentPriorityLevel = previousPriorityLevel;
        isPerformingWork = false;
      }
    }

    function workLoop(hasTimeRemaining, initialTime) {
      var currentTime = initialTime;
      advanceTimers(currentTime);
      currentTask = peek(taskQueue);

      while (currentTask !== null && !enableSchedulerDebugging) {
        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
          // This currentTask hasn't expired, and we've reached the deadline.
          break;
        }

        var callback = currentTask.callback;

        if (typeof callback === 'function') {
          currentTask.callback = null;
          currentPriorityLevel = currentTask.priorityLevel;
          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
          var continuationCallback = callback(didUserCallbackTimeout);
          currentTime = exports.unstable_now();

          if (typeof continuationCallback === 'function') {
            currentTask.callback = continuationCallback;
          } else {
            if (currentTask === peek(taskQueue)) {
              pop(taskQueue);
            }
          }

          advanceTimers(currentTime);
        } else {
          pop(taskQueue);
        }

        currentTask = peek(taskQueue);
      } // Return whether there's additional work


      if (currentTask !== null) {
        return true;
      } else {
        var firstTimer = peek(timerQueue);

        if (firstTimer !== null) {
          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }

        return false;
      }
    }

    function unstable_runWithPriority(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
        case LowPriority:
        case IdlePriority:
          break;

        default:
          priorityLevel = NormalPriority;
      }

      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;

      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    }

    function unstable_next(eventHandler) {
      var priorityLevel;

      switch (currentPriorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
          // Shift down to normal priority
          priorityLevel = NormalPriority;
          break;

        default:
          // Anything lower than normal priority should remain at the current level.
          priorityLevel = currentPriorityLevel;
          break;
      }

      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;

      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    }

    function unstable_wrapCallback(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function () {
        // This is a fork of runWithPriority, inlined for performance.
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;

        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    }

    function unstable_scheduleCallback(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      var startTime;

      if (_typeof(options) === 'object' && options !== null) {
        var delay = options.delay;

        if (typeof delay === 'number' && delay > 0) {
          startTime = currentTime + delay;
        } else {
          startTime = currentTime;
        }
      } else {
        startTime = currentTime;
      }

      var timeout;

      switch (priorityLevel) {
        case ImmediatePriority:
          timeout = IMMEDIATE_PRIORITY_TIMEOUT;
          break;

        case UserBlockingPriority:
          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
          break;

        case IdlePriority:
          timeout = IDLE_PRIORITY_TIMEOUT;
          break;

        case LowPriority:
          timeout = LOW_PRIORITY_TIMEOUT;
          break;

        case NormalPriority:
        default:
          timeout = NORMAL_PRIORITY_TIMEOUT;
          break;
      }

      var expirationTime = startTime + timeout;
      var newTask = {
        id: taskIdCounter++,
        callback: callback,
        priorityLevel: priorityLevel,
        startTime: startTime,
        expirationTime: expirationTime,
        sortIndex: -1
      };

      if (startTime > currentTime) {
        // This is a delayed task.
        newTask.sortIndex = startTime;
        push(timerQueue, newTask);

        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
          // All tasks are delayed, and this is the task with the earliest delay.
          if (isHostTimeoutScheduled) {
            // Cancel an existing timeout.
            cancelHostTimeout();
          } else {
            isHostTimeoutScheduled = true;
          } // Schedule a timeout.


          requestHostTimeout(handleTimeout, startTime - currentTime);
        }
      } else {
        newTask.sortIndex = expirationTime;
        push(taskQueue, newTask); // wait until the next time we yield.

        if (!isHostCallbackScheduled && !isPerformingWork) {
          isHostCallbackScheduled = true;
          requestHostCallback(flushWork);
        }
      }

      return newTask;
    }

    function unstable_pauseExecution() {}

    function unstable_continueExecution() {
      if (!isHostCallbackScheduled && !isPerformingWork) {
        isHostCallbackScheduled = true;
        requestHostCallback(flushWork);
      }
    }

    function unstable_getFirstCallbackNode() {
      return peek(taskQueue);
    }

    function unstable_cancelCallback(task) {
      // remove from the queue because you can't remove arbitrary nodes from an
      // array based heap, only the first one.)
      task.callback = null;
    }

    function unstable_getCurrentPriorityLevel() {
      return currentPriorityLevel;
    }

    var isMessageLoopRunning = false;
    var scheduledHostCallback = null;
    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
    // thread, like user events. By default, it yields multiple times per frame.
    // It does not attempt to align with frame boundaries, since most tasks don't
    // need to be frame aligned; for those that do, use requestAnimationFrame.

    var frameInterval = frameYieldMs;
    var startTime = -1;

    function shouldYieldToHost() {
      var timeElapsed = exports.unstable_now() - startTime;

      if (timeElapsed < frameInterval) {
        // The main thread has only been blocked for a really short amount of time;
        // smaller than a single frame. Don't yield yet.
        return false;
      } // The main thread has been blocked for a non-negligible amount of time. We


      return true;
    }

    function requestPaint() {}

    function forceFrameRate(fps) {
      if (fps < 0 || fps > 125) {
        // Using console['error'] to evade Babel and ESLint
        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
        return;
      }

      if (fps > 0) {
        frameInterval = Math.floor(1000 / fps);
      } else {
        // reset the framerate
        frameInterval = frameYieldMs;
      }
    }

    var performWorkUntilDeadline = function performWorkUntilDeadline() {
      if (scheduledHostCallback !== null) {
        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread
        // has been blocked.

        startTime = currentTime;
        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the
        // error can be observed.
        //
        // Intentionally not using a try-catch, since that makes some debugging
        // techniques harder. Instead, if `scheduledHostCallback` errors, then
        // `hasMoreWork` will remain true, and we'll continue the work loop.

        var hasMoreWork = true;

        try {
          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
        } finally {
          if (hasMoreWork) {
            // If there's more work, schedule the next message event at the end
            // of the preceding one.
            schedulePerformWorkUntilDeadline();
          } else {
            isMessageLoopRunning = false;
            scheduledHostCallback = null;
          }
        }
      } else {
        isMessageLoopRunning = false;
      } // Yielding to the browser will give it a chance to paint, so we can

    };

    var schedulePerformWorkUntilDeadline;

    if (typeof localSetImmediate === 'function') {
      // Node.js and old IE.
      // There's a few reasons for why we prefer setImmediate.
      //
      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
      // (Even though this is a DOM fork of the Scheduler, you could get here
      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
      // https://github.com/facebook/react/issues/20756
      //
      // But also, it runs earlier which is the semantic we want.
      // If other browsers ever implement it, it's better to use it.
      // Although both of these would be inferior to native scheduling.
      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
        localSetImmediate(performWorkUntilDeadline);
      };
    } else if (typeof MessageChannel !== 'undefined') {
      // DOM and Worker environments.
      // We prefer MessageChannel because of the 4ms setTimeout clamping.
      var channel = new MessageChannel();
      var port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;

      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
        port.postMessage(null);
      };
    } else {
      // We should only fallback here in non-browser environments.
      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    }

    function requestHostCallback(callback) {
      scheduledHostCallback = callback;

      if (!isMessageLoopRunning) {
        isMessageLoopRunning = true;
        schedulePerformWorkUntilDeadline();
      }
    }

    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function () {
        callback(exports.unstable_now());
      }, ms);
    }

    function cancelHostTimeout() {
      localClearTimeout(taskTimeoutID);
      taskTimeoutID = -1;
    }

    var unstable_requestPaint = requestPaint;
    var unstable_Profiling = null;
    exports.unstable_IdlePriority = IdlePriority;
    exports.unstable_ImmediatePriority = ImmediatePriority;
    exports.unstable_LowPriority = LowPriority;
    exports.unstable_NormalPriority = NormalPriority;
    exports.unstable_Profiling = unstable_Profiling;
    exports.unstable_UserBlockingPriority = UserBlockingPriority;
    exports.unstable_cancelCallback = unstable_cancelCallback;
    exports.unstable_continueExecution = unstable_continueExecution;
    exports.unstable_forceFrameRate = forceFrameRate;
    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
    exports.unstable_next = unstable_next;
    exports.unstable_pauseExecution = unstable_pauseExecution;
    exports.unstable_requestPaint = unstable_requestPaint;
    exports.unstable_runWithPriority = unstable_runWithPriority;
    exports.unstable_scheduleCallback = unstable_scheduleCallback;
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = unstable_wrapCallback;
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */

    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }
  })();
}

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {



if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}

/***/ }),

/***/ "./node_modules/split-on-first/index.js":
/*!**********************************************!*\
  !*** ./node_modules/split-on-first/index.js ***!
  \**********************************************/
/***/ (function(module) {



module.exports = function (string, separator) {
  if (!(typeof string === 'string' && typeof separator === 'string')) {
    throw new TypeError('Expected the arguments to be of type `string`');
  }

  if (separator === '') {
    return [string];
  }

  var separatorIndex = string.indexOf(separator);

  if (separatorIndex === -1) {
    return [string];
  }

  return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
};

/***/ }),

/***/ "./node_modules/strict-uri-encode/index.js":
/*!*************************************************!*\
  !*** ./node_modules/strict-uri-encode/index.js ***!
  \*************************************************/
/***/ (function(module) {



module.exports = function (str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (x) {
    return "%".concat(x.charCodeAt(0).toString(16).toUpperCase());
  });
};

/***/ }),

/***/ "./node_modules/web-vitals/dist/web-vitals.js":
/*!****************************************************!*\
  !*** ./node_modules/web-vitals/dist/web-vitals.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCLS": function() { return /* binding */ h; },
/* harmony export */   "getFCP": function() { return /* binding */ d; },
/* harmony export */   "getFID": function() { return /* binding */ L; },
/* harmony export */   "getLCP": function() { return /* binding */ F; },
/* harmony export */   "getTTFB": function() { return /* binding */ P; }
/* harmony export */ });
var e,
    t,
    n,
    i,
    r = function r(e, t) {
  return {
    name: e,
    value: void 0 === t ? -1 : t,
    delta: 0,
    entries: [],
    id: "v2-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12)
  };
},
    a = function a(e, t) {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(e)) {
      if ("first-input" === e && !("PerformanceEventTiming" in self)) return;
      var n = new PerformanceObserver(function (e) {
        return e.getEntries().map(t);
      });
      return n.observe({
        type: e,
        buffered: !0
      }), n;
    }
  } catch (e) {}
},
    o = function o(e, t) {
  var n = function n(i) {
    "pagehide" !== i.type && "hidden" !== document.visibilityState || (e(i), t && (removeEventListener("visibilitychange", n, !0), removeEventListener("pagehide", n, !0)));
  };

  addEventListener("visibilitychange", n, !0), addEventListener("pagehide", n, !0);
},
    u = function u(e) {
  addEventListener("pageshow", function (t) {
    t.persisted && e(t);
  }, !0);
},
    c = function c(e, t, n) {
  var i;
  return function (r) {
    t.value >= 0 && (r || n) && (t.delta = t.value - (i || 0), (t.delta || void 0 === i) && (i = t.value, e(t)));
  };
},
    f = -1,
    s = function s() {
  return "hidden" === document.visibilityState ? 0 : 1 / 0;
},
    m = function m() {
  o(function (e) {
    var t = e.timeStamp;
    f = t;
  }, !0);
},
    v = function v() {
  return f < 0 && (f = s(), m(), u(function () {
    setTimeout(function () {
      f = s(), m();
    }, 0);
  })), {
    get firstHiddenTime() {
      return f;
    }

  };
},
    d = function d(e, t) {
  var n,
      i = v(),
      o = r("FCP"),
      f = function f(e) {
    "first-contentful-paint" === e.name && (m && m.disconnect(), e.startTime < i.firstHiddenTime && (o.value = e.startTime, o.entries.push(e), n(!0)));
  },
      s = window.performance && performance.getEntriesByName && performance.getEntriesByName("first-contentful-paint")[0],
      m = s ? null : a("paint", f);

  (s || m) && (n = c(e, o, t), s && f(s), u(function (i) {
    o = r("FCP"), n = c(e, o, t), requestAnimationFrame(function () {
      requestAnimationFrame(function () {
        o.value = performance.now() - i.timeStamp, n(!0);
      });
    });
  }));
},
    p = !1,
    l = -1,
    h = function h(e, t) {
  p || (d(function (e) {
    l = e.value;
  }), p = !0);

  var n,
      i = function i(t) {
    l > -1 && e(t);
  },
      f = r("CLS", 0),
      s = 0,
      m = [],
      v = function v(e) {
    if (!e.hadRecentInput) {
      var t = m[0],
          i = m[m.length - 1];
      s && e.startTime - i.startTime < 1e3 && e.startTime - t.startTime < 5e3 ? (s += e.value, m.push(e)) : (s = e.value, m = [e]), s > f.value && (f.value = s, f.entries = m, n());
    }
  },
      h = a("layout-shift", v);

  h && (n = c(i, f, t), o(function () {
    h.takeRecords().map(v), n(!0);
  }), u(function () {
    s = 0, l = -1, f = r("CLS", 0), n = c(i, f, t);
  }));
},
    T = {
  passive: !0,
  capture: !0
},
    y = new Date(),
    g = function g(i, r) {
  e || (e = r, t = i, n = new Date(), w(removeEventListener), E());
},
    E = function E() {
  if (t >= 0 && t < n - y) {
    var r = {
      entryType: "first-input",
      name: e.type,
      target: e.target,
      cancelable: e.cancelable,
      startTime: e.timeStamp,
      processingStart: e.timeStamp + t
    };
    i.forEach(function (e) {
      e(r);
    }), i = [];
  }
},
    S = function S(e) {
  if (e.cancelable) {
    var t = (e.timeStamp > 1e12 ? new Date() : performance.now()) - e.timeStamp;
    "pointerdown" == e.type ? function (e, t) {
      var n = function n() {
        g(e, t), r();
      },
          i = function i() {
        r();
      },
          r = function r() {
        removeEventListener("pointerup", n, T), removeEventListener("pointercancel", i, T);
      };

      addEventListener("pointerup", n, T), addEventListener("pointercancel", i, T);
    }(t, e) : g(t, e);
  }
},
    w = function w(e) {
  ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function (t) {
    return e(t, S, T);
  });
},
    L = function L(n, f) {
  var s,
      m = v(),
      d = r("FID"),
      p = function p(e) {
    e.startTime < m.firstHiddenTime && (d.value = e.processingStart - e.startTime, d.entries.push(e), s(!0));
  },
      l = a("first-input", p);

  s = c(n, d, f), l && o(function () {
    l.takeRecords().map(p), l.disconnect();
  }, !0), l && u(function () {
    var a;
    d = r("FID"), s = c(n, d, f), i = [], t = -1, e = null, w(addEventListener), a = p, i.push(a), E();
  });
},
    b = {},
    F = function F(e, t) {
  var n,
      i = v(),
      f = r("LCP"),
      s = function s(e) {
    var t = e.startTime;
    t < i.firstHiddenTime && (f.value = t, f.entries.push(e), n());
  },
      m = a("largest-contentful-paint", s);

  if (m) {
    n = c(e, f, t);

    var d = function d() {
      b[f.id] || (m.takeRecords().map(s), m.disconnect(), b[f.id] = !0, n(!0));
    };

    ["keydown", "click"].forEach(function (e) {
      addEventListener(e, d, {
        once: !0,
        capture: !0
      });
    }), o(d, !0), u(function (i) {
      f = r("LCP"), n = c(e, f, t), requestAnimationFrame(function () {
        requestAnimationFrame(function () {
          f.value = performance.now() - i.timeStamp, b[f.id] = !0, n(!0);
        });
      });
    });
  }
},
    P = function P(e) {
  var t,
      n = r("TTFB");
  t = function t() {
    try {
      var t = performance.getEntriesByType("navigation")[0] || function () {
        var e = performance.timing,
            t = {
          entryType: "navigation",
          startTime: 0
        };

        for (var n in e) {
          "navigationStart" !== n && "toJSON" !== n && (t[n] = Math.max(e[n] - e.navigationStart, 0));
        }

        return t;
      }();

      if (n.value = n.delta = t.responseStart, n.value < 0 || n.value > performance.now()) return;
      n.entries = [t], e(n);
    } catch (e) {}
  }, "complete" === document.readyState ? setTimeout(t, 0) : addEventListener("load", function () {
    return setTimeout(t, 0);
  });
};



/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _extends; }
/* harmony export */ });
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsQ0FBeFcsRUFBeVcsZUFBYVgsUUFBUSxDQUFDczVILFVBQXRCLEdBQWlDamhFLFVBQVUsQ0FBQ2cvRCxDQUFELEVBQUcsQ0FBSCxDQUEzQyxHQUFpRDU3RixnQkFBZ0IsQ0FBQyxNQUFELEVBQVMsWUFBVTtJQUFDLE9BQU80OEIsVUFBVSxDQUFDZy9ELENBQUQsRUFBRyxDQUFILENBQWpCO0VBQXVCLENBQTNDLENBQTFhO0FBQXdkLENBQTVySTs7Ozs7Ozs7Ozs7Ozs7OztBQ0FlLFNBQVN1QyxRQUFULEdBQW9CO0VBQ2pDQSxRQUFRLEdBQUd4a0ksTUFBTSxDQUFDa0UsTUFBUCxHQUFnQmxFLE1BQU0sQ0FBQ2tFLE1BQVAsQ0FBY3M3QyxJQUFkLEVBQWhCLEdBQXVDLFVBQVVsdEIsTUFBVixFQUFrQjtJQUNsRSxLQUFLLElBQUk1eUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2dILFNBQVMsQ0FBQzVILE1BQTlCLEVBQXNDWSxDQUFDLEVBQXZDLEVBQTJDO01BQ3pDLElBQUk0UyxNQUFNLEdBQUc1TCxTQUFTLENBQUNoSCxDQUFELENBQXRCOztNQUVBLEtBQUssSUFBSVEsR0FBVCxJQUFnQm9TLE1BQWhCLEVBQXdCO1FBQ3RCLElBQUl0UyxNQUFNLENBQUNiLFNBQVAsQ0FBaUIyTCxjQUFqQixDQUFnQ3pMLElBQWhDLENBQXFDaVQsTUFBckMsRUFBNkNwUyxHQUE3QyxDQUFKLEVBQXVEO1VBQ3JEb3lCLE1BQU0sQ0FBQ3B5QixHQUFELENBQU4sR0FBY29TLE1BQU0sQ0FBQ3BTLEdBQUQsQ0FBcEI7UUFDRDtNQUNGO0lBQ0Y7O0lBRUQsT0FBT295QixNQUFQO0VBQ0QsQ0FaRDtFQWFBLE9BQU9reUcsUUFBUSxDQUFDLzhILEtBQVQsQ0FBZSxJQUFmLEVBQXFCZixTQUFyQixDQUFQO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC11c2Utcm91dGVyLy4vbm9kZV9tb2R1bGVzL2RlY29kZS11cmktY29tcG9uZW50L2luZGV4LmpzIiwid2VicGFjazovL3JlYWN0LXVzZS1yb3V0ZXIvLi9ub2RlX21vZHVsZXMvZmlsdGVyLW9iai9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdC11c2Utcm91dGVyLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5LXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdC11c2Utcm91dGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL3JlYWN0LXVzZS1yb3V0ZXIvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2NsaWVudC5qcyIsIndlYnBhY2s6Ly9yZWFjdC11c2Utcm91dGVyLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdC11c2Utcm91dGVyLy4uLy4uLy4uL3BhY2thZ2VzL3JlYWN0LXJvdXRlci1kb20vaW5kZXgudHN4Iiwid2VicGFjazovL3JlYWN0LXVzZS1yb3V0ZXIvLi4vLi4vLi4vcGFja2FnZXMvcmVhY3Qtcm91dGVyL2xpYi9jb250ZXh0LnRzIiwid2VicGFjazovL3JlYWN0LXVzZS1yb3V0ZXIvLi4vLi4vLi4vcGFja2FnZXMvcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vcmVhY3QtdXNlLXJvdXRlci8uLi8uLi8uLi9wYWNrYWdlcy9yZWFjdC1yb3V0ZXIvbGliL2hvb2tzLnRzeCIsIndlYnBhY2s6Ly9yZWFjdC11c2Utcm91dGVyLy4uLy4uLy4uL3BhY2thZ2VzL3JlYWN0LXJvdXRlci9saWIvY29tcG9uZW50cy50c3giLCJ3ZWJwYWNrOi8vcmVhY3QtdXNlLXJvdXRlci8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmVhY3QtdXNlLXJvdXRlci8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdC11c2Utcm91dGVyLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL3JlYWN0LXVzZS1yb3V0ZXIvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwid2VicGFjazovL3JlYWN0LXVzZS1yb3V0ZXIvLi9ub2RlX21vZHVsZXMvc3BsaXQtb24tZmlyc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmVhY3QtdXNlLXJvdXRlci8uL25vZGVfbW9kdWxlcy9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9yZWFjdC11c2Utcm91dGVyLy4vbm9kZV9tb2R1bGVzL3dlYi12aXRhbHMvZGlzdC93ZWItdml0YWxzLmpzIiwid2VicGFjazovL3JlYWN0LXVzZS1yb3V0ZXIvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgdG9rZW4gPSAnJVthLWYwLTldezJ9JztcbnZhciBzaW5nbGVNYXRjaGVyID0gbmV3IFJlZ0V4cCh0b2tlbiwgJ2dpJyk7XG52YXIgbXVsdGlNYXRjaGVyID0gbmV3IFJlZ0V4cCgnKCcgKyB0b2tlbiArICcpKycsICdnaScpO1xuXG5mdW5jdGlvbiBkZWNvZGVDb21wb25lbnRzKGNvbXBvbmVudHMsIHNwbGl0KSB7XG5cdHRyeSB7XG5cdFx0Ly8gVHJ5IHRvIGRlY29kZSB0aGUgZW50aXJlIHN0cmluZyBmaXJzdFxuXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoY29tcG9uZW50cy5qb2luKCcnKSk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIERvIG5vdGhpbmdcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdHJldHVybiBjb21wb25lbnRzO1xuXHR9XG5cblx0c3BsaXQgPSBzcGxpdCB8fCAxO1xuXG5cdC8vIFNwbGl0IHRoZSBhcnJheSBpbiAyIHBhcnRzXG5cdHZhciBsZWZ0ID0gY29tcG9uZW50cy5zbGljZSgwLCBzcGxpdCk7XG5cdHZhciByaWdodCA9IGNvbXBvbmVudHMuc2xpY2Uoc3BsaXQpO1xuXG5cdHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmNhbGwoW10sIGRlY29kZUNvbXBvbmVudHMobGVmdCksIGRlY29kZUNvbXBvbmVudHMocmlnaHQpKTtcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdHZhciB0b2tlbnMgPSBpbnB1dC5tYXRjaChzaW5nbGVNYXRjaGVyKTtcblxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpbnB1dCA9IGRlY29kZUNvbXBvbmVudHModG9rZW5zLCBpKS5qb2luKCcnKTtcblxuXHRcdFx0dG9rZW5zID0gaW5wdXQubWF0Y2goc2luZ2xlTWF0Y2hlcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlucHV0O1xuXHR9XG59XG5cbmZ1bmN0aW9uIGN1c3RvbURlY29kZVVSSUNvbXBvbmVudChpbnB1dCkge1xuXHQvLyBLZWVwIHRyYWNrIG9mIGFsbCB0aGUgcmVwbGFjZW1lbnRzIGFuZCBwcmVmaWxsIHRoZSBtYXAgd2l0aCB0aGUgYEJPTWBcblx0dmFyIHJlcGxhY2VNYXAgPSB7XG5cdFx0JyVGRSVGRic6ICdcXHVGRkZEXFx1RkZGRCcsXG5cdFx0JyVGRiVGRSc6ICdcXHVGRkZEXFx1RkZGRCdcblx0fTtcblxuXHR2YXIgbWF0Y2ggPSBtdWx0aU1hdGNoZXIuZXhlYyhpbnB1dCk7XG5cdHdoaWxlIChtYXRjaCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBEZWNvZGUgYXMgYmlnIGNodW5rcyBhcyBwb3NzaWJsZVxuXHRcdFx0cmVwbGFjZU1hcFttYXRjaFswXV0gPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMF0pO1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0dmFyIHJlc3VsdCA9IGRlY29kZShtYXRjaFswXSk7XG5cblx0XHRcdGlmIChyZXN1bHQgIT09IG1hdGNoWzBdKSB7XG5cdFx0XHRcdHJlcGxhY2VNYXBbbWF0Y2hbMF1dID0gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG1hdGNoID0gbXVsdGlNYXRjaGVyLmV4ZWMoaW5wdXQpO1xuXHR9XG5cblx0Ly8gQWRkIGAlQzJgIGF0IHRoZSBlbmQgb2YgdGhlIG1hcCB0byBtYWtlIHN1cmUgaXQgZG9lcyBub3QgcmVwbGFjZSB0aGUgY29tYmluYXRvciBiZWZvcmUgZXZlcnl0aGluZyBlbHNlXG5cdHJlcGxhY2VNYXBbJyVDMiddID0gJ1xcdUZGRkQnO1xuXG5cdHZhciBlbnRyaWVzID0gT2JqZWN0LmtleXMocmVwbGFjZU1hcCk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Ly8gUmVwbGFjZSBhbGwgZGVjb2RlZCBjb21wb25lbnRzXG5cdFx0dmFyIGtleSA9IGVudHJpZXNbaV07XG5cdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKG5ldyBSZWdFeHAoa2V5LCAnZycpLCByZXBsYWNlTWFwW2tleV0pO1xuXHR9XG5cblx0cmV0dXJuIGlucHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbmNvZGVkVVJJKSB7XG5cdGlmICh0eXBlb2YgZW5jb2RlZFVSSSAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBgZW5jb2RlZFVSSWAgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYCwgZ290IGAnICsgdHlwZW9mIGVuY29kZWRVUkkgKyAnYCcpO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRlbmNvZGVkVVJJID0gZW5jb2RlZFVSSS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcblxuXHRcdC8vIFRyeSB0aGUgYnVpbHQgaW4gZGVjb2RlciBmaXJzdFxuXHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZFVSSSk7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIEZhbGxiYWNrIHRvIGEgbW9yZSBhZHZhbmNlZCBkZWNvZGVyXG5cdFx0cmV0dXJuIGN1c3RvbURlY29kZVVSSUNvbXBvbmVudChlbmNvZGVkVVJJKTtcblx0fVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgcHJlZGljYXRlKSB7XG5cdHZhciByZXQgPSB7fTtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHR2YXIgaXNBcnIgPSBBcnJheS5pc0FycmF5KHByZWRpY2F0ZSk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0dmFyIHZhbCA9IG9ialtrZXldO1xuXG5cdFx0aWYgKGlzQXJyID8gcHJlZGljYXRlLmluZGV4T2Yoa2V5KSAhPT0gLTEgOiBwcmVkaWNhdGUoa2V5LCB2YWwsIG9iaikpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgc3RyaWN0VXJpRW5jb2RlID0gcmVxdWlyZSgnc3RyaWN0LXVyaS1lbmNvZGUnKTtcbmNvbnN0IGRlY29kZUNvbXBvbmVudCA9IHJlcXVpcmUoJ2RlY29kZS11cmktY29tcG9uZW50Jyk7XG5jb25zdCBzcGxpdE9uRmlyc3QgPSByZXF1aXJlKCdzcGxpdC1vbi1maXJzdCcpO1xuY29uc3QgZmlsdGVyT2JqZWN0ID0gcmVxdWlyZSgnZmlsdGVyLW9iaicpO1xuXG5jb25zdCBpc051bGxPclVuZGVmaW5lZCA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG5cbmNvbnN0IGVuY29kZUZyYWdtZW50SWRlbnRpZmllciA9IFN5bWJvbCgnZW5jb2RlRnJhZ21lbnRJZGVudGlmaWVyJyk7XG5cbmZ1bmN0aW9uIGVuY29kZXJGb3JBcnJheUZvcm1hdChvcHRpb25zKSB7XG5cdHN3aXRjaCAob3B0aW9ucy5hcnJheUZvcm1hdCkge1xuXHRcdGNhc2UgJ2luZGV4Jzpcblx0XHRcdHJldHVybiBrZXkgPT4gKHJlc3VsdCwgdmFsdWUpID0+IHtcblx0XHRcdFx0Y29uc3QgaW5kZXggPSByZXN1bHQubGVuZ3RoO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0KG9wdGlvbnMuc2tpcE51bGwgJiYgdmFsdWUgPT09IG51bGwpIHx8XG5cdFx0XHRcdFx0KG9wdGlvbnMuc2tpcEVtcHR5U3RyaW5nICYmIHZhbHVlID09PSAnJylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBbLi4ucmVzdWx0LCBbZW5jb2RlKGtleSwgb3B0aW9ucyksICdbJywgaW5kZXgsICddJ10uam9pbignJyldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHQuLi5yZXN1bHQsXG5cdFx0XHRcdFx0W2VuY29kZShrZXksIG9wdGlvbnMpLCAnWycsIGVuY29kZShpbmRleCwgb3B0aW9ucyksICddPScsIGVuY29kZSh2YWx1ZSwgb3B0aW9ucyldLmpvaW4oJycpXG5cdFx0XHRcdF07XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnYnJhY2tldCc6XG5cdFx0XHRyZXR1cm4ga2V5ID0+IChyZXN1bHQsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0KG9wdGlvbnMuc2tpcE51bGwgJiYgdmFsdWUgPT09IG51bGwpIHx8XG5cdFx0XHRcdFx0KG9wdGlvbnMuc2tpcEVtcHR5U3RyaW5nICYmIHZhbHVlID09PSAnJylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBbLi4ucmVzdWx0LCBbZW5jb2RlKGtleSwgb3B0aW9ucyksICdbXSddLmpvaW4oJycpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbLi4ucmVzdWx0LCBbZW5jb2RlKGtleSwgb3B0aW9ucyksICdbXT0nLCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKCcnKV07XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnY29sb24tbGlzdC1zZXBhcmF0b3InOlxuXHRcdFx0cmV0dXJuIGtleSA9PiAocmVzdWx0LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBOdWxsICYmIHZhbHVlID09PSBudWxsKSB8fFxuXHRcdFx0XHRcdChvcHRpb25zLnNraXBFbXB0eVN0cmluZyAmJiB2YWx1ZSA9PT0gJycpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gWy4uLnJlc3VsdCwgW2VuY29kZShrZXksIG9wdGlvbnMpLCAnOmxpc3Q9J10uam9pbignJyldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFsuLi5yZXN1bHQsIFtlbmNvZGUoa2V5LCBvcHRpb25zKSwgJzpsaXN0PScsIGVuY29kZSh2YWx1ZSwgb3B0aW9ucyldLmpvaW4oJycpXTtcblx0XHRcdH07XG5cblx0XHRjYXNlICdjb21tYSc6XG5cdFx0Y2FzZSAnc2VwYXJhdG9yJzpcblx0XHRjYXNlICdicmFja2V0LXNlcGFyYXRvcic6IHtcblx0XHRcdGNvbnN0IGtleVZhbHVlU2VwID0gb3B0aW9ucy5hcnJheUZvcm1hdCA9PT0gJ2JyYWNrZXQtc2VwYXJhdG9yJyA/XG5cdFx0XHRcdCdbXT0nIDpcblx0XHRcdFx0Jz0nO1xuXG5cdFx0XHRyZXR1cm4ga2V5ID0+IChyZXN1bHQsIHZhbHVlKSA9PiB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0KG9wdGlvbnMuc2tpcE51bGwgJiYgdmFsdWUgPT09IG51bGwpIHx8XG5cdFx0XHRcdFx0KG9wdGlvbnMuc2tpcEVtcHR5U3RyaW5nICYmIHZhbHVlID09PSAnJylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYW5zbGF0ZSBudWxsIHRvIGFuIGVtcHR5IHN0cmluZyBzbyB0aGF0IGl0IGRvZXNuJ3Qgc2VyaWFsaXplIGFzICdudWxsJ1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZTtcblxuXHRcdFx0XHRpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdHJldHVybiBbW2VuY29kZShrZXksIG9wdGlvbnMpLCBrZXlWYWx1ZVNlcCwgZW5jb2RlKHZhbHVlLCBvcHRpb25zKV0uam9pbignJyldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtbcmVzdWx0LCBlbmNvZGUodmFsdWUsIG9wdGlvbnMpXS5qb2luKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpXTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBrZXkgPT4gKHJlc3VsdCwgdmFsdWUpID0+IHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0XHQob3B0aW9ucy5za2lwTnVsbCAmJiB2YWx1ZSA9PT0gbnVsbCkgfHxcblx0XHRcdFx0XHQob3B0aW9ucy5za2lwRW1wdHlTdHJpbmcgJiYgdmFsdWUgPT09ICcnKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFsuLi5yZXN1bHQsIGVuY29kZShrZXksIG9wdGlvbnMpXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbLi4ucmVzdWx0LCBbZW5jb2RlKGtleSwgb3B0aW9ucyksICc9JywgZW5jb2RlKHZhbHVlLCBvcHRpb25zKV0uam9pbignJyldO1xuXHRcdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiBwYXJzZXJGb3JBcnJheUZvcm1hdChvcHRpb25zKSB7XG5cdGxldCByZXN1bHQ7XG5cblx0c3dpdGNoIChvcHRpb25zLmFycmF5Rm9ybWF0KSB7XG5cdFx0Y2FzZSAnaW5kZXgnOlxuXHRcdFx0cmV0dXJuIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikgPT4ge1xuXHRcdFx0XHRyZXN1bHQgPSAvXFxbKFxcZCopXFxdJC8uZXhlYyhrZXkpO1xuXG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC9cXFtcXGQqXFxdJC8sICcnKTtcblxuXHRcdFx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHt9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XVtyZXN1bHRbMV1dID0gdmFsdWU7XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnYnJhY2tldCc6XG5cdFx0XHRyZXR1cm4gKGtleSwgdmFsdWUsIGFjY3VtdWxhdG9yKSA9PiB7XG5cdFx0XHRcdHJlc3VsdCA9IC8oXFxbXFxdKSQvLmV4ZWMoa2V5KTtcblx0XHRcdFx0a2V5ID0ga2V5LnJlcGxhY2UoL1xcW1xcXSQvLCAnJyk7XG5cblx0XHRcdFx0aWYgKCFyZXN1bHQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBbdmFsdWVdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBbXS5jb25jYXQoYWNjdW11bGF0b3Jba2V5XSwgdmFsdWUpO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2NvbG9uLWxpc3Qtc2VwYXJhdG9yJzpcblx0XHRcdHJldHVybiAoa2V5LCB2YWx1ZSwgYWNjdW11bGF0b3IpID0+IHtcblx0XHRcdFx0cmVzdWx0ID0gLyg6bGlzdCkkLy5leGVjKGtleSk7XG5cdFx0XHRcdGtleSA9IGtleS5yZXBsYWNlKC86bGlzdCQvLCAnJyk7XG5cblx0XHRcdFx0aWYgKCFyZXN1bHQpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGFjY3VtdWxhdG9yW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBbdmFsdWVdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBbXS5jb25jYXQoYWNjdW11bGF0b3Jba2V5XSwgdmFsdWUpO1xuXHRcdFx0fTtcblxuXHRcdGNhc2UgJ2NvbW1hJzpcblx0XHRjYXNlICdzZXBhcmF0b3InOlxuXHRcdFx0cmV0dXJuIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikgPT4ge1xuXHRcdFx0XHRjb25zdCBpc0FycmF5ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5pbmNsdWRlcyhvcHRpb25zLmFycmF5Rm9ybWF0U2VwYXJhdG9yKTtcblx0XHRcdFx0Y29uc3QgaXNFbmNvZGVkQXJyYXkgPSAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhaXNBcnJheSAmJiBkZWNvZGUodmFsdWUsIG9wdGlvbnMpLmluY2x1ZGVzKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpKTtcblx0XHRcdFx0dmFsdWUgPSBpc0VuY29kZWRBcnJheSA/IGRlY29kZSh2YWx1ZSwgb3B0aW9ucykgOiB2YWx1ZTtcblx0XHRcdFx0Y29uc3QgbmV3VmFsdWUgPSBpc0FycmF5IHx8IGlzRW5jb2RlZEFycmF5ID8gdmFsdWUuc3BsaXQob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcikubWFwKGl0ZW0gPT4gZGVjb2RlKGl0ZW0sIG9wdGlvbnMpKSA6IHZhbHVlID09PSBudWxsID8gdmFsdWUgOiBkZWNvZGUodmFsdWUsIG9wdGlvbnMpO1xuXHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gbmV3VmFsdWU7XG5cdFx0XHR9O1xuXG5cdFx0Y2FzZSAnYnJhY2tldC1zZXBhcmF0b3InOlxuXHRcdFx0cmV0dXJuIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikgPT4ge1xuXHRcdFx0XHRjb25zdCBpc0FycmF5ID0gLyhcXFtcXF0pJC8udGVzdChrZXkpO1xuXHRcdFx0XHRrZXkgPSBrZXkucmVwbGFjZSgvXFxbXFxdJC8sICcnKTtcblxuXHRcdFx0XHRpZiAoIWlzQXJyYXkpIHtcblx0XHRcdFx0XHRhY2N1bXVsYXRvcltrZXldID0gdmFsdWUgPyBkZWNvZGUodmFsdWUsIG9wdGlvbnMpIDogdmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgYXJyYXlWYWx1ZSA9IHZhbHVlID09PSBudWxsID9cblx0XHRcdFx0XHRbXSA6XG5cdFx0XHRcdFx0dmFsdWUuc3BsaXQob3B0aW9ucy5hcnJheUZvcm1hdFNlcGFyYXRvcikubWFwKGl0ZW0gPT4gZGVjb2RlKGl0ZW0sIG9wdGlvbnMpKTtcblxuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IGFycmF5VmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IFtdLmNvbmNhdChhY2N1bXVsYXRvcltrZXldLCBhcnJheVZhbHVlKTtcblx0XHRcdH07XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIChrZXksIHZhbHVlLCBhY2N1bXVsYXRvcikgPT4ge1xuXHRcdFx0XHRpZiAoYWNjdW11bGF0b3Jba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0YWNjdW11bGF0b3Jba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFjY3VtdWxhdG9yW2tleV0gPSBbXS5jb25jYXQoYWNjdW11bGF0b3Jba2V5XSwgdmFsdWUpO1xuXHRcdFx0fTtcblx0fVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5Rm9ybWF0U2VwYXJhdG9yKHZhbHVlKSB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8IHZhbHVlLmxlbmd0aCAhPT0gMSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2FycmF5Rm9ybWF0U2VwYXJhdG9yIG11c3QgYmUgc2luZ2xlIGNoYXJhY3RlciBzdHJpbmcnKTtcblx0fVxufVxuXG5mdW5jdGlvbiBlbmNvZGUodmFsdWUsIG9wdGlvbnMpIHtcblx0aWYgKG9wdGlvbnMuZW5jb2RlKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuc3RyaWN0ID8gc3RyaWN0VXJpRW5jb2RlKHZhbHVlKSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGRlY29kZSh2YWx1ZSwgb3B0aW9ucykge1xuXHRpZiAob3B0aW9ucy5kZWNvZGUpIHtcblx0XHRyZXR1cm4gZGVjb2RlQ29tcG9uZW50KHZhbHVlKTtcblx0fVxuXG5cdHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24ga2V5c1NvcnRlcihpbnB1dCkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcblx0XHRyZXR1cm4gaW5wdXQuc29ydCgpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcpIHtcblx0XHRyZXR1cm4ga2V5c1NvcnRlcihPYmplY3Qua2V5cyhpbnB1dCkpXG5cdFx0XHQuc29ydCgoYSwgYikgPT4gTnVtYmVyKGEpIC0gTnVtYmVyKGIpKVxuXHRcdFx0Lm1hcChrZXkgPT4gaW5wdXRba2V5XSk7XG5cdH1cblxuXHRyZXR1cm4gaW5wdXQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUhhc2goaW5wdXQpIHtcblx0Y29uc3QgaGFzaFN0YXJ0ID0gaW5wdXQuaW5kZXhPZignIycpO1xuXHRpZiAoaGFzaFN0YXJ0ICE9PSAtMSkge1xuXHRcdGlucHV0ID0gaW5wdXQuc2xpY2UoMCwgaGFzaFN0YXJ0KTtcblx0fVxuXG5cdHJldHVybiBpbnB1dDtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzaCh1cmwpIHtcblx0bGV0IGhhc2ggPSAnJztcblx0Y29uc3QgaGFzaFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnKTtcblx0aWYgKGhhc2hTdGFydCAhPT0gLTEpIHtcblx0XHRoYXNoID0gdXJsLnNsaWNlKGhhc2hTdGFydCk7XG5cdH1cblxuXHRyZXR1cm4gaGFzaDtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdChpbnB1dCkge1xuXHRpbnB1dCA9IHJlbW92ZUhhc2goaW5wdXQpO1xuXHRjb25zdCBxdWVyeVN0YXJ0ID0gaW5wdXQuaW5kZXhPZignPycpO1xuXHRpZiAocXVlcnlTdGFydCA9PT0gLTEpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRyZXR1cm4gaW5wdXQuc2xpY2UocXVlcnlTdGFydCArIDEpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG5cdGlmIChvcHRpb25zLnBhcnNlTnVtYmVycyAmJiAhTnVtYmVyLmlzTmFOKE51bWJlcih2YWx1ZSkpICYmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRyaW0oKSAhPT0gJycpKSB7XG5cdFx0dmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMucGFyc2VCb29sZWFucyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnIHx8IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdmYWxzZScpKSB7XG5cdFx0dmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG5cdH1cblxuXHRyZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlKHF1ZXJ5LCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRkZWNvZGU6IHRydWUsXG5cdFx0c29ydDogdHJ1ZSxcblx0XHRhcnJheUZvcm1hdDogJ25vbmUnLFxuXHRcdGFycmF5Rm9ybWF0U2VwYXJhdG9yOiAnLCcsXG5cdFx0cGFyc2VOdW1iZXJzOiBmYWxzZSxcblx0XHRwYXJzZUJvb2xlYW5zOiBmYWxzZVxuXHR9LCBvcHRpb25zKTtcblxuXHR2YWxpZGF0ZUFycmF5Rm9ybWF0U2VwYXJhdG9yKG9wdGlvbnMuYXJyYXlGb3JtYXRTZXBhcmF0b3IpO1xuXG5cdGNvbnN0IGZvcm1hdHRlciA9IHBhcnNlckZvckFycmF5Rm9ybWF0KG9wdGlvbnMpO1xuXG5cdC8vIENyZWF0ZSBhbiBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGVcblx0Y29uc3QgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRpZiAodHlwZW9mIHF1ZXJ5ICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eWz8jJl0vLCAnJyk7XG5cblx0aWYgKCFxdWVyeSkge1xuXHRcdHJldHVybiByZXQ7XG5cdH1cblxuXHRmb3IgKGNvbnN0IHBhcmFtIG9mIHF1ZXJ5LnNwbGl0KCcmJykpIHtcblx0XHRpZiAocGFyYW0gPT09ICcnKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRsZXQgW2tleSwgdmFsdWVdID0gc3BsaXRPbkZpcnN0KG9wdGlvbnMuZGVjb2RlID8gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykgOiBwYXJhbSwgJz0nKTtcblxuXHRcdC8vIE1pc3NpbmcgYD1gIHNob3VsZCBiZSBgbnVsbGA6XG5cdFx0Ly8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xuXHRcdHZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBbJ2NvbW1hJywgJ3NlcGFyYXRvcicsICdicmFja2V0LXNlcGFyYXRvciddLmluY2x1ZGVzKG9wdGlvbnMuYXJyYXlGb3JtYXQpID8gdmFsdWUgOiBkZWNvZGUodmFsdWUsIG9wdGlvbnMpO1xuXHRcdGZvcm1hdHRlcihkZWNvZGUoa2V5LCBvcHRpb25zKSwgdmFsdWUsIHJldCk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXQpKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSByZXRba2V5XTtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuXHRcdFx0Zm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZVtrXSA9IHBhcnNlVmFsdWUodmFsdWVba10sIG9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXRba2V5XSA9IHBhcnNlVmFsdWUodmFsdWUsIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNvcnQgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIHJldDtcblx0fVxuXG5cdHJldHVybiAob3B0aW9ucy5zb3J0ID09PSB0cnVlID8gT2JqZWN0LmtleXMocmV0KS5zb3J0KCkgOiBPYmplY3Qua2V5cyhyZXQpLnNvcnQob3B0aW9ucy5zb3J0KSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuXHRcdGNvbnN0IHZhbHVlID0gcmV0W2tleV07XG5cdFx0aWYgKEJvb2xlYW4odmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHQvLyBTb3J0IG9iamVjdCBrZXlzLCBub3QgdmFsdWVzXG5cdFx0XHRyZXN1bHRba2V5XSA9IGtleXNTb3J0ZXIodmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRba2V5XSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuXG5leHBvcnRzLmV4dHJhY3QgPSBleHRyYWN0O1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IChvYmplY3QsIG9wdGlvbnMpID0+IHtcblx0aWYgKCFvYmplY3QpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0ZW5jb2RlOiB0cnVlLFxuXHRcdHN0cmljdDogdHJ1ZSxcblx0XHRhcnJheUZvcm1hdDogJ25vbmUnLFxuXHRcdGFycmF5Rm9ybWF0U2VwYXJhdG9yOiAnLCdcblx0fSwgb3B0aW9ucyk7XG5cblx0dmFsaWRhdGVBcnJheUZvcm1hdFNlcGFyYXRvcihvcHRpb25zLmFycmF5Rm9ybWF0U2VwYXJhdG9yKTtcblxuXHRjb25zdCBzaG91bGRGaWx0ZXIgPSBrZXkgPT4gKFxuXHRcdChvcHRpb25zLnNraXBOdWxsICYmIGlzTnVsbE9yVW5kZWZpbmVkKG9iamVjdFtrZXldKSkgfHxcblx0XHQob3B0aW9ucy5za2lwRW1wdHlTdHJpbmcgJiYgb2JqZWN0W2tleV0gPT09ICcnKVxuXHQpO1xuXG5cdGNvbnN0IGZvcm1hdHRlciA9IGVuY29kZXJGb3JBcnJheUZvcm1hdChvcHRpb25zKTtcblxuXHRjb25zdCBvYmplY3RDb3B5ID0ge307XG5cblx0Zm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqZWN0KSkge1xuXHRcdGlmICghc2hvdWxkRmlsdGVyKGtleSkpIHtcblx0XHRcdG9iamVjdENvcHlba2V5XSA9IG9iamVjdFtrZXldO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3RDb3B5KTtcblxuXHRpZiAob3B0aW9ucy5zb3J0ICE9PSBmYWxzZSkge1xuXHRcdGtleXMuc29ydChvcHRpb25zLnNvcnQpO1xuXHR9XG5cblx0cmV0dXJuIGtleXMubWFwKGtleSA9PiB7XG5cdFx0Y29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKGtleSwgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRpZiAodmFsdWUubGVuZ3RoID09PSAwICYmIG9wdGlvbnMuYXJyYXlGb3JtYXQgPT09ICdicmFja2V0LXNlcGFyYXRvcicpIHtcblx0XHRcdFx0cmV0dXJuIGVuY29kZShrZXksIG9wdGlvbnMpICsgJ1tdJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRcdC5yZWR1Y2UoZm9ybWF0dGVyKGtleSksIFtdKVxuXHRcdFx0XHQuam9pbignJicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbmNvZGUoa2V5LCBvcHRpb25zKSArICc9JyArIGVuY29kZSh2YWx1ZSwgb3B0aW9ucyk7XG5cdH0pLmZpbHRlcih4ID0+IHgubGVuZ3RoID4gMCkuam9pbignJicpO1xufTtcblxuZXhwb3J0cy5wYXJzZVVybCA9ICh1cmwsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGRlY29kZTogdHJ1ZVxuXHR9LCBvcHRpb25zKTtcblxuXHRjb25zdCBbdXJsXywgaGFzaF0gPSBzcGxpdE9uRmlyc3QodXJsLCAnIycpO1xuXG5cdHJldHVybiBPYmplY3QuYXNzaWduKFxuXHRcdHtcblx0XHRcdHVybDogdXJsXy5zcGxpdCgnPycpWzBdIHx8ICcnLFxuXHRcdFx0cXVlcnk6IHBhcnNlKGV4dHJhY3QodXJsKSwgb3B0aW9ucylcblx0XHR9LFxuXHRcdG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJzZUZyYWdtZW50SWRlbnRpZmllciAmJiBoYXNoID8ge2ZyYWdtZW50SWRlbnRpZmllcjogZGVjb2RlKGhhc2gsIG9wdGlvbnMpfSA6IHt9XG5cdCk7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeVVybCA9IChvYmplY3QsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGVuY29kZTogdHJ1ZSxcblx0XHRzdHJpY3Q6IHRydWUsXG5cdFx0W2VuY29kZUZyYWdtZW50SWRlbnRpZmllcl06IHRydWVcblx0fSwgb3B0aW9ucyk7XG5cblx0Y29uc3QgdXJsID0gcmVtb3ZlSGFzaChvYmplY3QudXJsKS5zcGxpdCgnPycpWzBdIHx8ICcnO1xuXHRjb25zdCBxdWVyeUZyb21VcmwgPSBleHBvcnRzLmV4dHJhY3Qob2JqZWN0LnVybCk7XG5cdGNvbnN0IHBhcnNlZFF1ZXJ5RnJvbVVybCA9IGV4cG9ydHMucGFyc2UocXVlcnlGcm9tVXJsLCB7c29ydDogZmFsc2V9KTtcblxuXHRjb25zdCBxdWVyeSA9IE9iamVjdC5hc3NpZ24ocGFyc2VkUXVlcnlGcm9tVXJsLCBvYmplY3QucXVlcnkpO1xuXHRsZXQgcXVlcnlTdHJpbmcgPSBleHBvcnRzLnN0cmluZ2lmeShxdWVyeSwgb3B0aW9ucyk7XG5cdGlmIChxdWVyeVN0cmluZykge1xuXHRcdHF1ZXJ5U3RyaW5nID0gYD8ke3F1ZXJ5U3RyaW5nfWA7XG5cdH1cblxuXHRsZXQgaGFzaCA9IGdldEhhc2gob2JqZWN0LnVybCk7XG5cdGlmIChvYmplY3QuZnJhZ21lbnRJZGVudGlmaWVyKSB7XG5cdFx0aGFzaCA9IGAjJHtvcHRpb25zW2VuY29kZUZyYWdtZW50SWRlbnRpZmllcl0gPyBlbmNvZGUob2JqZWN0LmZyYWdtZW50SWRlbnRpZmllciwgb3B0aW9ucykgOiBvYmplY3QuZnJhZ21lbnRJZGVudGlmaWVyfWA7XG5cdH1cblxuXHRyZXR1cm4gYCR7dXJsfSR7cXVlcnlTdHJpbmd9JHtoYXNofWA7XG59O1xuXG5leHBvcnRzLnBpY2sgPSAoaW5wdXQsIGZpbHRlciwgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0cGFyc2VGcmFnbWVudElkZW50aWZpZXI6IHRydWUsXG5cdFx0W2VuY29kZUZyYWdtZW50SWRlbnRpZmllcl06IGZhbHNlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGNvbnN0IHt1cmwsIHF1ZXJ5LCBmcmFnbWVudElkZW50aWZpZXJ9ID0gZXhwb3J0cy5wYXJzZVVybChpbnB1dCwgb3B0aW9ucyk7XG5cdHJldHVybiBleHBvcnRzLnN0cmluZ2lmeVVybCh7XG5cdFx0dXJsLFxuXHRcdHF1ZXJ5OiBmaWx0ZXJPYmplY3QocXVlcnksIGZpbHRlciksXG5cdFx0ZnJhZ21lbnRJZGVudGlmaWVyXG5cdH0sIG9wdGlvbnMpO1xufTtcblxuZXhwb3J0cy5leGNsdWRlID0gKGlucHV0LCBmaWx0ZXIsIG9wdGlvbnMpID0+IHtcblx0Y29uc3QgZXhjbHVzaW9uRmlsdGVyID0gQXJyYXkuaXNBcnJheShmaWx0ZXIpID8ga2V5ID0+ICFmaWx0ZXIuaW5jbHVkZXMoa2V5KSA6IChrZXksIHZhbHVlKSA9PiAhZmlsdGVyKGtleSwgdmFsdWUpO1xuXG5cdHJldHVybiBleHBvcnRzLnBpY2soaW5wdXQsIGV4Y2x1c2lvbkZpbHRlciwgb3B0aW9ucyk7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgICAgdmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBTY2hlZHVsZXIgPSByZXF1aXJlKCdzY2hlZHVsZXInKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBzdXBwcmVzc1dhcm5pbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldFN1cHByZXNzV2FybmluZyhuZXdTdXBwcmVzc1dhcm5pbmcpIHtcbiAge1xuICAgIHN1cHByZXNzV2FybmluZyA9IG5ld1N1cHByZXNzV2FybmluZztcbiAgfVxufSAvLyBJbiBERVYsIGNhbGxzIHRvIGNvbnNvbGUud2FybiBhbmQgY29uc29sZS5lcnJvciBnZXQgcmVwbGFjZWRcbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGlmICghc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIEZ1bmN0aW9uQ29tcG9uZW50ID0gMDtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDE7XG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDI7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb24gb3IgY2xhc3NcblxudmFyIEhvc3RSb290ID0gMzsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cblxudmFyIEhvc3RDb21wb25lbnQgPSA1O1xudmFyIEhvc3RUZXh0ID0gNjtcbnZhciBGcmFnbWVudCA9IDc7XG52YXIgTW9kZSA9IDg7XG52YXIgQ29udGV4dENvbnN1bWVyID0gOTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSAxMDtcbnZhciBGb3J3YXJkUmVmID0gMTE7XG52YXIgUHJvZmlsZXIgPSAxMjtcbnZhciBTdXNwZW5zZUNvbXBvbmVudCA9IDEzO1xudmFyIE1lbW9Db21wb25lbnQgPSAxNDtcbnZhciBTaW1wbGVNZW1vQ29tcG9uZW50ID0gMTU7XG52YXIgTGF6eUNvbXBvbmVudCA9IDE2O1xudmFyIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCA9IDE3O1xudmFyIERlaHlkcmF0ZWRGcmFnbWVudCA9IDE4O1xudmFyIFN1c3BlbnNlTGlzdENvbXBvbmVudCA9IDE5O1xudmFyIFNjb3BlQ29tcG9uZW50ID0gMjE7XG52YXIgT2Zmc2NyZWVuQ29tcG9uZW50ID0gMjI7XG52YXIgTGVnYWN5SGlkZGVuQ29tcG9uZW50ID0gMjM7XG52YXIgQ2FjaGVDb21wb25lbnQgPSAyNDtcbnZhciBUcmFjaW5nTWFya2VyQ29tcG9uZW50ID0gMjU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVDbGllbnRSZW5kZXJGYWxsYmFja09uVGV4dE1pc21hdGNoID0gdHJ1ZTsgLy8gVE9ETzogTmVlZCB0byByZXZpZXcgdGhpcyBjb2RlIG9uZSBtb3JlIHRpbWUgYmVmb3JlIGxhbmRpbmdcbi8vIHRoZSByZWFjdC1yZWNvbmNpbGVyIHBhY2thZ2UuXG5cbnZhciBlbmFibGVOZXdSZWNvbmNpbGVyID0gZmFsc2U7IC8vIFN1cHBvcnQgbGVnYWN5IFByaW1lciBzdXBwb3J0IG9uIGludGVybmFsIEZCIHd3d1xuXG52YXIgZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiA9IGZhbHNlOyAvLyBGQi1vbmx5IHVzYWdlLiBUaGUgbmV3IEFQSSBoYXMgZGlmZmVyZW50IHNlbWFudGljcy5cblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcblxudmFyIGVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2sgPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpenpcbi8vIFJlYWN0IERPTSBDaG9wcGluZyBCbG9ja1xuLy9cbi8vIFNpbWlsYXIgdG8gbWFpbiBDaG9wcGluZyBCbG9jayBidXQgb25seSBmbGFncyByZWxhdGVkIHRvIFJlYWN0IERPTS4gVGhlc2UgYXJlXG4vLyBncm91cGVkIGJlY2F1c2Ugd2Ugd2lsbCBsaWtlbHkgYmF0Y2ggYWxsIG9mIHRoZW0gaW50byBhIHNpbmdsZSBtYWpvciByZWxlYXNlLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERpc2FibGUgc3VwcG9ydCBmb3IgY29tbWVudCBub2RlcyBhcyBSZWFjdCBET00gY29udGFpbmVycy4gQWxyZWFkeSBkaXNhYmxlZFxuLy8gaW4gb3BlbiBzb3VyY2UsIGJ1dCB3d3cgY29kZWJhc2Ugc3RpbGwgcmVsaWVzIG9uIGl0LiBOZWVkIHRvIHJlbW92ZS5cblxudmFyIGRpc2FibGVDb21tZW50c0FzRE9NQ29udGFpbmVycyA9IHRydWU7IC8vIERpc2FibGUgamF2YXNjcmlwdDogVVJMIHN0cmluZ3MgaW4gaHJlZiBmb3IgWFNTIHByb3RlY3Rpb24uXG4vLyBhbmQgY2xpZW50IHJlbmRlcmluZywgbW9zdGx5IHRvIGFsbG93IEpTWCBhdHRyaWJ1dGVzIHRvIGFwcGx5IHRvIHRoZSBjdXN0b21cbi8vIGVsZW1lbnQncyBvYmplY3QgcHJvcGVydGllcyBpbnN0ZWFkIG9mIG9ubHkgSFRNTCBhdHRyaWJ1dGVzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTM0N1xuXG52YXIgZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCA9IGZhbHNlOyAvLyBEaXNhYmxlcyBjaGlsZHJlbiBmb3IgPHRleHRhcmVhPiBlbGVtZW50c1xudmFyIHdhcm5BYm91dFN0cmluZ1JlZnMgPSBmYWxzZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERlYnVnZ2luZyBhbmQgRGV2VG9vbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGRzIHVzZXIgdGltaW5nIG1hcmtzIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wIHN0dWZmLFxuLy8gZm9yIGFuIGV4cGVyaW1lbnRhbCB0aW1lbGluZSB0b29sLlxuXG52YXIgZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyID0gdHJ1ZTsgLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIHJlbmRlci1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlXG5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyA9IHRydWU7IC8vIFBoYXNlIHBhcmFtIHBhc3NlZCB0byBvblJlbmRlciBjYWxsYmFjayBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFuIFwidXBkYXRlXCIgYW5kIGEgXCJjYXNjYWRpbmctdXBkYXRlXCIuXG5cbnZhciBhbGxOYXRpdmVFdmVudHMgPSBuZXcgU2V0KCk7XG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cblxuXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAqIG9ubHkgaW4gdHJ1ZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSAge30gOyAvLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgaW4gdHJ1ZVxuXG5mdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lICsgJ0NhcHR1cmUnLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLCBkZXBlbmRlbmNpZXMpIHtcbiAge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdKSB7XG4gICAgICBlcnJvcignRXZlbnRSZWdpc3RyeTogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gZGVwZW5kZW5jaWVzO1xuXG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIGFsbE5hdGl2ZUV2ZW50cy5hZGQoZGVwZW5kZW5jaWVzW2ldKTtcbiAgfVxufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQgYCVzYCBhdHRyaWJ1dGUgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgYXR0cmlidXRlTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrUHJvcFN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIHByb3AgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgcHJvcE5hbWUsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uKHZhbHVlLCBwcm9wTmFtZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBgJXNgIENTUyBwcm9wZXJ0eSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCBwcm9wTmFtZSwgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0h0bWxTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBIVE1MIG1hcmt1cCB1c2VzIGEgdmFsdWUgb2YgdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdGb3JtIGZpZWxkIHZhbHVlcyAodmFsdWUsIGNoZWNrZWQsIGRlZmF1bHRWYWx1ZSwgb3IgZGVmYXVsdENoZWNrZWQgcHJvcHMpJyArICcgbXVzdCBiZSBzdHJpbmdzLCBub3QgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcblxuICB7XG4gICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOiAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG5cbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG5cbiAgICAgIGNhc2UgT1ZFUkxPQURFRF9CT09MRUFOOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuXG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSk7XG5cbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlLCBzYW5pdGl6ZVVSTCwgcmVtb3ZlRW1wdHlTdHJpbmcpIHtcbiAgdGhpcy5hY2NlcHRzQm9vbGVhbnMgPSB0eXBlID09PSBCT09MRUFOSVNIX1NUUklORyB8fCB0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTjtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2U7XG4gIHRoaXMubXVzdFVzZVByb3BlcnR5ID0gbXVzdFVzZVByb3BlcnR5O1xuICB0aGlzLnByb3BlcnR5TmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2FuaXRpemVVUkwgPSBzYW5pdGl6ZVVSTDtcbiAgdGhpcy5yZW1vdmVFbXB0eVN0cmluZyA9IHJlbW92ZUVtcHR5U3RyaW5nO1xufSAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cblxuXG52YXIgcHJvcGVydGllcyA9IHt9OyAvLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblxudmFyIHJlc2VydmVkUHJvcHMgPSBbJ2NoaWxkcmVuJywgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ107XG5cbnJlc2VydmVkUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBSRVNFUlZFRCwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIEEgZmV3IFJlYWN0IHN0cmluZyBhdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbmFtZS5cbi8vIFRoaXMgaXMgYSBtYXBwaW5nIGZyb20gUmVhY3QgcHJvcCBuYW1lcyB0byB0aGUgYXR0cmlidXRlIG5hbWVzLlxuXG5bWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnY2xhc3NOYW1lJywgJ2NsYXNzJ10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBuYW1lID0gX3JlZlswXSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBfcmVmWzFdO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuXG5bJ2NvbnRlbnRFZGl0YWJsZScsICdkcmFnZ2FibGUnLCAnc3BlbGxDaGVjaycsICd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBTVkcgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cbi8vIFNpbmNlIHRoZXNlIGFyZSBTVkcgYXR0cmlidXRlcywgdGhlaXIgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cblxuWydhdXRvUmV2ZXJzZScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZvY3VzYWJsZScsICdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGJvb2xlYW4gYXR0cmlidXRlcy5cblxuWydhbGxvd0Z1bGxTY3JlZW4nLCAnYXN5bmMnLCAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywgJ2F1dG9QbGF5JywgJ2NvbnRyb2xzJywgJ2RlZmF1bHQnLCAnZGVmZXInLCAnZGlzYWJsZWQnLCAnZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUnLCAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJywgJ2Zvcm1Ob1ZhbGlkYXRlJywgJ2hpZGRlbicsICdsb29wJywgJ25vTW9kdWxlJywgJ25vVmFsaWRhdGUnLCAnb3BlbicsICdwbGF5c0lubGluZScsICdyZWFkT25seScsICdyZXF1aXJlZCcsICdyZXZlcnNlZCcsICdzY29wZWQnLCAnc2VhbWxlc3MnLCAvLyBNaWNyb2RhdGFcbidpdGVtU2NvcGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuXG5bJ2NoZWNrZWQnLCAvLyBOb3RlOiBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuJ211bHRpcGxlJywgJ211dGVkJywgJ3NlbGVjdGVkJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCB0cnVlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYXJlIFwib3ZlcmxvYWRlZCBib29sZWFuc1wiOiB0aGV5IGJlaGF2ZSBsaWtlXG4vLyBib29sZWFucywgYnV0IGNhbiBhbHNvIGFjY2VwdCBhIHN0cmluZyB2YWx1ZS5cblxuWydjYXB0dXJlJywgJ2Rvd25sb2FkJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBPVkVSTE9BREVEX0JPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuXG5bJ2NvbHMnLCAncm93cycsICdzaXplJywgJ3NwYW4nIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFBPU0lUSVZFX05VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuXG5bJ3Jvd1NwYW4nLCAnc3RhcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE5VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7XG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG5cbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXS50b1VwcGVyQ2FzZSgpO1xufTsgLy8gVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZywgbmFtZXNwYWNpbmcsXG4vLyBvciBib29sZWFuIHZhbHVlIGFzc2lnbm1lbnQuIFJlZ3VsYXIgYXR0cmlidXRlcyB0aGF0IGp1c3QgYWNjZXB0IHN0cmluZ3Ncbi8vIGFuZCBoYXZlIHRoZSBzYW1lIG5hbWVzIGFyZSBvbWl0dGVkLCBqdXN0IGxpa2UgaW4gdGhlIEhUTUwgYXR0cmlidXRlIGZpbHRlci5cbi8vIFNvbWUgb2YgdGhlc2UgYXR0cmlidXRlcyBjYW4gYmUgaGFyZCB0byBmaW5kLiBUaGlzIGxpc3Qgd2FzIGNyZWF0ZWQgYnlcbi8vIHNjcmFwaW5nIHRoZSBNRE4gZG9jdW1lbnRhdGlvbi5cblxuXG5bJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3htbG5zOnhsaW5rJywgJ3gtaGVpZ2h0JyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeGxpbmsgbmFtZXNwYWNlLlxuXG5bJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bWwgbmFtZXNwYWNlLlxuXG5bJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZScgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXR0cmlidXRlIGV4aXN0cyBib3RoIGluIEhUTUwgYW5kIFNWRy5cbi8vIFRoZSBhdHRyaWJ1dGUgbmFtZSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBTVkcgc28gd2UgY2FuJ3QganVzdCB1c2Vcbi8vIHRoZSBSZWFjdCBuYW1lIGxpa2Ugd2UgZG8gZm9yIGF0dHJpYnV0ZXMgdGhhdCBleGlzdCBvbmx5IGluIEhUTUwuXG5cblsndGFiSW5kZXgnLCAnY3Jvc3NPcmlnaW4nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXR0cmlidXRlcyBhY2NlcHQgVVJMcy4gVGhlc2UgbXVzdCBub3QgYWxsb3cgamF2YXNjcmlwdDogVVJMUy5cbi8vIFRoZXNlIHdpbGwgYWxzbyBuZWVkIHRvIGFjY2VwdCBUcnVzdGVkIFR5cGVzIG9iamVjdCBpbiB0aGUgZnV0dXJlLlxuXG52YXIgeGxpbmtIcmVmID0gJ3hsaW5rSHJlZic7XG5wcm9wZXJ0aWVzW3hsaW5rSHJlZl0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKCd4bGlua0hyZWYnLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbid4bGluazpocmVmJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuZmFsc2UpO1xuWydzcmMnLCAnaHJlZicsICdhY3Rpb24nLCAnZm9ybUFjdGlvbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbiAgdHJ1ZSk7XG59KTtcblxuLy8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxudmFyIGlzSmF2YVNjcmlwdFByb3RvY29sID0gL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO1xudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm4gJiYgaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdCh1cmwpKSB7XG4gICAgICBkaWRXYXJuID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJyArICdVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJyArICd1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLiBSZWFjdCB3YXMgcGFzc2VkICVzLicsIEpTT04uc3RyaW5naWZ5KHVybCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSBcImV4cGVjdGVkXCIgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuXG4gKiBTb21lIHByb3BlcnRpZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvKSB7XG4gIHtcbiAgICBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICByZXR1cm4gbm9kZVtwcm9wZXJ0eU5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGNoZWNrIHByb3RlY3RzIG11bHRpcGxlIHVzZXMgb2YgYGV4cGVjdGVkYCwgd2hpY2ggaXMgd2h5IHRoZVxuICAgICAgLy8gcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb24gcnVsZSBpcyBkaXNhYmxlZCBpbiBzZXZlcmFsIHNwb3RzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHtcbiAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihleHBlY3RlZCwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICggcHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgZnVsbHkgZGlzYWJsZWQgamF2YXNjcmlwdDogVVJMcywgYW5kIGlmXG4gICAgICAgIC8vIHRoZSBoeWRyYXRpb24gaXMgc3VjY2Vzc2Z1bCBvZiBhIGphdmFzY3JpcHQ6IFVSTCwgd2VcbiAgICAgICAgLy8gc3RpbGwgd2FudCB0byB3YXJuIG9uIHRoZSBjbGllbnQuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgICBzYW5pdGl6ZVVSTCgnJyArIGV4cGVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgIGlmIChwcm9wZXJ0eUluZm8udHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOKSB7XG4gICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgICAvLyBXZSBoYWQgYW4gYXR0cmlidXRlIGJ1dCBzaG91bGRuJ3QgaGF2ZSBoYWQgb25lLCBzbyByZWFkIGl0XG4gICAgICAgICAgLy8gZm9yIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGEgYm9vbGVhbiwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIGhhdmUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIGV4cGVjdGVkLlxuICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgfSAvLyBFdmVuIGlmIHRoaXMgcHJvcGVydHkgdXNlcyBhIG5hbWVzcGFjZSB3ZSB1c2UgZ2V0QXR0cmlidXRlXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgYXNzdW1lIGl0cyBuYW1lc3BhY2VkIG5hbWUgaXMgdGhlIHNhbWUgYXMgb3VyIGNvbmZpZy5cbiAgICAgICAgLy8gVG8gdXNlIGdldEF0dHJpYnV0ZU5TIHdlIG5lZWQgdGhlIGxvY2FsIG5hbWUgd2hpY2ggd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAvLyBpbiBvdXIgY29uZmlnIGF0bS5cblxuXG4gICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gbnVsbCA/IGV4cGVjdGVkIDogc3RyaW5nVmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihleHBlY3RlZCwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAoc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH0gLy8gSWYgdGhlIHByb3AgaXNuJ3QgaW4gdGhlIHNwZWNpYWwgbGlzdCwgdHJlYXQgaXQgYXMgYSBzaW1wbGUgYXR0cmlidXRlLlxuXG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHByb3BlcnR5SW5mbyA9PT0gbnVsbCkge1xuICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICB2YXIgX2F0dHJpYnV0ZU5hbWUgPSBuYW1lO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrQXR0cmlidXRlU3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUsICAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbXVzdFVzZVByb3BlcnR5ID0gcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eTtcblxuICBpZiAobXVzdFVzZVByb3BlcnR5KSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB0eXBlID09PSBCT09MRUFOID8gZmFsc2UgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZSByZXN0IGFyZSB0cmVhdGVkIGFzIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGNhc2VzLlxuXG5cbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSxcbiAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF90eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG4gICAgdmFyIGF0dHJpYnV0ZVZhbHVlO1xuXG4gICAgaWYgKF90eXBlID09PSBCT09MRUFOIHx8IF90eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIC8vIElmIGF0dHJpYnV0ZSB0eXBlIGlzIGJvb2xlYW4sIHdlIGtub3cgZm9yIHN1cmUgaXQgd29uJ3QgYmUgYW4gZXhlY3V0aW9uIHNpbmtcbiAgICAgIC8vIGFuZCB3ZSB3b24ndCByZXF1aXJlIFRydXN0ZWQgVHlwZSBoZXJlLlxuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbih2YWx1ZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgc2FuaXRpemVVUkwoYXR0cmlidXRlVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyaWJ1dGVOYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBBVFRFTlRJT05cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3QudHJhY2luZ19tYXJrZXInKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSAgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICB2YXIgb3duZXIgPSAgZmliZXIuX2RlYnVnT3duZXIgPyBmaWJlci5fZGVidWdPd25lci50eXBlIDogbnVsbCA7XG4gIHZhciBzb3VyY2UgPSAgZmliZXIuX2RlYnVnU291cmNlIDtcblxuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICBkbyB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZSQxKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCBzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUkMSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikge1xuICB2YXIgdGFnID0gZmliZXIudGFnLFxuICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdDYWNoZSc7XG5cbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZSQxKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAgcmV0dXJuICdEZWh5ZHJhdGVkRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lJDEodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAvLyBIb3N0IGNvbXBvbmVudCB0eXBlIGlzIHRoZSBkaXNwbGF5IG5hbWUgKGUuZy4gXCJkaXZcIiwgXCJWaWV3XCIpXG4gICAgICByZXR1cm4gdHlwZTtcblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gJ1Jvb3QnO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiAnVGV4dCc7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICAvLyBOYW1lIGNvbWVzIGZyb20gdGhlIHR5cGUgaW4gdGhpcyBjYXNlOyB3ZSBkb24ndCBoYXZlIGEgdGFnLlxuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgIGNhc2UgTW9kZTpcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFKSB7XG4gICAgICAgIC8vIERvbid0IGJlIGxlc3Mgc3BlY2lmaWMgdGhhbiBzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlXG4gICAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnTW9kZSc7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnT2Zmc2NyZWVuJztcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1Njb3BlJztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdUcmFjaW5nTWFya2VyJztcbiAgICAvLyBUaGUgZGlzcGxheSBuYW1lIGZvciB0aGlzIHRhZ3MgY29tZSBmcm9tIHRoZSB1c2VyLXByb3ZpZGVkIHR5cGU6XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIGN1cnJlbnQgPSBudWxsO1xudmFyIGlzUmVuZGVyaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbiAgICAvLyBhbmQgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgd29yay1pbi1wcm9ncmVzcyB2ZXJzaW9uLlxuXG5cbiAgICByZXR1cm4gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgIGN1cnJlbnQgPSBudWxsO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBmaWJlciA9PT0gbnVsbCA/IG51bGwgOiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2O1xuICAgIGN1cnJlbnQgPSBmaWJlcjtcbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SXNSZW5kZXJpbmcocmVuZGVyaW5nKSB7XG4gIHtcbiAgICBpc1JlbmRlcmluZyA9IHJlbmRlcmluZztcbiAgfVxufVxuXG4vLyBGbG93IGRvZXMgbm90IGFsbG93IHN0cmluZyBjb25jYXRlbmF0aW9uIG9mIG1vc3Qgbm9uLXN0cmluZyB0eXBlcy4gVG8gd29ya1xuLy8gYXJvdW5kIHRoaXMgbGltaXRhdGlvbiwgd2UgdXNlIGFuIG9wYXF1ZSB0eXBlIHRoYXQgY2FuIG9ubHkgYmUgb2J0YWluZWQgYnlcbi8vIHBhc3NpbmcgdGhlIHZhbHVlIHRocm91Z2ggZ2V0VG9TdHJpbmdWYWx1ZSBmaXJzdC5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIFRoZSBjb2VyY2lvbiBzYWZldHkgY2hlY2sgaXMgcGVyZm9ybWVkIGluIGdldFRvU3RyaW5nVmFsdWUoKS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5mdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoIShoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLm9uSW5wdXQgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMudmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cblxuICAgIGlmICghKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmNoZWNrZWQgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcblxuICB7XG4gICAgY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKG5vZGVbdmFsdWVGaWVsZF0pO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTsgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldCA9IGRlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0ID0gZGVzY3JpcHRvci5zZXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tGb3JtRmllbGRWYWx1ZVN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIHNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH0pOyAvLyBXZSBjb3VsZCd2ZSBwYXNzZWQgdGhpcyB0aGUgZmlyc3QgdGltZVxuICAvLyBidXQgaXQgdHJpZ2dlcnMgYSBidWcgaW4gSUUxMSBhbmQgRWRnZSAxNC8xNS5cbiAgLy8gQ2FsbGluZyBkZWZpbmVQcm9wZXJ0eSgpIGFnYWluIHNob3VsZCBiZSBlcXVpdmFsZW50LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExNzY4XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGVcbiAgfSk7XG4gIHZhciB0cmFja2VyID0ge1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgIH0sXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAge1xuICAgICAgICBjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBPbmNlIGl0J3MganVzdCBGaWJlciB3ZSBjYW4gbW92ZSB0aGlzIHRvIG5vZGUuX3dyYXBwZXJTdGF0ZVxuXG5cbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpOyAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcblxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuXG4gIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgIHRyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuXG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICB2YXIgaG9zdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuICByZXR1cm4gaG9zdFByb3BzO1xufVxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSksXG4gICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCAnY2hlY2tlZCcsIGNoZWNrZWQsIGZhbHNlKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCB0byBiZSBjb250cm9sbGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0aGUgdmFsdWUgY2hhbmdpbmcgZnJvbSB1bmRlZmluZWQgdG8gJyArICdhIGRlZmluZWQgdmFsdWUsIHdoaWNoIHNob3VsZCBub3QgaGFwcGVuLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIGEgZGVmaW5lZCB0byAnICsgJ3VuZGVmaW5lZCwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG4gIHZhciB2YWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO1xuICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBub2RlLnZhbHVlID09PSAnJyB8fCAvLyBXZSBleHBsaWNpdGx5IHdhbnQgdG8gY29lcmNlIHRvIG51bWJlciBoZXJlIGlmIHBvc3NpYmxlLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSB0b1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdWJtaXQnIHx8IHR5cGUgPT09ICdyZXNldCcpIHtcbiAgICAvLyBTdWJtaXQvcmVzZXQgaW5wdXRzIG5lZWQgdGhlIGF0dHJpYnV0ZSByZW1vdmVkIGNvbXBsZXRlbHkgdG8gYXZvaWRcbiAgICAvLyBibGFuay10ZXh0IGJ1dHRvbnMuXG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgY29tZXMgZnJvbSBhIGNhc2NhZGUgb2ZcbiAgICAvLyBwcm9wZXJ0aWVzOlxuICAgIC8vICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHlcbiAgICAvLyAgMi4gVGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eVxuICAgIC8vICAzLiBPdGhlcndpc2UgdGhlcmUgc2hvdWxkIGJlIG5vIGNoYW5nZVxuICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHByb3BzLnR5cGUsIGdldFRvU3RyaW5nVmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGl0IG9ubHkgY2hhbmdlcyB3aGVuIGl0IG5lZWRzXG4gICAgLy8gdG8gYmUgcmVtb3ZlZCwgc3VjaCBhcyB0cmFuc2l0aW9uaW5nIGZyb20gYSBjaGVja2JveCBpbnRvIGEgdGV4dCBpbnB1dFxuICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzLCBpc0h5ZHJhdGluZykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7IC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gIC8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cblxuICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgfHwgcHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuICAgIHZhciBpc0J1dHRvbiA9IHR5cGUgPT09ICdzdWJtaXQnIHx8IHR5cGUgPT09ICdyZXNldCc7IC8vIEF2b2lkIHNldHRpbmcgdmFsdWUgYXR0cmlidXRlIG9uIHN1Ym1pdC9yZXNldCBpbnB1dHMgYXMgaXQgb3ZlcnJpZGVzIHRoZVxuICAgIC8vIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXIuIFNlZTogIzEyODcyXG5cbiAgICBpZiAoaXNCdXR0b24gJiYgKHByb3BzLnZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHMudmFsdWUgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpOyAvLyBEbyBub3QgYXNzaWduIHZhbHVlIGlmIGl0IGlzIGFscmVhZHkgc2V0LiBUaGlzIHByZXZlbnRzIHVzZXIgdGV4dCBpbnB1dFxuICAgIC8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cblxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzaG91bGQgdXNlXG4gICAgICAgIC8vIHRoZSB3cmFwcGVyU3RhdGUuX2luaXRpYWxWYWx1ZSBwcm9wZXJ0eS4gVGhpcyB1c2VzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAgICAgLy8gICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgICAgICAvLyAgIDMuIEFuIGVtcHR5IHN0cmluZ1xuICAgICAgICBpZiAoaW5pdGlhbFZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICAgICAgbm9kZS52YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBzeW5jaHJvbml6ZWQgdG8gdGhlIHByb3BlcnR5LFxuICAgICAgLy8gc28gd2UgYXNzaWduIGRlZmF1bHRWYWx1ZSB0byB0aGUgc2FtZSB0aGluZyBhcyB0aGUgdmFsdWUgcHJvcGVydHlcbiAgICAgIC8vIGFzc2lnbm1lbnQgc3RlcCBhYm92ZS5cbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIH1cbiAgfSAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG5cblxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcblxuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSAnJztcbiAgfVxuXG4gIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBib3RoIHRoZSBjaGVja2VkIHByb3BlcnR5IGFuZFxuICAgIC8vIGF0dHJpYnV0ZSBhcmUgYXNzaWduZWQgYXQgdGhlIHNhbWUgdGltZSB1c2luZyBkZWZhdWx0Q2hlY2tlZC4gVGhpcyB1c2VzOlxuICAgIC8vXG4gICAgLy8gICAxLiBUaGUgY2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAvLyAgIDIuIFRoZSBkZWZhdWx0Q2hlY2tlZCBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAvLyAgIDMuIE90aGVyd2lzZSwgZmFsc2VcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkO1xuICB9XG5cbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcblxuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH0gLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybS4gSXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gdGhlXG4gICAgLy8gZG9jdW1lbnQuIExldCdzIGp1c3QgdXNlIHRoZSBsb2NhbCBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0XG4gICAgLy8gbWlzcyBhbnl0aGluZy5cblxuXG4gICAge1xuICAgICAgY2hlY2tBdHRyaWJ1dGVTdHJpbmdDb2VyY2lvbihuYW1lLCAnbmFtZScpO1xuICAgIH1cblxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG5cbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cblxuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUob3RoZXJOb2RlKTtcblxuICAgICAgaWYgKCFvdGhlclByb3BzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlICcgKyAnc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgIH0gLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuXG5cbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7IC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59IC8vIEluIENocm9tZSwgYXNzaWduaW5nIGRlZmF1bHRWYWx1ZSB0byBjZXJ0YWluIGlucHV0IHR5cGVzIHRyaWdnZXJzIGlucHV0IHZhbGlkYXRpb24uXG4vLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4vLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuLy9cbi8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4vLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG5cblxuZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gIGlmICggLy8gRm9jdXNlZCBudW1iZXIgaW5wdXRzIHN5bmNocm9uaXplIG9uIGJsdXIuIFNlZSBDaGFuZ2VFdmVudFBsdWdpbi5qc1xuICB0eXBlICE9PSAnbnVtYmVyJyB8fCBnZXRBY3RpdmVFbGVtZW50KG5vZGUub3duZXJEb2N1bWVudCkgIT09IG5vZGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSB0b1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZENoaWxkID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRJbm5lckhUTUwgPSBmYWxzZTtcbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgLy8gSWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQsIHRoZW4gdGhlIGNoaWxkcmVuIG11c3QgYmUgc2ltcGxlLlxuICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnb2JqZWN0JyAmJiBwcm9wcy5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkQ2hpbGQpIHtcbiAgICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgICAgICBlcnJvcignQ2Fubm90IGluZmVyIHRoZSBvcHRpb24gdmFsdWUgb2YgY29tcGxleCBjaGlsZHJlbi4gJyArICdQYXNzIGEgYHZhbHVlYCBwcm9wIG9yIHVzZSBhIHBsYWluIHN0cmluZyBhcyBjaGlsZHJlbiB0byA8b3B0aW9uPi4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghZGlkV2FybkludmFsaWRJbm5lckhUTUwpIHtcbiAgICAgICAgICBkaWRXYXJuSW52YWxpZElubmVySFRNTCA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUGFzcyBhIGB2YWx1ZWAgcHJvcCBpZiB5b3Ugc2V0IGRhbmdlcm91c2x5SW5uZXJIVE1MIHNvIFJlYWN0IGtub3dzICcgKyAnd2hpY2ggdmFsdWUgc2hvdWxkIGJlIHNlbGVjdGVkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cblxuXG4gICAgaWYgKHByb3BzLnNlbGVjdGVkICE9IG51bGwgJiYgIWRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uKSB7XG4gICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG5cbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB0b1N0cmluZyhnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKSkpO1xuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxO1xuXG57XG4gIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG5cbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG5cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BOYW1lSXNBcnJheSA9IGlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcblxuICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFwcm9wTmFtZUlzQXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBwcm9wTmFtZUlzQXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7XG5cbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJyk7XG4gIH0gLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAvLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbiAgLy8gdG8gYmUgYSBzdHJpbmcuXG5cblxuICB2YXIgaG9zdFByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnKTtcblxuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTsgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcblxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUoaW5pdGlhbFZhbHVlKVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSk7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7IC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG5cbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgJiYgbm9kZS5kZWZhdWx0VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcoZGVmYXVsdFZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDsgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cblxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50OyAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cblxuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodGV4dENvbnRlbnQgIT09ICcnICYmIHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKTtcbn1cblxudmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnOyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuXG4gICAgaWYgKCEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAgICAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAgICAgLy8gdGhlIHRhcmdldCBub2RlXG4gICAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwudmFsdWVPZigpLnRvU3RyaW5nKCkgKyAnPC9zdmc+JztcbiAgICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcblxuICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xufSk7XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZS4gRm9yIHRleHQgdXBkYXRlcywgaXQncyBmYXN0ZXJcbiAqIHRvIHNldCB0aGUgYG5vZGVWYWx1ZWAgb2YgdGhlIFRleHQgbm9kZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHVzaW5nXG4gKiBgLnRleHRDb250ZW50YCB3aGljaCB3aWxsIHJlbW92ZSB0aGUgZXhpc3Rpbmcgbm9kZSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vLyBMaXN0IGRlcml2ZWQgZnJvbSBHZWNrbyBzb3VyY2UgY29kZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzRlNjM4ZWZjNzEvbGF5b3V0L3N0eWxlL3Rlc3QvcHJvcGVydHlfZGF0YWJhc2UuanNcbnZhciBzaG9ydGhhbmRUb0xvbmdoYW5kID0ge1xuICBhbmltYXRpb246IFsnYW5pbWF0aW9uRGVsYXknLCAnYW5pbWF0aW9uRGlyZWN0aW9uJywgJ2FuaW1hdGlvbkR1cmF0aW9uJywgJ2FuaW1hdGlvbkZpbGxNb2RlJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ2FuaW1hdGlvbk5hbWUnLCAnYW5pbWF0aW9uUGxheVN0YXRlJywgJ2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uJ10sXG4gIGJhY2tncm91bmQ6IFsnYmFja2dyb3VuZEF0dGFjaG1lbnQnLCAnYmFja2dyb3VuZENsaXAnLCAnYmFja2dyb3VuZENvbG9yJywgJ2JhY2tncm91bmRJbWFnZScsICdiYWNrZ3JvdW5kT3JpZ2luJywgJ2JhY2tncm91bmRQb3NpdGlvblgnLCAnYmFja2dyb3VuZFBvc2l0aW9uWScsICdiYWNrZ3JvdW5kUmVwZWF0JywgJ2JhY2tncm91bmRTaXplJ10sXG4gIGJhY2tncm91bmRQb3NpdGlvbjogWydiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknXSxcbiAgYm9yZGVyOiBbJ2JvcmRlckJvdHRvbUNvbG9yJywgJ2JvcmRlckJvdHRvbVN0eWxlJywgJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckltYWdlT3V0c2V0JywgJ2JvcmRlckltYWdlUmVwZWF0JywgJ2JvcmRlckltYWdlU2xpY2UnLCAnYm9yZGVySW1hZ2VTb3VyY2UnLCAnYm9yZGVySW1hZ2VXaWR0aCcsICdib3JkZXJMZWZ0Q29sb3InLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodENvbG9yJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyUmlnaHRXaWR0aCcsICdib3JkZXJUb3BDb2xvcicsICdib3JkZXJUb3BTdHlsZScsICdib3JkZXJUb3BXaWR0aCddLFxuICBib3JkZXJCbG9ja0VuZDogWydib3JkZXJCbG9ja0VuZENvbG9yJywgJ2JvcmRlckJsb2NrRW5kU3R5bGUnLCAnYm9yZGVyQmxvY2tFbmRXaWR0aCddLFxuICBib3JkZXJCbG9ja1N0YXJ0OiBbJ2JvcmRlckJsb2NrU3RhcnRDb2xvcicsICdib3JkZXJCbG9ja1N0YXJ0U3R5bGUnLCAnYm9yZGVyQmxvY2tTdGFydFdpZHRoJ10sXG4gIGJvcmRlckJvdHRvbTogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCddLFxuICBib3JkZXJDb2xvcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJMZWZ0Q29sb3InLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJUb3BDb2xvciddLFxuICBib3JkZXJJbWFnZTogWydib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnXSxcbiAgYm9yZGVySW5saW5lRW5kOiBbJ2JvcmRlcklubGluZUVuZENvbG9yJywgJ2JvcmRlcklubGluZUVuZFN0eWxlJywgJ2JvcmRlcklubGluZUVuZFdpZHRoJ10sXG4gIGJvcmRlcklubGluZVN0YXJ0OiBbJ2JvcmRlcklubGluZVN0YXJ0Q29sb3InLCAnYm9yZGVySW5saW5lU3RhcnRTdHlsZScsICdib3JkZXJJbmxpbmVTdGFydFdpZHRoJ10sXG4gIGJvcmRlckxlZnQ6IFsnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnXSxcbiAgYm9yZGVyUmFkaXVzOiBbJ2JvcmRlckJvdHRvbUxlZnRSYWRpdXMnLCAnYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMnLCAnYm9yZGVyVG9wTGVmdFJhZGl1cycsICdib3JkZXJUb3BSaWdodFJhZGl1cyddLFxuICBib3JkZXJSaWdodDogWydib3JkZXJSaWdodENvbG9yJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyUmlnaHRXaWR0aCddLFxuICBib3JkZXJTdHlsZTogWydib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyUmlnaHRTdHlsZScsICdib3JkZXJUb3BTdHlsZSddLFxuICBib3JkZXJUb3A6IFsnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyV2lkdGg6IFsnYm9yZGVyQm90dG9tV2lkdGgnLCAnYm9yZGVyTGVmdFdpZHRoJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgY29sdW1uUnVsZTogWydjb2x1bW5SdWxlQ29sb3InLCAnY29sdW1uUnVsZVN0eWxlJywgJ2NvbHVtblJ1bGVXaWR0aCddLFxuICBjb2x1bW5zOiBbJ2NvbHVtbkNvdW50JywgJ2NvbHVtbldpZHRoJ10sXG4gIGZsZXg6IFsnZmxleEJhc2lzJywgJ2ZsZXhHcm93JywgJ2ZsZXhTaHJpbmsnXSxcbiAgZmxleEZsb3c6IFsnZmxleERpcmVjdGlvbicsICdmbGV4V3JhcCddLFxuICBmb250OiBbJ2ZvbnRGYW1pbHknLCAnZm9udEZlYXR1cmVTZXR0aW5ncycsICdmb250S2VybmluZycsICdmb250TGFuZ3VhZ2VPdmVycmlkZScsICdmb250U2l6ZScsICdmb250U2l6ZUFkanVzdCcsICdmb250U3RyZXRjaCcsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAnZm9udFZhcmlhbnRBbHRlcm5hdGVzJywgJ2ZvbnRWYXJpYW50Q2FwcycsICdmb250VmFyaWFudEVhc3RBc2lhbicsICdmb250VmFyaWFudExpZ2F0dXJlcycsICdmb250VmFyaWFudE51bWVyaWMnLCAnZm9udFZhcmlhbnRQb3NpdGlvbicsICdmb250V2VpZ2h0JywgJ2xpbmVIZWlnaHQnXSxcbiAgZm9udFZhcmlhbnQ6IFsnZm9udFZhcmlhbnRBbHRlcm5hdGVzJywgJ2ZvbnRWYXJpYW50Q2FwcycsICdmb250VmFyaWFudEVhc3RBc2lhbicsICdmb250VmFyaWFudExpZ2F0dXJlcycsICdmb250VmFyaWFudE51bWVyaWMnLCAnZm9udFZhcmlhbnRQb3NpdGlvbiddLFxuICBnYXA6IFsnY29sdW1uR2FwJywgJ3Jvd0dhcCddLFxuICBncmlkOiBbJ2dyaWRBdXRvQ29sdW1ucycsICdncmlkQXV0b0Zsb3cnLCAnZ3JpZEF1dG9Sb3dzJywgJ2dyaWRUZW1wbGF0ZUFyZWFzJywgJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCAnZ3JpZFRlbXBsYXRlUm93cyddLFxuICBncmlkQXJlYTogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCcsICdncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkQ29sdW1uOiBbJ2dyaWRDb2x1bW5FbmQnLCAnZ3JpZENvbHVtblN0YXJ0J10sXG4gIGdyaWRDb2x1bW5HYXA6IFsnY29sdW1uR2FwJ10sXG4gIGdyaWRHYXA6IFsnY29sdW1uR2FwJywgJ3Jvd0dhcCddLFxuICBncmlkUm93OiBbJ2dyaWRSb3dFbmQnLCAnZ3JpZFJvd1N0YXJ0J10sXG4gIGdyaWRSb3dHYXA6IFsncm93R2FwJ10sXG4gIGdyaWRUZW1wbGF0ZTogWydncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgbGlzdFN0eWxlOiBbJ2xpc3RTdHlsZUltYWdlJywgJ2xpc3RTdHlsZVBvc2l0aW9uJywgJ2xpc3RTdHlsZVR5cGUnXSxcbiAgbWFyZ2luOiBbJ21hcmdpbkJvdHRvbScsICdtYXJnaW5MZWZ0JywgJ21hcmdpblJpZ2h0JywgJ21hcmdpblRvcCddLFxuICBtYXJrZXI6IFsnbWFya2VyRW5kJywgJ21hcmtlck1pZCcsICdtYXJrZXJTdGFydCddLFxuICBtYXNrOiBbJ21hc2tDbGlwJywgJ21hc2tDb21wb3NpdGUnLCAnbWFza0ltYWdlJywgJ21hc2tNb2RlJywgJ21hc2tPcmlnaW4nLCAnbWFza1Bvc2l0aW9uWCcsICdtYXNrUG9zaXRpb25ZJywgJ21hc2tSZXBlYXQnLCAnbWFza1NpemUnXSxcbiAgbWFza1Bvc2l0aW9uOiBbJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWSddLFxuICBvdXRsaW5lOiBbJ291dGxpbmVDb2xvcicsICdvdXRsaW5lU3R5bGUnLCAnb3V0bGluZVdpZHRoJ10sXG4gIG92ZXJmbG93OiBbJ292ZXJmbG93WCcsICdvdmVyZmxvd1knXSxcbiAgcGFkZGluZzogWydwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nVG9wJ10sXG4gIHBsYWNlQ29udGVudDogWydhbGlnbkNvbnRlbnQnLCAnanVzdGlmeUNvbnRlbnQnXSxcbiAgcGxhY2VJdGVtczogWydhbGlnbkl0ZW1zJywgJ2p1c3RpZnlJdGVtcyddLFxuICBwbGFjZVNlbGY6IFsnYWxpZ25TZWxmJywgJ2p1c3RpZnlTZWxmJ10sXG4gIHRleHREZWNvcmF0aW9uOiBbJ3RleHREZWNvcmF0aW9uQ29sb3InLCAndGV4dERlY29yYXRpb25MaW5lJywgJ3RleHREZWNvcmF0aW9uU3R5bGUnXSxcbiAgdGV4dEVtcGhhc2lzOiBbJ3RleHRFbXBoYXNpc0NvbG9yJywgJ3RleHRFbXBoYXNpc1N0eWxlJ10sXG4gIHRyYW5zaXRpb246IFsndHJhbnNpdGlvbkRlbGF5JywgJ3RyYW5zaXRpb25EdXJhdGlvbicsICd0cmFuc2l0aW9uUHJvcGVydHknLCAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJ10sXG4gIHdvcmRXcmFwOiBbJ292ZXJmbG93V3JhcCddXG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBhc3BlY3RSYXRpbzogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddOyAvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cblxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHtcbiAgICBjaGVja0NTU1Byb3BlcnR5U3RyaW5nQ29lcmNpb24odmFsdWUsIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIHZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKHN0eWxlcykge1xuICB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICB2YXIgZGVsaW1pdGVyID0gJyc7XG5cbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgKGlzQ3VzdG9tUHJvcGVydHkgPyBzdHlsZU5hbWUgOiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMpIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcblxuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuXG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbHVlRW1wdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xufVxuLyoqXG4gKiBHaXZlbiB7Y29sb3I6ICdyZWQnLCBvdmVyZmxvdzogJ2hpZGRlbid9IHJldHVybnMge1xuICogICBjb2xvcjogJ2NvbG9yJyxcbiAqICAgb3ZlcmZsb3dYOiAnb3ZlcmZsb3cnLFxuICogICBvdmVyZmxvd1k6ICdvdmVyZmxvdycsXG4gKiB9LiBUaGlzIGNhbiBiZSByZWFkIGFzIFwidGhlIG92ZXJmbG93WSBwcm9wZXJ0eSB3YXMgc2V0IGJ5IHRoZSBvdmVyZmxvd1xuICogc2hvcnRoYW5kXCIuIFRoYXQgaXMsIHRoZSB2YWx1ZXMgYXJlIHRoZSBwcm9wZXJ0eSB0aGF0IGVhY2ggd2FzIGRlcml2ZWQgZnJvbS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZXMpIHtcbiAgdmFyIGV4cGFuZGVkID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIHZhciBsb25naGFuZHMgPSBzaG9ydGhhbmRUb0xvbmdoYW5kW2tleV0gfHwgW2tleV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdoYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwYW5kZWRbbG9uZ2hhbmRzW2ldXSA9IGtleTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwYW5kZWQ7XG59XG4vKipcbiAqIFdoZW4gbWl4aW5nIHNob3J0aGFuZCBhbmQgbG9uZ2hhbmQgcHJvcGVydHkgbmFtZXMsIHdlIHdhcm4gZHVyaW5nIHVwZGF0ZXMgaWZcbiAqIHdlIGV4cGVjdCBhbiBpbmNvcnJlY3QgcmVzdWx0IHRvIG9jY3VyLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YXJuIGZvcjpcbiAqXG4gKiBVcGRhdGluZyBhIHNob3J0aGFuZCBwcm9wZXJ0eSAobG9uZ2hhbmQgZ2V0cyBvdmVyd3JpdHRlbik6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2JheicsIGZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICdiYXonXG4gKiBSZW1vdmluZyBhIHNob3J0aGFuZCBwcm9wZXJ0eSAobG9uZ2hhbmQgZ2V0cyBsb3N0IHRvbyk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udFZhcmlhbnQ6ICdiYXInfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250ID0gJydcbiAqIFJlbW92aW5nIGEgbG9uZ2hhbmQgcHJvcGVydHkgKHNob3VsZCByZXZlcnQgdG8gc2hvcnRoYW5kOyBkb2Vzbid0KTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250OiAnZm9vJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udFZhcmlhbnQgPSAnJ1xuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2KHN0eWxlVXBkYXRlcywgbmV4dFN0eWxlcykge1xuICB7XG4gICAgaWYgKCFuZXh0U3R5bGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4cGFuZGVkVXBkYXRlcyA9IGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZVVwZGF0ZXMpO1xuICAgIHZhciBleHBhbmRlZFN0eWxlcyA9IGV4cGFuZFNob3J0aGFuZE1hcChuZXh0U3R5bGVzKTtcbiAgICB2YXIgd2FybmVkQWJvdXQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBleHBhbmRlZFVwZGF0ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbEtleSA9IGV4cGFuZGVkVXBkYXRlc1trZXldO1xuICAgICAgdmFyIGNvcnJlY3RPcmlnaW5hbEtleSA9IGV4cGFuZGVkU3R5bGVzW2tleV07XG5cbiAgICAgIGlmIChjb3JyZWN0T3JpZ2luYWxLZXkgJiYgb3JpZ2luYWxLZXkgIT09IGNvcnJlY3RPcmlnaW5hbEtleSkge1xuICAgICAgICB2YXIgd2FybmluZ0tleSA9IG9yaWdpbmFsS2V5ICsgJywnICsgY29ycmVjdE9yaWdpbmFsS2V5O1xuXG4gICAgICAgIGlmICh3YXJuZWRBYm91dFt3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmVkQWJvdXRbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclcyBhIHN0eWxlIHByb3BlcnR5IGR1cmluZyByZXJlbmRlciAoJXMpIHdoZW4gYSAnICsgJ2NvbmZsaWN0aW5nIHByb3BlcnR5IGlzIHNldCAoJXMpIGNhbiBsZWFkIHRvIHN0eWxpbmcgYnVncy4gVG8gJyArIFwiYXZvaWQgdGhpcywgZG9uJ3QgbWl4IHNob3J0aGFuZCBhbmQgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIFwiICsgJ2ZvciB0aGUgc2FtZSB2YWx1ZTsgaW5zdGVhZCwgcmVwbGFjZSB0aGUgc2hvcnRoYW5kIHdpdGggJyArICdzZXBhcmF0ZSB2YWx1ZXMuJywgaXNWYWx1ZUVtcHR5KHN0eWxlVXBkYXRlc1tvcmlnaW5hbEtleV0pID8gJ1JlbW92aW5nJyA6ICdVcGRhdGluZycsIG9yaWdpbmFsS2V5LCBjb3JyZWN0T3JpZ2luYWxLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIGxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxuXG59O1xuXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBhc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG5cblxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICBpZiAocHJvcHMuY2hpbGRyZW4gIT0gbnVsbCB8fCBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGFnICsgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciBcIiArICd1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmIChwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09ICdvYmplY3QnIHx8ICEoSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sICcgKyAnZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wcy5zdHlsZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wcy5zdHlsZSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArIFwibm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIFwiICsgJ3VzaW5nIEpTWC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZW50ZXJrZXloaW50OiAnZW50ZXJLZXlIaW50JyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW1hZ2VzaXplczogJ2ltYWdlU2l6ZXMnLFxuICBpbWFnZXNyY3NldDogJ2ltYWdlU3JjU2V0JyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRlc2NyaXB0aW9uJzogMCxcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIGNvcnJlY3ROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlLCBldmVudFJlZ2lzdHJ5KSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG52YXIgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUgPSAxO1xudmFyIElTX05PTl9ERUxFR0FURUQgPSAxIDw8IDE7XG52YXIgSVNfQ0FQVFVSRV9QSEFTRSA9IDEgPDwgMjtcbi8vIHNldCB0byBMRUdBQ1lfRkJfU1VQUE9SVC4gTEVHQUNZX0ZCX1NVUFBPUlQgb25seSBnZXRzIHNldCB3aGVuXG4vLyB3ZSBjYWxsIHdpbGxEZWZlckxhdGVyRm9yTGVnYWN5RkJTdXBwb3J0LCB0aHVzIG5vdCBiYWlsaW5nIG91dFxuLy8gd2lsbCByZXN1bHQgaW4gZW5kbGVzcyBjeWNsZXMgbGlrZSBhbiBpbmZpbml0ZSBsb29wLlxuLy8gV2UgYWxzbyBkb24ndCB3YW50IHRvIGRlZmVyIGR1cmluZyBldmVudCByZXBsYXlpbmcuXG5cbnZhciBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUyA9IElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFIHwgSVNfTk9OX0RFTEVHQVRFRCB8IElTX0NBUFRVUkVfUEhBU0U7XG5cbi8vIFRoaXMgZXhpc3RzIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBSZWFjdERPTUV2ZW50UmVwbGF5aW5nXG4vLyBhbmQgRE9NUGx1Z2luRXZlbnRTeXN0ZW0uXG52YXIgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gbnVsbDtcbmZ1bmN0aW9uIHNldFJlcGxheWluZ0V2ZW50KGV2ZW50KSB7XG4gIHtcbiAgICBpZiAoY3VycmVudFJlcGxheWluZ0V2ZW50ICE9PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgY3VycmVudGx5IHJlcGxheWluZyBldmVudCB0byBiZSBudWxsLiBUaGlzIGVycm9yICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gZXZlbnQ7XG59XG5mdW5jdGlvbiByZXNldFJlcGxheWluZ0V2ZW50KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnRSZXBsYXlpbmdFdmVudCA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGN1cnJlbnRseSByZXBsYXlpbmcgZXZlbnQgdG8gbm90IGJlIG51bGwuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJyZW50UmVwbGF5aW5nRXZlbnQgPSBudWxsO1xufVxuZnVuY3Rpb24gaXNSZXBsYXlpbmdFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQgPT09IGN1cnJlbnRSZXBsYXlpbmdFdmVudDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93OyAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG5cbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfSAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuXG5cbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbnZhciByZXN0b3JlSW1wbCA9IG51bGw7XG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcblxuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIHJlc3RvcmVJbXBsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oKSBuZWVkcyB0byBiZSBjYWxsZWQgdG8gaGFuZGxlIGEgdGFyZ2V0IGZvciBjb250cm9sbGVkICcgKyAnZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHN0YXRlTm9kZSA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlOyAvLyBHdWFyZCBhZ2FpbnN0IEZpYmVyIGJlaW5nIHVubW91bnRlZC5cblxuICBpZiAoc3RhdGVOb2RlKSB7XG4gICAgdmFyIF9wcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICAgIHJlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIF9wcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpIHtcbiAgcmVzdG9yZUltcGwgPSBpbXBsO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuXG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG4vLyBEZWZhdWx0c1xuXG52YXIgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGZsdXNoU3luY0ltcGwgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZpbmlzaEV2ZW50SGFuZGxlcigpIHtcbiAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICB2YXIgY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMgPSBuZWVkc1N0YXRlUmVzdG9yZSgpO1xuXG4gIGlmIChjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcykge1xuICAgIC8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4gICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAvLyBiYWlscyBvdXQgb2YgdGhlIHVwZGF0ZSB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAgLy8gVE9ETzogUmVzdG9yZSBzdGF0ZSBpbiB0aGUgbWljcm90YXNrLCBhZnRlciB0aGUgZGlzY3JldGUgdXBkYXRlcyBmbHVzaCxcbiAgICAvLyBpbnN0ZWFkIG9mIGVhcmx5IGZsdXNoaW5nIHRoZW0gaGVyZS5cbiAgICBmbHVzaFN5bmNJbXBsKCk7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYSwgYikge1xuICBpZiAoaXNJbnNpZGVFdmVudEhhbmRsZXIpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbiAgICByZXR1cm4gZm4oYSwgYik7XG4gIH1cblxuICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYmF0Y2hlZFVwZGF0ZXNJbXBsKGZuLCBhLCBiKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IGZhbHNlO1xuICAgIGZpbmlzaEV2ZW50SGFuZGxlcigpO1xuICB9XG59IC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBmbHVzaFN5bmNcbmZ1bmN0aW9uIHNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oX2JhdGNoZWRVcGRhdGVzSW1wbCwgX2Rpc2NyZXRlVXBkYXRlc0ltcGwsIF9mbHVzaFN5bmNJbXBsKSB7XG4gIGJhdGNoZWRVcGRhdGVzSW1wbCA9IF9iYXRjaGVkVXBkYXRlc0ltcGw7XG4gIGZsdXNoU3luY0ltcGwgPSBfZmx1c2hTeW5jSW1wbDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZUVudGVyJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuXG4gIGlmIChzdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICBpZiAocHJvcHMgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobGlzdGVuZXIgJiYgdHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgYFwiICsgcmVnaXN0cmF0aW9uTmFtZSArIFwiYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGBcIiArIHR5cGVvZiBsaXN0ZW5lciArIFwiYCB0eXBlLlwiKTtcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxudmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7IC8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydCBldmVudHMgd2l0aCBwYXNzaXZlIGxpc3RlbmVyc1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gJEZsb3dGaXhNZTogSWdub3JlIEZsb3cgY29tcGxhaW5pbmcgYWJvdXQgbmVlZGluZyBhIHZhbHVlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0RldihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCBkb2N1bWVudCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgZG9jdW1lbnRgIGdsb2JhbCB3YXMgZGVmaW5lZCB3aGVuIFJlYWN0IHdhcyBpbml0aWFsaXplZCwgYnV0IGlzIG5vdCAnICsgJ2RlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCAnICsgJ3NjaGVkdWxlcyBhbiB1cGRhdGUgZnJvbSBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2ssIGJ1dCB0aGUgdGVzdCBoYXMgYWxyZWFkeSAnICsgJ2ZpbmlzaGVkIHJ1bm5pbmcuIFRvIHNvbHZlIHRoaXMsIHlvdSBjYW4gZWl0aGVyIHVubW91bnQgdGhlIGNvbXBvbmVudCBhdCAnICsgJ3RoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCAnICsgJ2NhbmNlbGVkIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGApLCBvciB5b3UgY2FuIGNoYW5nZSB0aGUgdGVzdCBpdHNlbGYgJyArICd0byBiZSBhc3luY2hyb25vdXMuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIHZhciBkaWRDYWxsID0gZmFsc2U7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cblxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG5cbiAgICAgIHZhciB3aW5kb3dFdmVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywgJ2V2ZW50Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcbiAgICAgICAgICB3aW5kb3cuZXZlbnQgPSB3aW5kb3dFdmVudDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuXG5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfSAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuXG5cbiAgICAgIHZhciBlcnJvcjsgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc2lsZW5jZSB0aGUgZXJyb3IgcmVwb3J0IGlmIHRoaXMgaGFwcGVucy5cbiAgICAgICAgICAvLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikgey8vIElnbm9yZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuXG5cbiAgICAgIHZhciBldnRUeXBlID0gXCJyZWFjdC1cIiArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTsgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh3aW5kb3dFdmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2V2ZW50Jywgd2luZG93RXZlbnREZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZENhbGwgJiYgZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICB9IC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG5cblxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlV2luZG93RXJyb3IpO1xuXG4gICAgICBpZiAoIWRpZENhbGwpIHtcbiAgICAgICAgLy8gU29tZXRoaW5nIHdlbnQgcmVhbGx5IHdyb25nLCBhbmQgb3VyIGV2ZW50IHdhcyBub3QgZGlzcGF0Y2hlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjczNFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2NTg1XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgcHJvZHVjdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgcmVzdG9yZUFmdGVyRGlzcGF0Y2goKTtcbiAgICAgICAgcmV0dXJuIGludm9rZUd1YXJkZWRDYWxsYmFja1Byb2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsO1xuXG52YXIgaGFzRXJyb3IgPSBmYWxzZTtcbnZhciBjYXVnaHRFcnJvciA9IG51bGw7IC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG5cbnZhciBoYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbnZhciByZXRocm93RXJyb3IgPSBudWxsO1xudmFyIHJlcG9ydGVyID0ge1xuICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gKlxuICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhbWUgYXMgaW52b2tlR3VhcmRlZENhbGxiYWNrLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gZXJyb3IsIGl0IHN0b3Jlc1xuICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICogVE9ETzogU2VlIGlmIGNhdWdodEVycm9yIGFuZCByZXRocm93RXJyb3IgY2FuIGJlIHVuaWZpZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChoYXNFcnJvcikge1xuICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgIGlmICghaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICBoYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgcmV0aHJvd0Vycm9yID0gZXJyb3I7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICovXG5cbmZ1bmN0aW9uIHJldGhyb3dDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IHJldGhyb3dFcnJvcjtcbiAgICBoYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbiAgICByZXRocm93RXJyb3IgPSBudWxsO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBoYXNDYXVnaHRFcnJvcigpIHtcbiAgcmV0dXJuIGhhc0Vycm9yO1xufVxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBoYXMoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgQ2hpbGREZWxldGlvbiA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTY7XG52YXIgQ29udGVudFJlc2V0ID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgQ2FsbGJhY2sgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuNjQ7XG52YXIgRGlkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIEZvcmNlQ2xpZW50UmVuZGVyID1cbi8qICAgICAgICAgICAgKi9cbjI1NjtcbnZhciBSZWYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG41MTI7XG52YXIgU25hcHNob3QgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBQYXNzaXZlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG4yMDQ4O1xudmFyIEh5ZHJhdGluZyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjQwOTY7XG52YXIgVmlzaWJpbGl0eSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBTdG9yZUNvbnNpc3RlbmN5ID1cbi8qICAgICAgICAgICAgICovXG4xNjM4NDtcbnZhciBMaWZlY3ljbGVFZmZlY3RNYXNrID0gUGFzc2l2ZSB8IFVwZGF0ZSB8IENhbGxiYWNrIHwgUmVmIHwgU25hcHNob3QgfCBTdG9yZUNvbnNpc3RlbmN5OyAvLyBVbmlvbiBvZiBhbGwgY29tbWl0IGZsYWdzIChmbGFncyB3aXRoIHRoZSBsaWZldGltZSBvZiBhIHBhcnRpY3VsYXIgY29tbWl0KVxuXG52YXIgSG9zdEVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgICAgICAqL1xuMzI3Njc7IC8vIFRoZXNlIGFyZSBub3QgcmVhbGx5IHNpZGUgZWZmZWN0cywgYnV0IHdlIHN0aWxsIHJldXNlIHRoaXMgZmllbGQuXG5cbnZhciBJbmNvbXBsZXRlID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4zMjc2ODtcbnZhciBTaG91bGRDYXB0dXJlID1cbi8qICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlID1cbi8qICovXG4xMzEwNzI7XG52YXIgRm9ya2VkID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjsgLy8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcbi8vIGUuZy4gYSBmaWJlciB1c2VzIGEgcGFzc2l2ZSBlZmZlY3QgKGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHVwZGF0ZXMgb24gdGhpcyBwYXJ0aWN1bGFyIHJlbmRlcikuXG4vLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGVmZXIgbW9yZSB3b3JrIGluIHRoZSB1bm1vdW50IGNhc2UsXG4vLyBzaW5jZSB3ZSBjYW4gZGVmZXIgdHJhdmVyc2luZyB0aGUgdHJlZSBkdXJpbmcgbGF5b3V0IHRvIGxvb2sgZm9yIFBhc3NpdmUgZWZmZWN0cyxcbi8vIGFuZCBpbnN0ZWFkIHJlbHkgb24gdGhlIHN0YXRpYyBmbGFnIGFzIGEgc2lnbmFsIHRoYXQgdGhlcmUgbWF5IGJlIGNsZWFudXAgd29yay5cblxudmFyIFJlZlN0YXRpYyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjIwOTcxNTI7XG52YXIgTGF5b3V0U3RhdGljID1cbi8qICAgICAgICAgICAgICAgICAqL1xuNDE5NDMwNDtcbnZhciBQYXNzaXZlU3RhdGljID1cbi8qICAgICAgICAgICAgICAgICovXG44Mzg4NjA4OyAvLyBUaGVzZSBmbGFncyBhbGxvdyB1cyB0byB0cmF2ZXJzZSB0byBmaWJlcnMgdGhhdCBoYXZlIGVmZmVjdHMgb24gbW91bnRcbi8vIHdpdGhvdXQgdHJhdmVyc2luZyB0aGUgZW50aXJlIHRyZWUgYWZ0ZXIgZXZlcnkgY29tbWl0IGZvclxuLy8gZG91YmxlIGludm9raW5nXG5cbnZhciBNb3VudExheW91dERldiA9XG4vKiAgICAgICAgICAgICAgICovXG4xNjc3NzIxNjtcbnZhciBNb3VudFBhc3NpdmVEZXYgPVxuLyogICAgICAgICAgICAgICovXG4zMzU1NDQzMjsgLy8gR3JvdXBzIG9mIGZsYWdzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIGNvbW1pdCBwaGFzZSB0byBza2lwIG92ZXIgdHJlZXMgdGhhdFxuLy8gZG9uJ3QgY29udGFpbiBlZmZlY3RzLCBieSBjaGVja2luZyBzdWJ0cmVlRmxhZ3MuXG5cbnZhciBCZWZvcmVNdXRhdGlvbk1hc2sgPSAvLyBUT0RPOiBSZW1vdmUgVXBkYXRlIGZsYWcgZnJvbSBiZWZvcmUgbXV0YXRpb24gcGhhc2UgYnkgcmUtbGFuZGluZyBWaXNpYmlsaXR5XG4vLyBmbGFnIGxvZ2ljIChzZWUgIzIwMDQzKVxuVXBkYXRlIHwgU25hcHNob3QgfCAoIDApO1xudmFyIE11dGF0aW9uTWFzayA9IFBsYWNlbWVudCB8IFVwZGF0ZSB8IENoaWxkRGVsZXRpb24gfCBDb250ZW50UmVzZXQgfCBSZWYgfCBIeWRyYXRpbmcgfCBWaXNpYmlsaXR5O1xudmFyIExheW91dE1hc2sgPSBVcGRhdGUgfCBDYWxsYmFjayB8IFJlZiB8IFZpc2liaWxpdHk7IC8vIFRPRE86IFNwbGl0IGludG8gUGFzc2l2ZU1vdW50TWFzayBhbmQgUGFzc2l2ZVVubW91bnRNYXNrXG5cbnZhciBQYXNzaXZlTWFzayA9IFBhc3NpdmUgfCBDaGlsZERlbGV0aW9uOyAvLyBVbmlvbiBvZiB0YWdzIHRoYXQgZG9uJ3QgZ2V0IHJlc2V0IG9uIGNsb25lcy5cbi8vIFRoaXMgYWxsb3dzIGNlcnRhaW4gY29uY2VwdHMgdG8gcGVyc2lzdCB3aXRob3V0IHJlY2FsY3VsYXRpbmcgdGhlbSxcbi8vIGUuZy4gd2hldGhlciBhIHN1YnRyZWUgY29udGFpbnMgcGFzc2l2ZSBlZmZlY3RzIG9yIHBvcnRhbHMuXG5cbnZhciBTdGF0aWNNYXNrID0gTGF5b3V0U3RhdGljIHwgUGFzc2l2ZVN0YXRpYyB8IFJlZlN0YXRpYztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIHZhciBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuXG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cbiAgICBkbyB7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG5cbiAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4gICAgICAgIC8vIG1vdW50ZWQgZmliZXIgaXMgdGhlIHBhcmVudCBidXQgd2UgbmVlZCB0byBjb250aW51ZSB0byBmaWd1cmUgb3V0XG4gICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBuZWFyZXN0TW91bnRlZDtcbiAgfSAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJGcm9tRmliZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgPyBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICghaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuXG5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuXG4gICAgaWYgKHBhcmVudEEgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcblxuICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBhbHRlcm5hdGUuIFRoaXMgaXMgYW4gdW51c3VhbCBjYXNlLiBDdXJyZW50bHksIGl0IG9ubHlcbiAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIFN1c3BlbnNlIGNvbXBvbmVudCBpcyBoaWRkZW4uIEFuIGV4dHJhIGZyYWdtZW50IGZpYmVyXG4gICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4gICAgICAvLyBvdmVyIHRoaXMgZXh0cmEgZnJhZ21lbnQgZmliZXIgYW5kIHByb2NlZWQgdG8gdGhlIG5leHQgcGFyZW50LlxuICAgICAgdmFyIG5leHRQYXJlbnQgPSBwYXJlbnRBLnJldHVybjtcblxuICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYSA9IGIgPSBuZXh0UGFyZW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuXG5cbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuXG5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfSAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnICcgKyAnaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGEuYWx0ZXJuYXRlICE9PSBiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnMnIGFsdGVybmF0ZXMuIFwiICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9IC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cblxuXG4gIGlmIChhLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxuXG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfSAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5cblxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgcmV0dXJuIGN1cnJlbnRQYXJlbnQgIT09IG51bGwgPyBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY3VycmVudFBhcmVudCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSkge1xuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHZhciBtYXRjaCA9IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjaGlsZCk7XG5cbiAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChjdXJyZW50UGFyZW50KSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwobm9kZSkge1xuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY2hpbGQpO1xuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUaGlzIG1vZHVsZSBvbmx5IGV4aXN0cyBhcyBhbiBFU00gd3JhcHBlciBhcm91bmQgdGhlIGV4dGVybmFsIENvbW1vbkpTXG52YXIgc2NoZWR1bGVDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xudmFyIGNhbmNlbENhbGxiYWNrID0gU2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xudmFyIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkO1xudmFyIHJlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG52YXIgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IFNjaGVkdWxlci51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbDtcbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eTtcbnZhciBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eTtcbnZhciBMb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eTtcbnZhciBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5O1xuLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IG9uIHRoZSBzY2hlZHVsZXIsIGJ1dCBpdCAqZG9lcypcbi8vIG9uIHNjaGVkdWxlci91bnN0YWJsZV9tb2NrLCB3aGljaCB3ZSdsbCBuZWVkIGZvciBpbnRlcm5hbCB0ZXN0aW5nXG52YXIgdW5zdGFibGVfeWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV95aWVsZFZhbHVlO1xudmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcikge1xuICAgICAgLy8gQ29uZGl0aW9uYWxseSBpbmplY3QgdGhlc2UgaG9va3Mgb25seSBpZiBUaW1lbGluZSBwcm9maWxlciBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBidWlsZC5cbiAgICAgIC8vIFRoaXMgZ2l2ZXMgRGV2VG9vbHMgYSB3YXkgdG8gZmVhdHVyZSBkZXRlY3QgdGhhdCBpc24ndCB0aWVkIHRvIHZlcnNpb24gbnVtYmVyXG4gICAgICAvLyAoc2luY2UgcHJvZmlsaW5nIGFuZCB0aW1lbGluZSBhcmUgY29udHJvbGxlZCBieSBkaWZmZXJlbnQgZmVhdHVyZSBmbGFncykuXG4gICAgICBpbnRlcm5hbHMgPSBhc3NpZ24oe30sIGludGVybmFscywge1xuICAgICAgICBnZXRMYW5lTGFiZWxNYXA6IGdldExhbmVMYWJlbE1hcCxcbiAgICAgICAgaW5qZWN0UHJvZmlsaW5nSG9va3M6IGluamVjdFByb2ZpbGluZ0hvb2tzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTsgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cblxuICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhvb2suY2hlY2tEQ0UpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSByZWFsIERldlRvb2xzLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgaG9vayBpbnN0YWxsZWQgYnkgRmFzdCBSZWZyZXNoIHJ1bnRpbWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuICB7XG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QsIGV2ZW50UHJpb3JpdHkpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkaWRFcnJvciA9IChyb290LmN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gRGlkQ2FwdHVyZTtcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlclByaW9yaXR5O1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgICAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgc2NoZWR1bGVyUHJpb3JpdHksIGRpZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCB1bmRlZmluZWQsIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Qb3N0Q29tbWl0Um9vdChyb290KSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgdW5zdGFibGVfeWllbGRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gV2UncmUgaW4gYSB0ZXN0IGJlY2F1c2UgU2NoZWR1bGVyLnVuc3RhYmxlX3lpZWxkVmFsdWUgb25seSBleGlzdHNcbiAgICAgIC8vIGluIFNjaGVkdWxlck1vY2suIFRvIHJlZHVjZSB0aGUgbm9pc2UgaW4gc3RyaWN0IG1vZGUgdGVzdHMsXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBhbmQgZGlzYWJsZSBzY2hlZHVsZXIgeWllbGRpbmcgZHVyaW5nIHRoZSBkb3VibGUgcmVuZGVyXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgc2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBQcm9maWxlciBBUEkgaG9va3NcblxuZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xufVxuXG5mdW5jdGlvbiBnZXRMYW5lTGFiZWxNYXAoKSB7XG4gIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciBsYW5lID0gMTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBUb3RhbExhbmVzOyBpbmRleCsrKSB7XG4gICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICBtYXAuc2V0KGxhbmUsIGxhYmVsKTtcbiAgICAgIGxhbmUgKj0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlciwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyWWllbGRlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgTm9Nb2RlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wOyAvLyBUT0RPOiBSZW1vdmUgQ29uY3VycmVudE1vZGUgYnkgcmVhZGluZyBmcm9tIHRoZSByb290IHRhZyBpbnN0ZWFkXG5cbnZhciBDb25jdXJyZW50TW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUHJvZmlsZU1vZGUgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFN0cmljdExlZ2FjeU1vZGUgPVxuLyogICAgICAgICAgICAgICAqL1xuODtcbnZhciBTdHJpY3RFZmZlY3RzTW9kZSA9XG4vKiAgICAgICAgICAgICAgKi9cbjE2O1xuXG4vLyBUT0RPOiBUaGlzIGlzIHByZXR0eSB3ZWxsIHN1cHBvcnRlZCBieSBicm93c2Vycy4gTWF5YmUgd2UgY2FuIGRyb3AgaXQuXG52YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2s7IC8vIENvdW50IGxlYWRpbmcgemVyb3MuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgdmFyIGFzVWludCA9IHggPj4+IDA7XG5cbiAgaWYgKGFzVWludCA9PT0gMCkge1xuICAgIHJldHVybiAzMjtcbiAgfVxuXG4gIHJldHVybiAzMSAtIChsb2coYXNVaW50KSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gSWYgdGhvc2UgdmFsdWVzIGFyZSBjaGFuZ2VkIHRoYXQgcGFja2FnZSBzaG91bGQgYmUgcmVidWlsdCBhbmQgcmVkZXBsb3llZC5cblxudmFyIFRvdGFsTGFuZXMgPSAzMTtcbnZhciBOb0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgTm9MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUgPVxuLyogICAgKi9cbjI7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZSA9XG4vKiAgICAgICAgICAgICAqL1xuNDtcbnZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICovXG44O1xudmFyIERlZmF1bHRMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBUcmFuc2l0aW9uTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG40MTk0MjQwO1xudmFyIFRyYW5zaXRpb25MYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG42NDtcbnZhciBUcmFuc2l0aW9uTGFuZTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFRyYW5zaXRpb25MYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgVHJhbnNpdGlvbkxhbmU0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBUcmFuc2l0aW9uTGFuZTUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBUcmFuc2l0aW9uTGFuZTYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBUcmFuc2l0aW9uTGFuZTcgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBUcmFuc2l0aW9uTGFuZTggPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBUcmFuc2l0aW9uTGFuZTkgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTYzODQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxMCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFRyYW5zaXRpb25MYW5lMTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBUcmFuc2l0aW9uTGFuZTEyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTMxMDcyO1xudmFyIFRyYW5zaXRpb25MYW5lMTMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4yNjIxNDQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUyNDI4ODtcbnZhciBUcmFuc2l0aW9uTGFuZTE1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTE2ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMzAwMjM0MjQ7XG52YXIgUmV0cnlMYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxOTQzMDQ7XG52YXIgUmV0cnlMYW5lMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgzODg2MDg7XG52YXIgUmV0cnlMYW5lMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjE2Nzc3MjE2O1xudmFyIFJldHJ5TGFuZTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBSZXRyeUxhbmU1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjcxMDg4NjQ7XG52YXIgU29tZVJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAqL1xuMTM0MjE3NzI4O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI2ODQzNTQ1NTtcbnZhciBJZGxlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICAgICovXG4yNjg0MzU0NTY7XG52YXIgSWRsZUxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xudmFyIE9mZnNjcmVlbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEwNzM3NDE4MjQ7IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgdGhlIGV4cGVyaW1lbnRhbCB0aW1lbGluZSAocmVhY3QtZGV2dG9vbHMtdGltZWxpbmUpXG4vLyBJdCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIExhbmVzIHZhbHVlcyBhYm92ZS5cblxuZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpIHtcbiAge1xuICAgIGlmIChsYW5lICYgU3luY0xhbmUpIHtcbiAgICAgIHJldHVybiAnU3luYyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91c0h5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNMYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91cyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZhdWx0SHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZhdWx0SHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIERlZmF1bHRMYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmF1bHQnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbkh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBSZXRyeUxhbmVzKSB7XG4gICAgICByZXR1cm4gJ1JldHJ5JztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnU2VsZWN0aXZlSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElkbGVIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lkbGVIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSWRsZUxhbmUpIHtcbiAgICAgIHJldHVybiAnSWRsZSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG4gICAgfVxuICB9XG59XG52YXIgTm9UaW1lc3RhbXAgPSAtMTtcbnZhciBuZXh0VHJhbnNpdGlvbkxhbmUgPSBUcmFuc2l0aW9uTGFuZTE7XG52YXIgbmV4dFJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIHN3aXRjaCAoZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykpIHtcbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgICAgcmV0dXJuIFN5bmNMYW5lO1xuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgcmV0dXJuIERlZmF1bHRMYW5lO1xuXG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNjpcbiAgICAgIHJldHVybiBsYW5lcyAmIFRyYW5zaXRpb25MYW5lcztcblxuICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICBjYXNlIFJldHJ5TGFuZTI6XG4gICAgY2FzZSBSZXRyeUxhbmUzOlxuICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICBjYXNlIFJldHJ5TGFuZTU6XG4gICAgICByZXR1cm4gbGFuZXMgJiBSZXRyeUxhbmVzO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElkbGVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIHJldHVybiBJZGxlTGFuZTtcblxuICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcbiAgICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgICAgIHJldHVybiBsYW5lcztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybiBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIG5leHRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7IC8vIERvIG5vdCB3b3JrIG9uIGFueSBpZGxlIHdvcmsgdW50aWwgYWxsIHRoZSBub24taWRsZSB3b3JrIGhhcyBmaW5pc2hlZCxcbiAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG5cbiAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiBOb25JZGxlTGFuZXM7XG5cbiAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbm9uSWRsZVVuYmxvY2tlZExhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgIGlmIChub25JZGxlVW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgIGlmIChub25JZGxlUGluZ2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbiAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICBpZiAodW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cblxuICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4gIC8vIGJvdGhlciB3YWl0aW5nIHVudGlsIHRoZSByb290IGlzIGNvbXBsZXRlLlxuICAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICB2YXIgbmV4dExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKG5leHRMYW5lcyk7XG4gICAgdmFyIHdpcExhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHdpcExhbmVzKTtcblxuICAgIGlmICggLy8gVGVzdHMgd2hldGhlciB0aGUgbmV4dCBsYW5lIGlzIGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5IHRoYW4gdGhlIHdpcFxuICAgIC8vIG9uZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXRzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICAgIG5leHRMYW5lID49IHdpcExhbmUgfHwgLy8gRGVmYXVsdCBwcmlvcml0eSB1cGRhdGVzIHNob3VsZCBub3QgaW50ZXJydXB0IHRyYW5zaXRpb24gdXBkYXRlcy4gVGhlXG4gICAgLy8gb25seSBkaWZmZXJlbmNlIGJldHdlZW4gZGVmYXVsdCB1cGRhdGVzIGFuZCB0cmFuc2l0aW9uIHVwZGF0ZXMgaXMgdGhhdFxuICAgIC8vIGRlZmF1bHQgdXBkYXRlcyBkbyBub3Qgc3VwcG9ydCByZWZyZXNoIHRyYW5zaXRpb25zLlxuICAgIG5leHRMYW5lID09PSBEZWZhdWx0TGFuZSAmJiAod2lwTGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICAgIC8vIEtlZXAgd29ya2luZyBvbiB0aGUgZXhpc3RpbmcgaW4tcHJvZ3Jlc3MgdHJlZS4gRG8gbm90IGludGVycnVwdC5cbiAgICAgIHJldHVybiB3aXBMYW5lcztcbiAgICB9XG4gIH1cblxuICBpZiAoKG5leHRMYW5lcyAmIElucHV0Q29udGludW91c0xhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gV2hlbiB1cGRhdGVzIGFyZSBzeW5jIGJ5IGRlZmF1bHQsIHdlIGVudGFuZ2xlIGNvbnRpbnVvdXMgcHJpb3JpdHkgdXBkYXRlc1xuICAgIC8vIGFuZCBkZWZhdWx0IHVwZGF0ZXMsIHNvIHRoZXkgcmVuZGVyIGluIHRoZSBzYW1lIGJhdGNoLiBUaGUgb25seSByZWFzb25cbiAgICAvLyB0aGV5IHVzZSBzZXBhcmF0ZSBsYW5lcyBpcyBiZWNhdXNlIGNvbnRpbnVvdXMgdXBkYXRlcyBzaG91bGQgaW50ZXJydXB0XG4gICAgLy8gdHJhbnNpdGlvbnMsIGJ1dCBkZWZhdWx0IHVwZGF0ZXMgc2hvdWxkIG5vdC5cbiAgICBuZXh0TGFuZXMgfD0gcGVuZGluZ0xhbmVzICYgRGVmYXVsdExhbmU7XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcy4gVGhlIGNvdW50ZXItYXJndW1lbnQgaXMgdGhhdCB0aGUgcGFydGlhbCB3b3JrXG4gIC8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gIC8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG4gIC8vIHRpbWUgaXQgdGFrZXMgdG8gc2hvdyB0aGUgZmluYWwgc3RhdGUsIHdoaWNoIGlzIHdoYXQgdGhleSBhcmUgYWN0dWFsbHlcbiAgLy8gd2FpdGluZyBmb3IuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LCBsaWtlXG4gIC8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4gIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG4gIHZhciBlbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG5cbiAgaWYgKGVudGFuZ2xlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gICAgdmFyIGxhbmVzID0gbmV4dExhbmVzICYgZW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIG5leHRMYW5lcyB8PSBlbnRhbmdsZW1lbnRzW2luZGV4XTtcbiAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV2ZW50VGltZSA9IGV2ZW50VGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV2ZW50VGltZSA+IG1vc3RSZWNlbnRFdmVudFRpbWUpIHtcbiAgICAgIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBldmVudFRpbWU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICByZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIHN3aXRjaCAobGFuZSkge1xuICAgIGNhc2UgU3luY0xhbmU6XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgc2V0IHRvIHRoZSBjb3JyZXNwb25kaW5nIGNvbnN0YW50IGFzIGluIFNjaGVkdWxlci5qcy5cbiAgICAgIC8vIFdoZW4gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZ1xuICAgICAgLy8gdGhlcmUncyBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCdzIGJlaW5nIHN0YXJ2ZWQgYnkgYSBzZXJpZXMgb2ZcbiAgICAgIC8vIHN5bmNocm9ub3VzIHVwZGF0ZXMuIElmIHRoYXQgdGhlb3J5IGlzIGNvcnJlY3QsIHRoZSBwcm9wZXIgc29sdXRpb24gaXNcbiAgICAgIC8vIHRvIGZpeCB0aGUgc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0XG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzIGFyZSBhbiBpbXBvcnRhbnQgc2FmZWd1YXJkIHdoZW4gc3RhcnZhdGlvblxuICAgICAgLy8gZG9lcyBoYXBwZW4uXG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyAyNTA7XG5cbiAgICBjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTY6XG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgIGNhc2UgUmV0cnlMYW5lNTpcbiAgICAgIC8vIFRPRE86IFJldHJpZXMgc2hvdWxkIGJlIGFsbG93ZWQgdG8gZXhwaXJlIGlmIHRoZXkgYXJlIENQVSBib3VuZCBmb3JcbiAgICAgIC8vIHRvbyBsb25nLCBidXQgd2hlbiBJIG1hZGUgdGhpcyBjaGFuZ2UgaXQgY2F1c2VkIGEgc3Bpa2UgaW4gYnJvd3NlclxuICAgICAgLy8gY3Jhc2hlcy4gVGhlcmUgbXVzdCBiZSBzb21lIG90aGVyIHVuZGVybHlpbmcgYnVnOyBub3Qgc3VwZXIgdXJnZW50IGJ1dFxuICAgICAgLy8gaWRlYWxseSBzaG91bGQgZmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gVW5mb3J0dW5hdGVseSB3ZSBkb24ndCBoYXZlXG4gICAgICAvLyBhIHJlcHJvIGZvciB0aGUgY3Jhc2hlcywgb25seSBkZXRlY3RlZCB2aWEgcHJvZHVjdGlvbiBtZXRyaWNzLlxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICBjYXNlIE9mZnNjcmVlbkxhbmU6XG4gICAgICAvLyBBbnl0aGluZyBpZGxlIHByaW9yaXR5IG9yIGxvd2VyIHNob3VsZCBuZXZlciBleHBpcmUuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3JpbmdcbiAgLy8gdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZSBvbiB0aGUgcm9vdC4gVGhlbiB1c2UgdGhhdCB0byBxdWlja2x5IGJhaWwgb3V0XG4gIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbiAgLy8gZXhwaXJhdGlvbiB0aW1lLiBJZiBzbywgd2UnbGwgYXNzdW1lIHRoZSB1cGRhdGUgaXMgYmVpbmcgc3RhcnZlZCBhbmQgbWFya1xuICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuICAgICAgLy8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3JcbiAgICAgIC8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgaWYgKChsYW5lICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzIHx8IChsYW5lICYgcGluZ2VkTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIC8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufSAvLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuLy8gYXJlIHN1c3BlbmRlZC5cblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzKHJvb3QpIHtcbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHJvb3QucGVuZGluZ0xhbmVzKTtcbn1cbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNTeW5jTGFuZShsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgU3luY0xhbmUpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzKGxhbmVzKSB7XG4gIHZhciBVcmdlbnRMYW5lcyA9IFN5bmNMYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRMYW5lO1xuICByZXR1cm4gKGxhbmVzICYgVXJnZW50TGFuZXMpID09PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFRyYW5zaXRpb25MYW5lcykgPT09IGxhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgbGFuZXMpIHtcblxuICB2YXIgU3luY0RlZmF1bHRMYW5lcyA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUgfCBJbnB1dENvbnRpbnVvdXNMYW5lIHwgRGVmYXVsdEh5ZHJhdGlvbkxhbmUgfCBEZWZhdWx0TGFuZTtcbiAgcmV0dXJuIChsYW5lcyAmIFN5bmNEZWZhdWx0TGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LCBsYW5lcykge1xuICAvLyBUaGlzIGlzIGEgc2VwYXJhdGUgY2hlY2sgZnJvbSBpbmNsdWRlc0Jsb2NraW5nTGFuZSBiZWNhdXNlIGEgbGFuZSBjYW5cbiAgLy8gZXhwaXJlIGFmdGVyIGEgcmVuZGVyIGhhcyBhbHJlYWR5IHN0YXJ0ZWQuXG4gIHJldHVybiAobGFuZXMgJiByb290LmV4cGlyZWRMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpc1RyYW5zaXRpb25MYW5lKGxhbmUpIHtcbiAgcmV0dXJuIChsYW5lICYgVHJhbnNpdGlvbkxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkge1xuICAvLyBDeWNsZSB0aHJvdWdoIHRoZSBsYW5lcywgYXNzaWduaW5nIGVhY2ggbmV3IHRyYW5zaXRpb24gdG8gdGhlIG5leHQgbGFuZS5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBtZWFucyBldmVyeSB0cmFuc2l0aW9uIGdldHMgaXRzIG93biBsYW5lLCB1bnRpbCB3ZVxuICAvLyBydW4gb3V0IG9mIGxhbmVzIGFuZCBjeWNsZSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcuXG4gIHZhciBsYW5lID0gbmV4dFRyYW5zaXRpb25MYW5lO1xuICBuZXh0VHJhbnNpdGlvbkxhbmUgPDw9IDE7XG5cbiAgaWYgKChuZXh0VHJhbnNpdGlvbkxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgbmV4dFRyYW5zaXRpb25MYW5lID0gVHJhbnNpdGlvbkxhbmUxO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBjbGFpbU5leHRSZXRyeUxhbmUoKSB7XG4gIHZhciBsYW5lID0gbmV4dFJldHJ5TGFuZTtcbiAgbmV4dFJldHJ5TGFuZSA8PD0gMTtcblxuICBpZiAoKG5leHRSZXRyeUxhbmUgJiBSZXRyeUxhbmVzKSA9PT0gTm9MYW5lcykge1xuICAgIG5leHRSZXRyeUxhbmUgPSBSZXRyeUxhbmUxO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIHJldHVybiBsYW5lcyAmIC1sYW5lcztcbn1cbmZ1bmN0aW9uIHBpY2tBcmJpdHJhcnlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBnZXRzIGlubGluZWQuIE9ubHkgZXhpc3RzIHNvIHRvIGNvbW11bmljYXRlIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggYml0IGlzIHNlbGVjdGVkOyB5b3UgY2FuIHBpY2sgYW55IGJpdCB3aXRob3V0XG4gIC8vIGFmZmVjdGluZyB0aGUgYWxnb3JpdGhtcyB3aGVyZSBpdHMgdXNlZC4gSGVyZSBJJ20gdXNpbmdcbiAgLy8gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZSBiZWNhdXNlIGl0IHJlcXVpcmVzIHRoZSBmZXdlc3Qgb3BlcmF0aW9ucy5cbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKSB7XG4gIHJldHVybiAzMSAtIGNsejMyKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbGFuZVRvSW5kZXgobGFuZSkge1xuICByZXR1cm4gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lKTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNTb21lTGFuZShhLCBiKSB7XG4gIHJldHVybiAoYSAmIGIpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNTdWJzZXRPZkxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiAoc2V0ICYgc3Vic2V0KSA9PT0gc3Vic2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VMYW5lcyhhLCBiKSB7XG4gIHJldHVybiBhIHwgYjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiBzZXQgJiB+c3Vic2V0O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0TGFuZXMoYSwgYikge1xuICByZXR1cm4gYSAmIGI7XG59IC8vIFNlZW1zIHJlZHVuZGFudCwgYnV0IGl0IGNoYW5nZXMgdGhlIHR5cGUgZnJvbSBhIHNpbmdsZSBsYW5lICh1c2VkIGZvclxuLy8gdXBkYXRlcykgdG8gYSBncm91cCBvZiBsYW5lcyAodXNlZCBmb3IgZmx1c2hpbmcgd29yaykuXG5cbmZ1bmN0aW9uIGxhbmVUb0xhbmVzKGxhbmUpIHtcbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBoaWdoZXJQcmlvcml0eUxhbmUoYSwgYikge1xuICAvLyBUaGlzIHdvcmtzIGJlY2F1c2UgdGhlIGJpdCByYW5nZXMgZGVjcmVhc2UgaW4gcHJpb3JpdHkgYXMgeW91IGdvIGxlZnQuXG4gIHJldHVybiBhICE9PSBOb0xhbmUgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxhbmVNYXAoaW5pdGlhbCkge1xuICAvLyBJbnRlbnRpb25hbGx5IHB1c2hpbmcgb25lIGJ5IG9uZS5cbiAgLy8gaHR0cHM6Ly92OC5kZXYvYmxvZy9lbGVtZW50cy1raW5kcyNhdm9pZC1jcmVhdGluZy1ob2xlc1xuICB2YXIgbGFuZU1hcCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVG90YWxMYW5lczsgaSsrKSB7XG4gICAgbGFuZU1hcC5wdXNoKGluaXRpYWwpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmVNYXA7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgdXBkYXRlTGFuZSwgZXZlbnRUaW1lKSB7XG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IHVwZGF0ZUxhbmU7IC8vIElmIHRoZXJlIGFyZSBhbnkgc3VzcGVuZGVkIHRyYW5zaXRpb25zLCBpdCdzIHBvc3NpYmxlIHRoaXMgbmV3IHVwZGF0ZVxuICAvLyBjb3VsZCB1bmJsb2NrIHRoZW0uIENsZWFyIHRoZSBzdXNwZW5kZWQgbGFuZXMgc28gdGhhdCB3ZSBjYW4gdHJ5IHJlbmRlcmluZ1xuICAvLyB0aGVtIGFnYWluLlxuICAvL1xuICAvLyBUT0RPOiBXZSByZWFsbHkgb25seSBuZWVkIHRvIHVuc3VzcGVuZCBvbmx5IGxhbmVzIHRoYXQgYXJlIGluIHRoZVxuICAvLyBgc3VidHJlZUxhbmVzYCBvZiB0aGUgdXBkYXRlZCBmaWJlciwgb3IgdGhlIHVwZGF0ZSBsYW5lcyBvZiB0aGUgcmV0dXJuXG4gIC8vIHBhdGguIFRoaXMgd291bGQgZXhjbHVkZSBzdXNwZW5kZWQgdXBkYXRlcyBpbiBhbiB1bnJlbGF0ZWQgc2libGluZyB0cmVlLFxuICAvLyBzaW5jZSB0aGVyZSdzIG5vIHdheSBmb3IgdGhpcyB1cGRhdGUgdG8gdW5ibG9jayBpdC5cbiAgLy9cbiAgLy8gV2UgZG9uJ3QgZG8gdGhpcyBpZiB0aGUgaW5jb21pbmcgdXBkYXRlIGlzIGlkbGUsIGJlY2F1c2Ugd2UgbmV2ZXIgcHJvY2Vzc1xuICAvLyBpZGxlIHVwZGF0ZXMgdW50aWwgYWZ0ZXIgYWxsIHRoZSByZWd1bGFyIHVwZGF0ZXMgaGF2ZSBmaW5pc2hlZDsgdGhlcmUncyBub1xuICAvLyB3YXkgaXQgY291bGQgdW5ibG9jayBhIHRyYW5zaXRpb24uXG5cbiAgaWYgKHVwZGF0ZUxhbmUgIT09IElkbGVMYW5lKSB7XG4gICAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcm9vdC5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgodXBkYXRlTGFuZSk7IC8vIFdlIGNhbiBhbHdheXMgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHRpbWVzdGFtcCBiZWNhdXNlIHdlIHByZWZlciB0aGUgbW9zdFxuICAvLyByZWNlbnQgZXZlbnQsIGFuZCB3ZSBhc3N1bWUgdGltZSBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG5cbiAgZXZlbnRUaW1lc1tpbmRleF0gPSBldmVudFRpbWU7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcykge1xuICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lczsgLy8gVGhlIHN1c3BlbmRlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIENQVS1ib3VuZC4gQ2xlYXIgdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cblxuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gIHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcywgZXZlbnRUaW1lKSB7XG4gIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcykge1xuICB2YXIgbm9Mb25nZXJQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIH5yZW1haW5pbmdMYW5lcztcbiAgcm9vdC5wZW5kaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lczsgLy8gTGV0J3MgdHJ5IGV2ZXJ5dGhpbmcgYWdhaW5cblxuICByb290LnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHJvb3QuZXhwaXJlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290Lm11dGFibGVSZWFkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBDbGVhciB0aGUgbGFuZXMgdGhhdCBubyBsb25nZXIgaGF2ZSBwZW5kaW5nIHdvcmtcblxuICB2YXIgbGFuZXMgPSBub0xvbmdlclBlbmRpbmdMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdID0gTm9MYW5lcztcbiAgICBldmVudFRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgLy8gSW4gYWRkaXRpb24gdG8gZW50YW5nbGluZyBlYWNoIG9mIHRoZSBnaXZlbiBsYW5lcyB3aXRoIGVhY2ggb3RoZXIsIHdlIGFsc29cbiAgLy8gaGF2ZSB0byBjb25zaWRlciBfdHJhbnNpdGl2ZV8gZW50YW5nbGVtZW50cy4gRm9yIGVhY2ggbGFuZSB0aGF0IGlzIGFscmVhZHlcbiAgLy8gZW50YW5nbGVkIHdpdGggKmFueSogb2YgdGhlIGdpdmVuIGxhbmVzLCB0aGF0IGxhbmUgaXMgbm93IHRyYW5zaXRpdmVseVxuICAvLyBlbnRhbmdsZWQgd2l0aCAqYWxsKiB0aGUgZ2l2ZW4gbGFuZXMuXG4gIC8vXG4gIC8vIFRyYW5zbGF0ZWQ6IElmIEMgaXMgZW50YW5nbGVkIHdpdGggQSwgdGhlbiBlbnRhbmdsaW5nIEEgd2l0aCBCIGFsc29cbiAgLy8gZW50YW5nbGVzIEMgd2l0aCBCLlxuICAvL1xuICAvLyBJZiB0aGlzIGlzIGhhcmQgdG8gZ3Jhc3AsIGl0IG1pZ2h0IGhlbHAgdG8gaW50ZW50aW9uYWxseSBicmVhayB0aGlzXG4gIC8vIGZ1bmN0aW9uIGFuZCBsb29rIGF0IHRoZSB0ZXN0cyB0aGF0IGZhaWwgaW4gUmVhY3RUcmFuc2l0aW9uLXRlc3QuanMuIFRyeVxuICAvLyBjb21tZW50aW5nIG91dCBvbmUgb2YgdGhlIGNvbmRpdGlvbnMgYmVsb3cuXG4gIHZhciByb290RW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGxhbmVzID0gcm9vdEVudGFuZ2xlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcykge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcblxuICAgIGlmICggLy8gSXMgdGhpcyBvbmUgb2YgdGhlIG5ld2x5IGVudGFuZ2xlZCBsYW5lcz9cbiAgICBsYW5lICYgZW50YW5nbGVkTGFuZXMgfCAvLyBJcyB0aGlzIGxhbmUgdHJhbnNpdGl2ZWx5IGVudGFuZ2xlZCB3aXRoIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gJiBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgZW50YW5nbGVtZW50c1tpbmRleF0gfD0gZW50YW5nbGVkTGFuZXM7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb24ocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHJlbmRlckxhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHJlbmRlckxhbmVzKTtcbiAgdmFyIGxhbmU7XG5cbiAgc3dpdGNoIChyZW5kZXJMYW5lKSB7XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lOlxuICAgICAgbGFuZSA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgICBsYW5lID0gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNjpcbiAgICBjYXNlIFJldHJ5TGFuZTE6XG4gICAgY2FzZSBSZXRyeUxhbmUyOlxuICAgIGNhc2UgUmV0cnlMYW5lMzpcbiAgICBjYXNlIFJldHJ5TGFuZTQ6XG4gICAgY2FzZSBSZXRyeUxhbmU1OlxuICAgICAgbGFuZSA9IFRyYW5zaXRpb25IeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIElkbGVMYW5lOlxuICAgICAgbGFuZSA9IElkbGVIeWRyYXRpb25MYW5lO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIGFscmVhZHkgZWl0aGVyIGEgaHlkcmF0aW9uIGxhbmUsIG9yIHNob3VsZG4ndFxuICAgICAgLy8gYmUgcmV0cmllZCBhdCBhIGh5ZHJhdGlvbiBsYW5lLlxuICAgICAgbGFuZSA9IE5vTGFuZTtcbiAgICAgIGJyZWFrO1xuICB9IC8vIENoZWNrIGlmIHRoZSBsYW5lIHdlIGNob3NlIGlzIHN1c3BlbmRlZC4gSWYgc28sIHRoYXQgaW5kaWNhdGVzIHRoYXQgd2VcbiAgLy8gYWxyZWFkeSBhdHRlbXB0ZWQgYW5kIGZhaWxlZCB0byBoeWRyYXRlIGF0IHRoYXQgbGV2ZWwuIEFsc28gY2hlY2sgaWYgd2UncmVcbiAgLy8gYWxyZWFkeSByZW5kZXJpbmcgdGhhdCBsYW5lLCB3aGljaCBpcyByYXJlIGJ1dCBjb3VsZCBoYXBwZW4uXG5cblxuICBpZiAoKGxhbmUgJiAocm9vdC5zdXNwZW5kZWRMYW5lcyB8IHJlbmRlckxhbmVzKSkgIT09IE5vTGFuZSkge1xuICAgIC8vIEdpdmUgdXAgdHJ5aW5nIHRvIGh5ZHJhdGUgYW5kIGZhbGwgYmFjayB0byBjbGllbnQgcmVuZGVyLlxuICAgIHJldHVybiBOb0xhbmU7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZXMpIHtcblxuICBpZiAoIWlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXA7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIHVwZGF0ZXJzID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG4gICAgdXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKSB7XG5cbiAgaWYgKCFpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO1xuICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgdXBkYXRlcnMgPSBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTtcblxuICAgIGlmICh1cGRhdGVycy5zaXplID4gMCkge1xuICAgICAgdXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsIHx8ICFtZW1vaXplZFVwZGF0ZXJzLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5hZGQoZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25zRm9yTGFuZXMocm9vdCwgbGFuZXMpIHtcbiAge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBTeW5jTGFuZTtcbnZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmU7XG52YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0TGFuZTtcbnZhciBJZGxlRXZlbnRQcmlvcml0eSA9IElkbGVMYW5lO1xudmFyIGN1cnJlbnRVcGRhdGVQcmlvcml0eSA9IE5vTGFuZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShuZXdQcmlvcml0eSkge1xuICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBuZXdQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSwgZm4pIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBjdXJyZW50VXBkYXRlUHJpb3JpdHk7XG5cbiAgdHJ5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VXBkYXRlUHJpb3JpdHkgPSBwcmV2aW91c1ByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBoaWdoZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IDAgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGxvd2VyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSAwIHx8IGEgPiBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBpc0hpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYjtcbn1cbmZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG4gIHZhciBsYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7XG5cbiAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5LCBsYW5lKSkge1xuICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoIWlzSGlnaGVyRXZlbnRQcmlvcml0eShDb250aW51b3VzRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcbiAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoaW5jbHVkZXNOb25JZGxlV29yayhsYW5lKSkge1xuICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIHJldHVybiBJZGxlRXZlbnRQcmlvcml0eTtcbn1cblxuLy8gVGhpcyBpcyBpbXBvcnRlZCBieSB0aGUgZXZlbnQgcmVwbGF5aW5nIGltcGxlbWVudGF0aW9uIGluIFJlYWN0IERPTS4gSXQnc1xuLy8gaW4gYSBzZXBhcmF0ZSBmaWxlIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSByZW5kZXJlciBhbmRcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gaXNSb290RGVoeWRyYXRlZChyb290KSB7XG4gIHZhciBjdXJyZW50U3RhdGUgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG59XG5cbnZhciBfYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uO1xuXG5mdW5jdGlvbiBzZXRBdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZm4pIHtcbiAgX2F0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiA9IGZuO1xufVxuZnVuY3Rpb24gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uKGZpYmVyKSB7XG4gIF9hdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpO1xufVxudmFyIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uO1xuZnVuY3Rpb24gc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZm4pIHtcbiAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24gPSBmbjtcbn1cbnZhciBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHk7XG5mdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZm4pIHtcbiAgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gZm47XG59XG52YXIgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDE7XG5mdW5jdGlvbiBzZXRHZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoZm4pIHtcbiAgZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDEgPSBmbjtcbn1cbnZhciBhdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eTtcbmZ1bmN0aW9uIHNldEF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KGZuKSB7XG4gIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5ID0gZm47XG59IC8vIFRPRE86IFVwZ3JhZGUgdGhpcyBkZWZpbml0aW9uIG9uY2Ugd2UncmUgb24gYSBuZXdlciB2ZXJzaW9uIG9mIEZsb3cgdGhhdFxuLy8gaGFzIHRoaXMgZGVmaW5pdGlvbiBidWlsdC1pbi5cblxudmFyIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSBmYWxzZTsgLy8gVGhlIHF1ZXVlIG9mIGRpc2NyZXRlIGV2ZW50cyB0byBiZSByZXBsYXllZC5cblxudmFyIHF1ZXVlZERpc2NyZXRlRXZlbnRzID0gW107IC8vIEluZGljYXRlcyBpZiBhbnkgY29udGludW91cyBldmVudCB0YXJnZXRzIGFyZSBub24tbnVsbCBmb3IgZWFybHkgYmFpbG91dC5cbi8vIGlmIHRoZSBsYXN0IHRhcmdldCB3YXMgZGVoeWRyYXRlZC5cblxudmFyIHF1ZXVlZEZvY3VzID0gbnVsbDtcbnZhciBxdWV1ZWREcmFnID0gbnVsbDtcbnZhciBxdWV1ZWRNb3VzZSA9IG51bGw7IC8vIEZvciBwb2ludGVyIGV2ZW50cyB0aGVyZSBjYW4gYmUgb25lIGxhdGVzdCBldmVudCBwZXIgcG9pbnRlcklkLlxuXG52YXIgcXVldWVkUG9pbnRlcnMgPSBuZXcgTWFwKCk7XG52YXIgcXVldWVkUG9pbnRlckNhcHR1cmVzID0gbmV3IE1hcCgpOyAvLyBXZSBjb3VsZCBjb25zaWRlciByZXBsYXlpbmcgc2VsZWN0aW9uY2hhbmdlIGFuZCB0b3VjaG1vdmVzIHRvby5cblxudmFyIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cyA9IFtdO1xudmFyIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cyA9IFsnbW91c2Vkb3duJywgJ21vdXNldXAnLCAndG91Y2hjYW5jZWwnLCAndG91Y2hlbmQnLCAndG91Y2hzdGFydCcsICdhdXhjbGljaycsICdkYmxjbGljaycsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJ1cCcsICdkcmFnZW5kJywgJ2RyYWdzdGFydCcsICdkcm9wJywgJ2NvbXBvc2l0aW9uZW5kJywgJ2NvbXBvc2l0aW9uc3RhcnQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdpbnB1dCcsICd0ZXh0SW5wdXQnLCAvLyBJbnRlbnRpb25hbGx5IGNhbWVsQ2FzZVxuJ2NvcHknLCAnY3V0JywgJ3Bhc3RlJywgJ2NsaWNrJywgJ2NoYW5nZScsICdjb250ZXh0bWVudScsICdyZXNldCcsICdzdWJtaXQnXTtcbmZ1bmN0aW9uIGlzRGlzY3JldGVFdmVudFRoYXRSZXF1aXJlc0h5ZHJhdGlvbihldmVudFR5cGUpIHtcbiAgcmV0dXJuIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgYmxvY2tlZE9uOiBibG9ja2VkT24sXG4gICAgZG9tRXZlbnROYW1lOiBkb21FdmVudE5hbWUsXG4gICAgZXZlbnRTeXN0ZW1GbGFnczogZXZlbnRTeXN0ZW1GbGFncyxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0Q29udGFpbmVyczogW3RhcmdldENvbnRhaW5lcl1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdsZWF2ZSc6XG4gICAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgIGNhc2UgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZGVsZXRlKF9wb2ludGVySWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KGV4aXN0aW5nUXVldWVkRXZlbnQsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChleGlzdGluZ1F1ZXVlZEV2ZW50ID09PSBudWxsIHx8IGV4aXN0aW5nUXVldWVkRXZlbnQubmF0aXZlRXZlbnQgIT09IG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIHZhciBfZmliZXIyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIHRhcmdldC5cbiAgICAgICAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlZEV2ZW50O1xuICB9IC8vIElmIHdlIGhhdmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBleGFjdCBldmVudCwgdGhlbiBpdCdzIGJlY2F1c2VcbiAgLy8gdGhlIGRpZmZlcmVudCBldmVudCBzeXN0ZW1zIGhhdmUgZGlmZmVyZW50IERPTSBldmVudCBsaXN0ZW5lcnMuXG4gIC8vIFdlIGNhbiBhY2N1bXVsYXRlIHRoZSBmbGFncywgYW5kIHRoZSB0YXJnZXRDb250YWluZXJzLCBhbmRcbiAgLy8gc3RvcmUgYSBzaW5nbGUgZXZlbnQgdG8gYmUgcmVwbGF5ZWQuXG5cblxuICBleGlzdGluZ1F1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MgfD0gZXZlbnRTeXN0ZW1GbGFncztcbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgaWYgKHRhcmdldENvbnRhaW5lciAhPT0gbnVsbCAmJiB0YXJnZXRDb250YWluZXJzLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRDb250YWluZXJzLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBleGlzdGluZ1F1ZXVlZEV2ZW50O1xufVxuXG5mdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIFRoZXNlIHNldCByZWxhdGVkVGFyZ2V0IHRvIG51bGwgYmVjYXVzZSB0aGUgcmVwbGF5ZWQgZXZlbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIHdlXG4gIC8vIG1vdmVkIGZyb20gb3V0c2lkZSB0aGUgd2luZG93IChubyB0YXJnZXQpIG9udG8gdGhlIHRhcmdldCBvbmNlIGl0IGh5ZHJhdGVzLlxuICAvLyBJbnN0ZWFkIG9mIG11dGF0aW5nIHdlIGNvdWxkIGNsb25lIHRoZSBldmVudC5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZvY3VzRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkRm9jdXMgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZEZvY3VzLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBmb2N1c0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAge1xuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHF1ZXVlZERyYWcgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZERyYWcsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIGRyYWdFdmVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkTW91c2UgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZE1vdXNlLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBtb3VzZUV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgICB7XG4gICAgICAgIHZhciBwb2ludGVyRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICAgIHF1ZXVlZFBvaW50ZXJzLnNldChwb2ludGVySWQsIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCwgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BvaW50ZXJFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgX3BvaW50ZXJJZDIgPSBfcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChfcG9pbnRlcklkMiwgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZ2V0KF9wb2ludGVySWQyKSB8fCBudWxsLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBfcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBDaGVjayBpZiB0aGlzIHRhcmdldCBpcyB1bmJsb2NrZWQuIFJldHVybnMgdHJ1ZSBpZiBpdCdzIHVuYmxvY2tlZC5cblxuZnVuY3Rpb24gYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCkge1xuICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIHNoYXJlcyBhIGxvdCBvZiBsb2dpYyB3aXRoIGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQuXG4gIC8vIFRyeSB0byB1bmlmeSB0aGVtLiBJdCdzIGEgYml0IHRyaWNreSBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIHR3byByZXR1cm5cbiAgLy8gdmFsdWVzLlxuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHF1ZXVlZFRhcmdldC50YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcblxuICAgICAgaWYgKHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmxvY2tlZCBvbiBoeWRyYXRpbmcgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICAvLyBJbmNyZWFzZSBpdHMgcHJpb3JpdHkuXG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGluc3RhbmNlO1xuICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KHF1ZXVlZFRhcmdldC5wcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNSb290RGVoeWRyYXRlZChyb290KSkge1xuICAgICAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBnZXRDb250YWluZXJGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpOyAvLyBXZSBkb24ndCBjdXJyZW50bHkgaGF2ZSBhIHdheSB0byBpbmNyZWFzZSB0aGUgcHJpb3JpdHkgb2ZcbiAgICAgICAgICAvLyBhIHJvb3Qgb3RoZXIgdGhhbiBzeW5jLlxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlRXhwbGljaXRIeWRyYXRpb25UYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFRPRE86IFRoaXMgd2lsbCByZWFkIHRoZSBwcmlvcml0eSBpZiBpdCdzIGRpc3BhdGNoZWQgYnkgdGhlIFJlYWN0XG4gIC8vIGV2ZW50IHN5c3RlbSBidXQgbm90IG5hdGl2ZSBldmVudHMuIFNob3VsZCByZWFkIHdpbmRvdy5ldmVudC50eXBlLCBsaWtlXG4gIC8vIHdlIGRvIGZvciB1cGRhdGVzIChnZXRDdXJyZW50RXZlbnRQcmlvcml0eSkuXG4gIHZhciB1cGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSQxKCk7XG4gIHZhciBxdWV1ZWRUYXJnZXQgPSB7XG4gICAgYmxvY2tlZE9uOiBudWxsLFxuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHByaW9yaXR5OiB1cGRhdGVQcmlvcml0eVxuICB9O1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBTdG9wIG9uY2Ugd2UgaGl0IHRoZSBmaXJzdCB0YXJnZXQgd2l0aCBsb3dlciBwcmlvcml0eSB0aGFuXG4gICAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkodXBkYXRlUHJpb3JpdHksIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tpXS5wcmlvcml0eSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zcGxpY2UoaSwgMCwgcXVldWVkVGFyZ2V0KTtcblxuICBpZiAoaSA9PT0gMCkge1xuICAgIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpIHtcbiAgaWYgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0YXJnZXRDb250YWluZXJzID0gcXVldWVkRXZlbnQudGFyZ2V0Q29udGFpbmVycztcblxuICB3aGlsZSAodGFyZ2V0Q29udGFpbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhcmdldENvbnRhaW5lciA9IHRhcmdldENvbnRhaW5lcnNbMF07XG4gICAgdmFyIG5leHRCbG9ja2VkT24gPSBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KHF1ZXVlZEV2ZW50LmRvbUV2ZW50TmFtZSwgcXVldWVkRXZlbnQuZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBxdWV1ZWRFdmVudC5uYXRpdmVFdmVudCk7XG5cbiAgICBpZiAobmV4dEJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB2YXIgbmF0aXZlRXZlbnQgPSBxdWV1ZWRFdmVudC5uYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIG5hdGl2ZUV2ZW50Q2xvbmUgPSBuZXcgbmF0aXZlRXZlbnQuY29uc3RydWN0b3IobmF0aXZlRXZlbnQudHlwZSwgbmF0aXZlRXZlbnQpO1xuICAgICAgICBzZXRSZXBsYXlpbmdFdmVudChuYXRpdmVFdmVudENsb25lKTtcbiAgICAgICAgbmF0aXZlRXZlbnQudGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnRDbG9uZSk7XG4gICAgICAgIHJlc2V0UmVwbGF5aW5nRXZlbnQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UncmUgc3RpbGwgYmxvY2tlZC4gVHJ5IGFnYWluIGxhdGVyLlxuICAgICAgdmFyIF9maWJlcjMgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKG5leHRCbG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyMyAhPT0gbnVsbCkge1xuICAgICAgICBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihfZmliZXIzKTtcbiAgICAgIH1cblxuICAgICAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbmV4dEJsb2NrZWRPbjtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFRoaXMgdGFyZ2V0IGNvbnRhaW5lciB3YXMgc3VjY2Vzc2Z1bGx5IGRpc3BhdGNoZWQuIFRyeSB0aGUgbmV4dC5cblxuXG4gICAgdGFyZ2V0Q29udGFpbmVycy5zaGlmdCgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcChxdWV1ZWRFdmVudCwga2V5LCBtYXApIHtcbiAgaWYgKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpKSB7XG4gICAgbWFwLmRlbGV0ZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxheVVuYmxvY2tlZEV2ZW50cygpIHtcbiAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9IGZhbHNlO1xuXG5cbiAgaWYgKHF1ZXVlZEZvY3VzICE9PSBudWxsICYmIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRm9jdXMpKSB7XG4gICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICB9XG5cbiAgaWYgKHF1ZXVlZERyYWcgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWREcmFnKSkge1xuICAgIHF1ZXVlZERyYWcgPSBudWxsO1xuICB9XG5cbiAgaWYgKHF1ZXVlZE1vdXNlICE9PSBudWxsICYmIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkTW91c2UpKSB7XG4gICAgcXVldWVkTW91c2UgPSBudWxsO1xuICB9XG5cbiAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO1xuICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXApO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsIHVuYmxvY2tlZCkge1xuICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQpIHtcbiAgICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPSBudWxsO1xuXG4gICAgaWYgKCFoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0KSB7XG4gICAgICBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gdHJ1ZTsgLy8gU2NoZWR1bGUgYSBjYWxsYmFjayB0byBhdHRlbXB0IHJlcGxheWluZyBhcyBtYW55IGV2ZW50cyBhcyBhcmVcbiAgICAgIC8vIG5vdyB1bmJsb2NrZWQuIFRoaXMgZmlyc3QgbWlnaHQgbm90IGFjdHVhbGx5IGJlIHVuYmxvY2tlZCB5ZXQuXG4gICAgICAvLyBXZSBjb3VsZCBjaGVjayBpdCBlYXJseSB0byBhdm9pZCBzY2hlZHVsaW5nIGFuIHVubmVjZXNzYXJ5IGNhbGxiYWNrLlxuXG4gICAgICBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksIHJlcGxheVVuYmxvY2tlZEV2ZW50cyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5SWZCbG9ja2VkT24odW5ibG9ja2VkKSB7XG4gIC8vIE1hcmsgYW55dGhpbmcgdGhhdCB3YXMgYmxvY2tlZCBvbiB0aGlzIGFzIG5vIGxvbmdlciBibG9ja2VkXG4gIC8vIGFuZCBlbGlnaWJsZSBmb3IgYSByZXBsYXkuXG4gIGlmIChxdWV1ZWREaXNjcmV0ZUV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERpc2NyZXRlRXZlbnRzWzBdLCB1bmJsb2NrZWQpOyAvLyBUaGlzIGlzIGEgZXhwb25lbnRpYWwgc2VhcmNoIGZvciBlYWNoIGJvdW5kYXJ5IHRoYXQgY29tbWl0cy4gSSB0aGluayBpdCdzXG4gICAgLy8gd29ydGggaXQgYmVjYXVzZSB3ZSBleHBlY3QgdmVyeSBmZXcgZGlzY3JldGUgZXZlbnRzIHRvIHF1ZXVlIHVwIGFuZCBvbmNlXG4gICAgLy8gd2UgYXJlIGFjdHVhbGx5IGZ1bGx5IHVuYmxvY2tlZCBpdCB3aWxsIGJlIGZhc3QgdG8gcmVwbGF5IHRoZW0uXG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcXVldWVkRXZlbnQgPSBxdWV1ZWREaXNjcmV0ZUV2ZW50c1tpXTtcblxuICAgICAgaWYgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkKSB7XG4gICAgICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1ZXVlZEZvY3VzICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEZvY3VzLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgaWYgKHF1ZXVlZERyYWcgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRHJhZywgdW5ibG9ja2VkKTtcbiAgfVxuXG4gIGlmIChxdWV1ZWRNb3VzZSAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRNb3VzZSwgdW5ibG9ja2VkKTtcbiAgfVxuXG4gIHZhciB1bmJsb2NrID0gZnVuY3Rpb24gKHF1ZXVlZEV2ZW50KSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKTtcbiAgfTtcblxuICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKHVuYmxvY2spO1xuICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZm9yRWFjaCh1bmJsb2NrKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aDsgX2krKykge1xuICAgIHZhciBxdWV1ZWRUYXJnZXQgPSBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbX2ldO1xuXG4gICAgaWYgKHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCkge1xuICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIG5leHRFeHBsaWNpdFRhcmdldCA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1swXTtcblxuICAgIGlmIChuZXh0RXhwbGljaXRUYXJnZXQuYmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLlxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChuZXh0RXhwbGljaXRUYXJnZXQpO1xuXG4gICAgICBpZiAobmV4dEV4cGxpY2l0VGFyZ2V0LmJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSB1bmJsb2NrZWQuXG4gICAgICAgIHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZzsgLy8gVE9ETzogY2FuIHdlIHN0b3AgZXhwb3J0aW5nIHRoZXNlP1xuXG52YXIgX2VuYWJsZWQgPSB0cnVlOyAvLyBUaGlzIGlzIGV4cG9ydGVkIGluIEZCIGJ1aWxkcyBmb3IgdXNlIGJ5IGxlZ2FjeSBGQiBsYXllciBpbmZyYS5cbi8vIFdlJ2QgbGlrZSB0byByZW1vdmUgdGhpcyBidXQgaXQncyBub3QgY2xlYXIgaWYgdGhpcyBpcyBzYWZlLlxuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5KHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gIHZhciBldmVudFByaW9yaXR5ID0gZ2V0RXZlbnRQcmlvcml0eShkb21FdmVudE5hbWUpO1xuICB2YXIgbGlzdGVuZXJXcmFwcGVyO1xuXG4gIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hDb250aW51b3VzRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgZGVmYXVsdDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcldyYXBwZXIuYmluZChudWxsLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoQ29udGludW91c0V2ZW50UHJpb3JpdHkpO1xuICAgIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICghX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgZGlzcGF0Y2hFdmVudFdpdGhFbmFibGVDYXB0dXJlUGhhc2VTZWxlY3RpdmVIeWRyYXRpb25XaXRob3V0RGlzY3JldGVFdmVudFJlcGxheShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRXaXRoRW5hYmxlQ2FwdHVyZVBoYXNlU2VsZWN0aXZlSHlkcmF0aW9uV2l0aG91dERpc2NyZXRlRXZlbnRSZXBsYXkoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBibG9ja2VkT24gPSBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG5cbiAgaWYgKGJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCByZXR1cm5fdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKTtcbiAgICBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSkge1xuICAgIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXZSBuZWVkIHRvIGNsZWFyIG9ubHkgaWYgd2UgZGlkbid0IHF1ZXVlIGJlY2F1c2VcbiAgLy8gcXVldWVpbmcgaXMgYWNjdW11bGF0aXZlLlxuXG5cbiAgY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KTtcblxuICBpZiAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UgJiYgaXNEaXNjcmV0ZUV2ZW50VGhhdFJlcXVpcmVzSHlkcmF0aW9uKGRvbUV2ZW50TmFtZSkpIHtcbiAgICB3aGlsZSAoYmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dEJsb2NrZWRPbiA9IGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICAgICAgaWYgKG5leHRCbG9ja2VkT24gPT09IG51bGwpIHtcbiAgICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIHJldHVybl90YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dEJsb2NrZWRPbiA9PT0gYmxvY2tlZE9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBibG9ja2VkT24gPSBuZXh0QmxvY2tlZE9uO1xuICAgIH1cblxuICAgIGlmIChibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBUaGlzIGlzIG5vdCByZXBsYXlhYmxlIHNvIHdlJ2xsIGludm9rZSBpdCBidXQgd2l0aG91dCBhIHRhcmdldCxcbiAgLy8gaW4gY2FzZSB0aGUgZXZlbnQgc3lzdGVtIG5lZWRzIHRvIHRyYWNlIGl0LlxuXG5cbiAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIG51bGwsIHRhcmdldENvbnRhaW5lcik7XG59XG5cbnZhciByZXR1cm5fdGFyZ2V0SW5zdCA9IG51bGw7IC8vIFJldHVybnMgYSBTdXNwZW5zZUluc3RhbmNlIG9yIENvbnRhaW5lciBpZiBpdCdzIGJsb2NrZWQuXG4vLyBUaGUgcmV0dXJuX3RhcmdldEluc3QgZmllbGQgYWJvdmUgaXMgY29uY2VwdHVhbGx5IHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZS5cblxuZnVuY3Rpb24gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gVE9ETzogV2FybiBpZiBfZW5hYmxlZCBpcyBmYWxzZS5cbiAgcmV0dXJuX3RhcmdldEluc3QgPSBudWxsO1xuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB0cmVlIGhhcyBiZWVuIHVubW91bnRlZCBhbHJlYWR5LiBEaXNwYXRjaCB3aXRob3V0IGEgdGFyZ2V0LlxuICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWcgPSBuZWFyZXN0TW91bnRlZC50YWc7XG5cbiAgICAgIGlmICh0YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFF1ZXVlIHRoZSBldmVudCB0byBiZSByZXBsYXllZCBsYXRlci4gQWJvcnQgZGlzcGF0Y2hpbmcgc2luY2Ugd2VcbiAgICAgICAgICAvLyBkb24ndCB3YW50IHRoaXMgZXZlbnQgZGlzcGF0Y2hlZCB0d2ljZSB0aHJvdWdoIHRoZSBldmVudCBzeXN0ZW0uXG4gICAgICAgICAgLy8gVE9ETzogSWYgdGhpcyBpcyB0aGUgZmlyc3QgZGlzY3JldGUgZXZlbnQgaW4gdGhlIHF1ZXVlLiBTY2hlZHVsZSBhbiBpbmNyZWFzZWRcbiAgICAgICAgICAvLyBwcmlvcml0eSBmb3IgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0gLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBzb21ldGhpbmcgd2VudCB3cm9uZyBidXQgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgICAgLy8gdGhlIHdob2xlIHN5c3RlbSwgZGlzcGF0Y2ggdGhlIGV2ZW50IHdpdGhvdXQgYSB0YXJnZXQuXG4gICAgICAgIC8vIFRPRE86IFdhcm4uXG5cblxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNSb290RGVoeWRyYXRlZChyb290KSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgaGFwcGVucyBkdXJpbmcgYSByZXBsYXkgc29tZXRoaW5nIHdlbnQgd3JvbmcgYW5kIGl0IG1pZ2h0IGJsb2NrXG4gICAgICAgICAgLy8gdGhlIHdob2xlIHN5c3RlbS5cbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGFpbmVyRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldEluc3QgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gdGFyZ2V0SW5zdCkge1xuICAgICAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgICAgIC8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbiAgICAgICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgICAgIHRhcmdldEluc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDsgLy8gV2UncmUgbm90IGJsb2NrZWQgb24gYW55dGhpbmcuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5KGRvbUV2ZW50TmFtZSkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIC8vIFVzZWQgYnkgU2ltcGxlRXZlbnRQbHVnaW46XG4gICAgY2FzZSAnY2FuY2VsJzpcbiAgICBjYXNlICdjbGljayc6XG4gICAgY2FzZSAnY2xvc2UnOlxuICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICBjYXNlICdjb3B5JzpcbiAgICBjYXNlICdjdXQnOlxuICAgIGNhc2UgJ2F1eGNsaWNrJzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgY2FzZSAnZHJhZ3N0YXJ0JzpcbiAgICBjYXNlICdkcm9wJzpcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ2ludmFsaWQnOlxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXByZXNzJzpcbiAgICBjYXNlICdrZXl1cCc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdtb3VzZXVwJzpcbiAgICBjYXNlICdwYXN0ZSc6XG4gICAgY2FzZSAncGF1c2UnOlxuICAgIGNhc2UgJ3BsYXknOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgIGNhc2UgJ3JhdGVjaGFuZ2UnOlxuICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICBjYXNlICdyZXNpemUnOlxuICAgIGNhc2UgJ3NlZWtlZCc6XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgIGNhc2UgJ3ZvbHVtZWNoYW5nZSc6IC8vIFVzZWQgYnkgcG9seWZpbGxzOlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgY2FzZSAnY2hhbmdlJzpcbiAgICBjYXNlICdzZWxlY3Rpb25jaGFuZ2UnOlxuICAgIGNhc2UgJ3RleHRJbnB1dCc6XG4gICAgY2FzZSAnY29tcG9zaXRpb25zdGFydCc6XG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgIGNhc2UgJ2NvbXBvc2l0aW9udXBkYXRlJzogLy8gT25seSBlbmFibGVDcmVhdGVFdmVudEhhbmRsZUFQSTpcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgJ2JlZm9yZWJsdXInOlxuICAgIGNhc2UgJ2FmdGVyYmx1cic6IC8vIE5vdCB1c2VkIGJ5IFJlYWN0IGJ1dCBjb3VsZCBiZSBieSB1c2VyIGNvZGU6XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICBjYXNlICdiZWZvcmVpbnB1dCc6XG4gICAgY2FzZSAnYmx1cic6XG4gICAgY2FzZSAnZnVsbHNjcmVlbmNoYW5nZSc6XG4gICAgY2FzZSAnZm9jdXMnOlxuICAgIGNhc2UgJ2hhc2hjaGFuZ2UnOlxuICAgIGNhc2UgJ3BvcHN0YXRlJzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3NlbGVjdHN0YXJ0JzpcbiAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdleGl0JzpcbiAgICBjYXNlICdkcmFnbGVhdmUnOlxuICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJtb3ZlJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgY2FzZSAnc2Nyb2xsJzpcbiAgICBjYXNlICd0b2dnbGUnOlxuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgY2FzZSAnd2hlZWwnOiAvLyBOb3QgdXNlZCBieSBSZWFjdCBidXQgY291bGQgYmUgYnkgdXNlciBjb2RlOlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgY2FzZSAnbW91c2VsZWF2ZSc6XG4gICAgY2FzZSAncG9pbnRlcmVudGVyJzpcbiAgICBjYXNlICdwb2ludGVybGVhdmUnOlxuICAgICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuXG4gICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIG1pZ2h0IGJlIGluIHRoZSBTY2hlZHVsZXIgY2FsbGJhY2suXG4gICAgICAgIC8vIEV2ZW50dWFsbHkgdGhpcyBtZWNoYW5pc20gd2lsbCBiZSByZXBsYWNlZCBieSBhIGNoZWNrXG4gICAgICAgIC8vIG9mIHRoZSBjdXJyZW50IHByaW9yaXR5IG9uIHRoZSBuYXRpdmUgc2NoZWR1bGVyLlxuICAgICAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHkgPSBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpO1xuXG4gICAgICAgIHN3aXRjaCAoc2NoZWR1bGVyUHJpb3JpdHkpIHtcbiAgICAgICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcblxuICAgICAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG5cbiAgICAgICAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgTG93U2NoZWR1bGVyUHJpb3JpdHksIHNvbWVob3cuIE1heWJlIHRoZSBzYW1lIGxhbmUgYXMgaHlkcmF0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuXG4gICAgICAgICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICAgICAgICByZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5mdW5jdGlvbiBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9KTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwge1xuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBUaGVzZSB2YXJpYWJsZXMgc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgcm9vdCA9IG51bGw7XG52YXIgc3RhcnRUZXh0ID0gbnVsbDtcbnZhciBmYWxsYmFja1RleHQgPSBudWxsO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICByb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIHN0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXNldCgpIHtcbiAgcm9vdCA9IG51bGw7XG4gIHN0YXJ0VGV4dCA9IG51bGw7XG4gIGZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5mdW5jdGlvbiBnZXREYXRhKCkge1xuICBpZiAoZmFsbGJhY2tUZXh0KSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgfVxuXG4gIHZhciBzdGFydDtcbiAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQ7XG4gIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICB2YXIgZW5kO1xuICB2YXIgZW5kVmFsdWUgPSBnZXRUZXh0KCk7XG4gIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG5cbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBmYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cbmZ1bmN0aW9uIGdldFRleHQoKSB7XG4gIGlmICgndmFsdWUnIGluIHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByb290LnRleHRDb250ZW50O1xufVxuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTsgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfSAvLyBJRSBhbmQgRWRnZSAob24gV2luZG93cykgYW5kIENocm9tZSAvIFNhZmFyaSAob24gV2luZG93cyBhbmQgTGludXgpXG4gIC8vIHJlcG9ydCBFbnRlciBhcyBjaGFyQ29kZSAxMCB3aGVuIGN0cmwgaXMgcHJlc3NlZC5cblxuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9IC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuXG5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYSBmYWN0b3J5IHNvIHRoYXQgd2UgaGF2ZSBkaWZmZXJlbnQgcmV0dXJuZWQgY29uc3RydWN0b3JzLlxuLy8gSWYgd2UgaGFkIGEgc2luZ2xlIGNvbnN0cnVjdG9yLCBpdCB3b3VsZCBiZSBtZWdhbW9ycGhpYyBhbmQgZW5naW5lcyB3b3VsZCBkZW9wdC5cblxuXG5mdW5jdGlvbiBjcmVhdGVTeW50aGV0aWNFdmVudChJbnRlcmZhY2UpIHtcbiAgLyoqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAgICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAgICpcbiAgICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAgICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gICAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAgICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAgICpcbiAgICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICAgKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICAgKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gICAqL1xuICBmdW5jdGlvbiBTeW50aGV0aWNCYXNlRXZlbnQocmVhY3ROYW1lLCByZWFjdEV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdGhpcy5fcmVhY3ROYW1lID0gcmVhY3ROYW1lO1xuICAgIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHRoaXMudHlwZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW19wcm9wTmFtZV07XG5cbiAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgdGhpc1tfcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W19wcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuXG4gICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhc3NpZ24oU3ludGhldGljQmFzZUV2ZW50LnByb3RvdHlwZSwge1xuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyAkRmxvd0ZpeE1lIC0gZmxvdyBpcyBub3QgYXdhcmUgb2YgYHVua25vd25gIGluIElFXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyAkRmxvd0ZpeE1lIC0gZmxvdyBpcyBub3QgYXdhcmUgb2YgYHVua25vd25gIGluIElFXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKi9cbiAgICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7Ly8gTW9kZXJuIGV2ZW50IHN5c3RlbSBkb2Vzbid0IHVzZSBwb29saW5nLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1BlcnNpc3RlbnQ6IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlXG4gIH0pO1xuICByZXR1cm4gU3ludGhldGljQmFzZUV2ZW50O1xufVxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgZXZlbnRQaGFzZTogMCxcbiAgYnViYmxlczogMCxcbiAgY2FuY2VsYWJsZTogMCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IDAsXG4gIGlzVHJ1c3RlZDogMFxufTtcbnZhciBTeW50aGV0aWNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIHZpZXc6IDAsXG4gIGRldGFpbDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVUlFdmVudEludGVyZmFjZSk7XG52YXIgbGFzdE1vdmVtZW50WDtcbnZhciBsYXN0TW92ZW1lbnRZO1xudmFyIGxhc3RNb3VzZUV2ZW50O1xuXG5mdW5jdGlvbiB1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZShldmVudCkge1xuICBpZiAoZXZlbnQgIT09IGxhc3RNb3VzZUV2ZW50KSB7XG4gICAgaWYgKGxhc3RNb3VzZUV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgICBsYXN0TW92ZW1lbnRYID0gZXZlbnQuc2NyZWVuWCAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblg7XG4gICAgICBsYXN0TW92ZW1lbnRZID0gZXZlbnQuc2NyZWVuWSAtIGxhc3RNb3VzZUV2ZW50LnNjcmVlblk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RNb3ZlbWVudFggPSAwO1xuICAgICAgbGFzdE1vdmVtZW50WSA9IDA7XG4gICAgfVxuXG4gICAgbGFzdE1vdXNlRXZlbnQgPSBldmVudDtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cblxudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgc2NyZWVuWDogMCxcbiAgc2NyZWVuWTogMCxcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMCxcbiAgcGFnZVg6IDAsXG4gIHBhZ2VZOiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogMCxcbiAgYnV0dG9uczogMCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KTtcbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WDtcbiAgfSxcbiAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WScgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFk7XG4gICAgfSAvLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4gICAgLy8gYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhbHJlYWR5IHJ1biB3aGVuIG1vdmVtZW50WFxuICAgIC8vIHdhcyBjb3BpZWQuXG5cblxuICAgIHJldHVybiBsYXN0TW92ZW1lbnRZO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGF0YVRyYW5zZmVyOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgcmVsYXRlZFRhcmdldDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRm9jdXNFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cblxudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBhbmltYXRpb25OYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xuXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xuXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGF0YTogMFxufSk7XG5cbnZhciBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xuLy8gSGFwcGVucyB0byBzaGFyZSB0aGUgc2FtZSBsaXN0IGZvciBub3cuXG5cbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xuXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xuXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcblxuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfSAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG5cblxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpOyAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cblxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cblxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICBBbHQ6ICdhbHRLZXknLFxuICBDb250cm9sOiAnY3RybEtleScsXG4gIE1ldGE6ICdtZXRhS2V5JyxcbiAgU2hpZnQ6ICdzaGlmdEtleSdcbn07IC8vIE9sZGVyIGJyb3dzZXJzIChTYWZhcmkgPD0gMTAsIGlPUyBTYWZhcmkgPD0gMTAuMikgZG8gbm90IHN1cHBvcnRcbi8vIGdldE1vZGlmaWVyU3RhdGUuIElmIGdldE1vZGlmaWVyU3RhdGUgaXMgbm90IHN1cHBvcnRlZCwgd2UgbWFwIGl0IHRvIGEgc2V0IG9mXG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50LiBJbiB0aGlzIGNhc2UsIExvY2sta2V5cyBhcmUgbm90IHN1cHBvcnRlZC5cblxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG5cbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG5cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cblxudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgY29kZTogMCxcbiAgbG9jYXRpb246IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIHJlcGVhdDogMCxcbiAgbG9jYWxlOiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi9cblxudmFyIFBvaW50ZXJFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBwb2ludGVySWQ6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHByZXNzdXJlOiAwLFxuICB0YW5nZW50aWFsUHJlc3N1cmU6IDAsXG4gIHRpbHRYOiAwLFxuICB0aWx0WTogMCxcbiAgdHdpc3Q6IDAsXG4gIHBvaW50ZXJUeXBlOiAwLFxuICBpc1ByaW1hcnk6IDBcbn0pO1xuXG52YXIgU3ludGhldGljUG9pbnRlckV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoUG9pbnRlckV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xuXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICB0b3VjaGVzOiAwLFxuICB0YXJnZXRUb3VjaGVzOiAwLFxuICBjaGFuZ2VkVG91Y2hlczogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59KTtcblxudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUb3VjaEV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cblxudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgcHJvcGVydHlOYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogMCxcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IDBcbn0pO1xuXG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxuXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcblxuaWYgKGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59IC8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG5cblxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlOyAvLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBjYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cygpIHtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkJlZm9yZUlucHV0JywgWydjb21wb3NpdGlvbmVuZCcsICdrZXlwcmVzcycsICd0ZXh0SW5wdXQnLCAncGFzdGUnXSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvbkVuZCcsIFsnY29tcG9zaXRpb25lbmQnLCAnZm9jdXNvdXQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdtb3VzZWRvd24nXSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvblN0YXJ0JywgWydjb21wb3NpdGlvbnN0YXJ0JywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25VcGRhdGUnLCBbJ2NvbXBvc2l0aW9udXBkYXRlJywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xufSAvLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG5cblxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cblxuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJiAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnY29tcG9zaXRpb25zdGFydCc6XG4gICAgICByZXR1cm4gJ29uQ29tcG9zaXRpb25TdGFydCc7XG5cbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gJ29uQ29tcG9zaXRpb25FbmQnO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb251cGRhdGUnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uVXBkYXRlJztcbiAgfVxufVxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIGRvbUV2ZW50TmFtZSA9PT0gJ2tleWRvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKi9cblxuXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcblxuICAgIGNhc2UgJ2tleXByZXNzJzpcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG5cbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb3NpdGlvbiBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IEtvcmVhbiBJTUUuXG4gKiBPdXIgZmFsbGJhY2sgbW9kZSBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBJRSdzIEtvcmVhbiBJTUUsXG4gKiBzbyBqdXN0IHVzZSBuYXRpdmUgY29tcG9zaXRpb24gZXZlbnRzIHdoZW4gS29yZWFuIElNRSBpcyB1c2VkLlxuICogQWx0aG91Z2ggQ29tcG9zaXRpb25FdmVudC5sb2NhbGUgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCxcbiAqIGl0IGlzIGF2YWlsYWJsZSBpbiBJRSwgd2hlcmUgb3VyIGZhbGxiYWNrIG1vZGUgaXMgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBuYXRpdmVFdmVudC5sb2NhbGUgPT09ICdrbyc7XG59IC8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cblxuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZShkb21FdmVudE5hbWUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gJ29uQ29tcG9zaXRpb25TdGFydCc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9ICdvbkNvbXBvc2l0aW9uRW5kJztcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSAnb25Db21wb3NpdGlvblN0YXJ0Jykge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ29uQ29tcG9zaXRpb25FbmQnKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgZXZlbnRUeXBlKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljQ29tcG9zaXRpb25FdmVudChldmVudFR5cGUsIGRvbUV2ZW50TmFtZSwgbnVsbCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcblxuICAgIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcblxuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTsgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBpZ25vcmUgaXQuXG5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmIChkb21FdmVudE5hbWUgPT09ICdjb21wb3NpdGlvbmVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAncGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cblxuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgJ29uQmVmb3JlSW5wdXQnKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljSW5wdXRFdmVudCgnb25CZWZvcmVJbnB1dCcsICdiZWZvcmVpbnB1dCcsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gICAgfSk7XG4gICAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4KSB7XG4gIGlmICghY2FuVXNlRE9NKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZG9jdW1lbnQpO1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzJDEoKSB7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25DaGFuZ2UnLCBbJ2NoYW5nZScsICdjbGljaycsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2lucHV0JywgJ2tleWRvd24nLCAna2V5dXAnLCAnc2VsZWN0aW9uY2hhbmdlJ10pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCkge1xuICAvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KTtcbiAgdmFyIGxpc3RlbmVycyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhpbnN0LCAnb25DaGFuZ2UnKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoJ29uQ2hhbmdlJywgJ2NoYW5nZScsIG51bGwsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG5cblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpOyAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cblxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGRpc3BhdGNoUXVldWUpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZGlzcGF0Y2hRdWV1ZSkge1xuICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO1xuXG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEluc3QpIHtcbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2NoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG5cblxudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cblxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuLyoqXG4gKiAoRm9yIElFIDw9OSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpIHtcbiAgICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3VzaW4nKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn0gLy8gRm9yIElFOCBhbmQgSUU5LlxuXG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdzZWxlY3Rpb25jaGFuZ2UnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ2tleXVwJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdjbGljaycpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdpbnB1dCcgfHwgZG9tRXZlbnROYW1lID09PSAnY2hhbmdlJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihub2RlKSB7XG4gIHZhciBzdGF0ZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCAnbnVtYmVyJywgbm9kZS52YWx1ZSk7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcblxuICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gIH1cblxuICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCk7XG5cbiAgICBpZiAoaW5zdCkge1xuICAgICAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgIGhhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICB9IC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG5cblxuICBpZiAoZG9tRXZlbnROYW1lID09PSAnZm9jdXNvdXQnKSB7XG4gICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXROb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQyKCkge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvbk1vdXNlRW50ZXInLCBbJ21vdXNlb3V0JywgJ21vdXNlb3ZlciddKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUxlYXZlJywgWydtb3VzZW91dCcsICdtb3VzZW92ZXInXSk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uUG9pbnRlckVudGVyJywgWydwb2ludGVyb3V0JywgJ3BvaW50ZXJvdmVyJ10pO1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJMZWF2ZScsIFsncG9pbnRlcm91dCcsICdwb2ludGVyb3ZlciddKTtcbn1cbi8qKlxuICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkMihkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBpc092ZXJFdmVudCA9IGRvbUV2ZW50TmFtZSA9PT0gJ21vdXNlb3ZlcicgfHwgZG9tRXZlbnROYW1lID09PSAncG9pbnRlcm92ZXInO1xuICB2YXIgaXNPdXRFdmVudCA9IGRvbUV2ZW50TmFtZSA9PT0gJ21vdXNlb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JztcblxuICBpZiAoaXNPdmVyRXZlbnQgJiYgIWlzUmVwbGF5aW5nRXZlbnQobmF0aXZlRXZlbnQpKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBvdmVyIGV2ZW50IHdpdGggYSB0YXJnZXQsIHdlIG1pZ2h0IGhhdmUgYWxyZWFkeSBkaXNwYXRjaGVkXG4gICAgLy8gdGhlIGV2ZW50IGluIHRoZSBvdXQgZXZlbnQgb2YgdGhlIG90aGVyIHRhcmdldC4gSWYgdGhpcyBpcyByZXBsYXllZCxcbiAgICAvLyB0aGVuIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBkaXNwYXRjaCBhZ2FpbnN0IHRoaXMgdGFyZ2V0IHByZXZpb3VzbHlcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGRvIGl0IG5vdyBpbnN0ZWFkLlxuICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudDtcblxuICAgIGlmIChyZWxhdGVkKSB7XG4gICAgICAvLyBJZiB0aGUgcmVsYXRlZCBub2RlIGlzIG1hbmFnZWQgYnkgUmVhY3QsIHdlIGNhbiBhc3N1bWUgdGhhdCB3ZSBoYXZlXG4gICAgICAvLyBhbHJlYWR5IGRpc3BhdGNoZWQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGR1cmluZyBpdHMgbW91c2VvdXQuXG4gICAgICBpZiAoZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgfHwgaXNDb250YWluZXJNYXJrZWRBc1Jvb3QocmVsYXRlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHdpbjsgLy8gVE9ETzogd2h5IGlzIHRoaXMgbnVsbGFibGUgaW4gdGhlIHR5cGVzIGJ1dCB3ZSByZWFkIGZyb20gaXQ/XG5cbiAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICBpZiAoZG9jKSB7XG4gICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgd2luID0gd2luZG93O1xuICAgIH1cbiAgfVxuXG4gIHZhciBmcm9tO1xuICB2YXIgdG87XG5cbiAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICB2YXIgX3JlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcblxuICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgIHRvID0gX3JlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShfcmVsYXRlZCkgOiBudWxsO1xuXG4gICAgaWYgKHRvICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRvKTtcblxuICAgICAgaWYgKHRvICE9PSBuZWFyZXN0TW91bnRlZCB8fCB0by50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgdG8udGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICB0byA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgZnJvbSA9IG51bGw7XG4gICAgdG8gPSB0YXJnZXRJbnN0O1xuICB9XG5cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICB2YXIgbGVhdmVFdmVudFR5cGUgPSAnb25Nb3VzZUxlYXZlJztcbiAgdmFyIGVudGVyRXZlbnRUeXBlID0gJ29uTW91c2VFbnRlcic7XG4gIHZhciBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuXG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3ZlcicpIHtcbiAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgbGVhdmVFdmVudFR5cGUgPSAnb25Qb2ludGVyTGVhdmUnO1xuICAgIGVudGVyRXZlbnRUeXBlID0gJ29uUG9pbnRlckVudGVyJztcbiAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gIH1cblxuICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuICB2YXIgbGVhdmUgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKGxlYXZlRXZlbnRUeXBlLCBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcbiAgdmFyIGVudGVyID0gbnVsbDsgLy8gV2Ugc2hvdWxkIG9ubHkgcHJvY2VzcyB0aGlzIG5hdGl2ZUV2ZW50IGlmIHdlIGFyZSBwcm9jZXNzaW5nXG4gIC8vIHRoZSBmaXJzdCBhbmNlc3Rvci4gTmV4dCB0aW1lLCB3ZSB3aWxsIGlnbm9yZSB0aGUgZXZlbnQuXG5cbiAgdmFyIG5hdGl2ZVRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKG5hdGl2ZVRhcmdldEluc3QgPT09IHRhcmdldEluc3QpIHtcbiAgICB2YXIgZW50ZXJFdmVudCA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoZW50ZXJFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyRXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGVudGVyID0gZW50ZXJFdmVudDtcbiAgfVxuXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudEtleSA9IGtleXNBW2ldO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8ICFvYmplY3RJcyhvYmpBW2N1cnJlbnRLZXldLCBvYmpCW2N1cnJlbnRLZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gb3V0ZXJOb2RlLm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbiAmJiB3aW4uZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0OyAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG59XG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG5cblxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG5cblxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cblxuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgLy8gRWRnZSBmYWlscyB3aXRoIFwiT2JqZWN0IGV4cGVjdGVkXCIgaW4gc29tZSBzY2VuYXJpb3MuXG4gIC8vIChGb3IgaW5zdGFuY2U6IFRpbnlNQ0UgZWRpdG9yIHVzZWQgaW4gYSBsaXN0IGNvbXBvbmVudCB0aGF0IHN1cHBvcnRzIHBhc3RpbmcgdG8gYWRkIG1vcmUsXG4gIC8vIGZhaWxzIHdoZW4gcGFzdGluZyAxMDArIGl0ZW1zKVxuXG4gIGlmICghd2luLmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpOyAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFO1xufVxuXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5vd25lckRvY3VtZW50ICYmIGNvbnRhaW5zTm9kZShub2RlLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JpZ2luRnJhbWUoaWZyYW1lKSB7XG4gIHRyeSB7XG4gICAgLy8gQWNjZXNzaW5nIHRoZSBjb250ZW50RG9jdW1lbnQgb2YgYSBIVE1MSWZyYW1lRWxlbWVudCBjYW4gY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyB0byB0aHJvdywgZS5nLiBpZiBpdCBoYXMgYSBjcm9zcy1vcmlnaW4gc3JjIGF0dHJpYnV0ZS5cbiAgICAvLyBTYWZhcmkgd2lsbCBzaG93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdoZW4gdGhlIGFjY2VzcyByZXN1bHRzIGluIFwiQmxvY2tlZCBhIGZyYW1lIHdpdGggb3JpZ2luXCIuIGUuZzpcbiAgICAvLyBpZnJhbWUuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIC8vIEEgc2FmZXR5IHdheSBpcyB0byBhY2Nlc3Mgb25lIG9mIHRoZSBjcm9zcyBvcmlnaW4gcHJvcGVydGllczogV2luZG93IG9yIExvY2F0aW9uXG4gICAgLy8gV2hpY2ggbWlnaHQgcmVzdWx0IGluIFwiU2VjdXJpdHlFcnJvclwiIERPTSBFeGNlcHRpb24gYW5kIGl0IGlzIGNvbXBhdGlibGUgdG8gU2FmYXJpLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjaW50ZWdyYXRpb24td2l0aC1pZGxcbiAgICByZXR1cm4gdHlwZW9mIGlmcmFtZS5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYgPT09ICdzdHJpbmcnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudERlZXAoKSB7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuXG4gIHdoaWxlIChlbGVtZW50IGluc3RhbmNlb2Ygd2luLkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgaWYgKGlzU2FtZU9yaWdpbkZyYW1lKGVsZW1lbnQpKSB7XG4gICAgICB3aW4gPSBlbGVtZW50LmNvbnRlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KHdpbi5kb2N1bWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG5cbi8qKlxuICogQGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogd2UgZ2V0IHRoZSBlbGVtZW50IHR5cGVzIHRoYXQgc3VwcG9ydCBzZWxlY3Rpb25cbiAqIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG8tbm90LWFwcGx5LCBsb29raW5nIGF0IGBzZWxlY3Rpb25TdGFydGBcbiAqIGFuZCBgc2VsZWN0aW9uRW5kYCByb3dzLlxuICovXG5cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAndGV4dCcgfHwgZWxlbS50eXBlID09PSAnc2VhcmNoJyB8fCBlbGVtLnR5cGUgPT09ICd0ZWwnIHx8IGVsZW0udHlwZSA9PT0gJ3VybCcgfHwgZWxlbS50eXBlID09PSAncGFzc3dvcmQnKSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCkge1xuICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG4vKipcbiAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG5cbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChwcmlvclNlbGVjdGlvblJhbmdlICE9PSBudWxsICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH0gLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcblxuXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG5cbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbjtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7XG4gICAgc3RhcnQ6IDAsXG4gICAgZW5kOiAwXG4gIH07XG59XG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQzKCkge1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uU2VsZWN0JywgWydmb2N1c291dCcsICdjb250ZXh0bWVudScsICdkcmFnZW5kJywgJ2ZvY3VzaW4nLCAna2V5ZG93bicsICdrZXl1cCcsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdzZWxlY3Rpb25jaGFuZ2UnXSk7XG59XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICovXG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd2luID0gbm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudCB0YXJnZXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldERvY3VtZW50KGV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBldmVudFRhcmdldC53aW5kb3cgPT09IGV2ZW50VGFyZ2V0ID8gZXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IGV2ZW50VGFyZ2V0IDogZXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbn1cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cblxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgdmFyIGRvYyA9IGdldEV2ZW50VGFyZ2V0RG9jdW1lbnQobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCQxID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCQxICE9PSBnZXRBY3RpdmVFbGVtZW50KGRvYykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuXG5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24kMShhY3RpdmVFbGVtZW50JDEpO1xuXG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgdmFyIGxpc3RlbmVycyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhhY3RpdmVFbGVtZW50SW5zdCQxLCAnb25TZWxlY3QnKTtcblxuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KCdvblNlbGVjdCcsICdzZWxlY3QnLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgICAgfSk7XG4gICAgICBldmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDMoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG5cbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAvL1xuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG5cbiAgICBjYXNlICdzZWxlY3Rpb25jaGFuZ2UnOlxuICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG5cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cblxudmFyIHN0eWxlID0ge307XG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cblxuaWYgKGNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlOyAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfSAvLyBTYW1lIGFzIGFib3ZlXG5cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbnZhciBBTklNQVRJT05fRU5EID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpO1xudmFyIEFOSU1BVElPTl9JVEVSQVRJT04gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyk7XG52YXIgQU5JTUFUSU9OX1NUQVJUID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0Jyk7XG52YXIgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpO1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKCk7IC8vIE5PVEU6IENhcGl0YWxpemF0aW9uIGlzIGltcG9ydGFudCBpbiB0aGlzIGxpc3QhXG4vL1xuLy8gRS5nLiBpdCBuZWVkcyBcInBvaW50ZXJEb3duXCIsIG5vdCBcInBvaW50ZXJkb3duXCIuXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2UgZGVyaXZlIGJvdGggUmVhY3QgbmFtZSAoXCJvblBvaW50ZXJEb3duXCIpXG4vLyBhbmQgRE9NIG5hbWUgKFwicG9pbnRlcmRvd25cIikgZnJvbSB0aGUgc2FtZSBsaXN0LlxuLy9cbi8vIEV4Y2VwdGlvbnMgdGhhdCBkb24ndCBtYXRjaCB0aGlzIGNvbnZlbnRpb24gYXJlIGxpc3RlZCBzZXBhcmF0ZWx5LlxuLy9cbi8vIHByZXR0aWVyLWlnbm9yZVxuXG52YXIgc2ltcGxlRXZlbnRQbHVnaW5FdmVudHMgPSBbJ2Fib3J0JywgJ2F1eENsaWNrJywgJ2NhbmNlbCcsICdjYW5QbGF5JywgJ2NhblBsYXlUaHJvdWdoJywgJ2NsaWNrJywgJ2Nsb3NlJywgJ2NvbnRleHRNZW51JywgJ2NvcHknLCAnY3V0JywgJ2RyYWcnLCAnZHJhZ0VuZCcsICdkcmFnRW50ZXInLCAnZHJhZ0V4aXQnLCAnZHJhZ0xlYXZlJywgJ2RyYWdPdmVyJywgJ2RyYWdTdGFydCcsICdkcm9wJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2dvdFBvaW50ZXJDYXB0dXJlJywgJ2lucHV0JywgJ2ludmFsaWQnLCAna2V5RG93bicsICdrZXlQcmVzcycsICdrZXlVcCcsICdsb2FkJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZFN0YXJ0JywgJ2xvc3RQb2ludGVyQ2FwdHVyZScsICdtb3VzZURvd24nLCAnbW91c2VNb3ZlJywgJ21vdXNlT3V0JywgJ21vdXNlT3ZlcicsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwb2ludGVyQ2FuY2VsJywgJ3BvaW50ZXJEb3duJywgJ3BvaW50ZXJNb3ZlJywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlck92ZXInLCAncG9pbnRlclVwJywgJ3Byb2dyZXNzJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAncmVzaXplJywgJ3NlZWtlZCcsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3VibWl0JywgJ3N1c3BlbmQnLCAndGltZVVwZGF0ZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaFN0YXJ0JywgJ3ZvbHVtZUNoYW5nZScsICdzY3JvbGwnLCAndG9nZ2xlJywgJ3RvdWNoTW92ZScsICd3YWl0aW5nJywgJ3doZWVsJ107XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnQoZG9tRXZlbnROYW1lLCByZWFjdE5hbWUpIHtcbiAgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KGRvbUV2ZW50TmFtZSwgcmVhY3ROYW1lKTtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlYWN0TmFtZSwgW2RvbUV2ZW50TmFtZV0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclNpbXBsZUV2ZW50cygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaW1wbGVFdmVudFBsdWdpbkV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldmVudE5hbWUgPSBzaW1wbGVFdmVudFBsdWdpbkV2ZW50c1tpXTtcbiAgICB2YXIgZG9tRXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudE5hbWVbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50TmFtZS5zbGljZSgxKTtcbiAgICByZWdpc3RlclNpbXBsZUV2ZW50KGRvbUV2ZW50TmFtZSwgJ29uJyArIGNhcGl0YWxpemVkRXZlbnQpO1xuICB9IC8vIFNwZWNpYWwgY2FzZXMgd2hlcmUgZXZlbnQgbmFtZXMgZG9uJ3QgbWF0Y2guXG5cblxuICByZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9FTkQsICdvbkFuaW1hdGlvbkVuZCcpO1xuICByZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9JVEVSQVRJT04sICdvbkFuaW1hdGlvbkl0ZXJhdGlvbicpO1xuICByZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9TVEFSVCwgJ29uQW5pbWF0aW9uU3RhcnQnKTtcbiAgcmVnaXN0ZXJTaW1wbGVFdmVudCgnZGJsY2xpY2snLCAnb25Eb3VibGVDbGljaycpO1xuICByZWdpc3RlclNpbXBsZUV2ZW50KCdmb2N1c2luJywgJ29uRm9jdXMnKTtcbiAgcmVnaXN0ZXJTaW1wbGVFdmVudCgnZm9jdXNvdXQnLCAnb25CbHVyJyk7XG4gIHJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9FTkQsICdvblRyYW5zaXRpb25FbmQnKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuXG4gIGlmIChyZWFjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgdmFyIHJlYWN0RXZlbnRUeXBlID0gZG9tRXZlbnROYW1lO1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnZm9jdXMnO1xuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnYmx1cic7XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWZvcmVibHVyJzpcbiAgICBjYXNlICdhZnRlcmJsdXInOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY2xpY2snOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2F1eGNsaWNrJzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNldXAnOiAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG5cbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICBjYXNlICdkcmFnZW5kJzpcbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdleGl0JzpcbiAgICBjYXNlICdkcmFnbGVhdmUnOlxuICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgIGNhc2UgQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVFJBTlNJVElPTl9FTkQ6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjb3B5JzpcbiAgICBjYXNlICdjdXQnOlxuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgY2FzZSAnbG9zdHBvaW50ZXJjYXB0dXJlJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIHtcbiAgICAvLyBTb21lIGV2ZW50cyBkb24ndCBidWJibGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgLy8gSW4gdGhlIHBhc3QsIFJlYWN0IGhhcyBhbHdheXMgYnViYmxlZCB0aGVtLCBidXQgdGhpcyBjYW4gYmUgc3VycHJpc2luZy5cbiAgICAvLyBXZSdyZSBnb2luZyB0byB0cnkgYWxpZ25pbmcgY2xvc2VyIHRvIHRoZSBicm93c2VyIGJlaGF2aW9yIGJ5IG5vdCBidWJibGluZ1xuICAgIC8vIHRoZW0gaW4gUmVhY3QgZWl0aGVyLiBXZSdsbCBzdGFydCBieSBub3QgYnViYmxpbmcgb25TY3JvbGwsIGFuZCB0aGVuIGV4cGFuZC5cbiAgICB2YXIgYWNjdW11bGF0ZVRhcmdldE9ubHkgPSAhaW5DYXB0dXJlUGhhc2UgJiYgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFkZCBhbGwgZXZlbnRzIGZyb21cbiAgICAvLyBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdCBpbiBET01QbHVnaW5FdmVudFN5c3RlbS5cbiAgICAvLyBUaGVuIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGxpc3QuXG4gICAgLy8gVGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZSB0aGF0IGNhbiB3YWl0IHVudGlsIFJlYWN0IDE4LlxuICAgIGRvbUV2ZW50TmFtZSA9PT0gJ3Njcm9sbCc7XG5cbiAgICB2YXIgX2xpc3RlbmVycyA9IGFjY3VtdWxhdGVTaW5nbGVQaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50LnR5cGUsIGluQ2FwdHVyZVBoYXNlLCBhY2N1bXVsYXRlVGFyZ2V0T25seSk7XG5cbiAgICBpZiAoX2xpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGNyZWF0ZSBldmVudCBsYXppbHkuXG4gICAgICB2YXIgX2V2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihyZWFjdE5hbWUsIHJlYWN0RXZlbnRUeXBlLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogX2V2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiByZW1vdmUgdG9wLWxldmVsIHNpZGUgZWZmZWN0LlxucmVnaXN0ZXJTaW1wbGVFdmVudHMoKTtcbnJlZ2lzdGVyRXZlbnRzJDIoKTtcbnJlZ2lzdGVyRXZlbnRzJDEoKTtcbnJlZ2lzdGVyRXZlbnRzJDMoKTtcbnJlZ2lzdGVyRXZlbnRzKCk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkNShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIC8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhlIGNvbmNlcHQgb2YgYSBcIlNpbXBsZUV2ZW50UGx1Z2luXCIuXG4gIC8vIFRoaXMgaXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGV2ZW50IHN5c3RlbS4gQWxsXG4gIC8vIHRoZSBvdGhlciBwbHVnaW5zIGFyZSBlc3NlbnRpYWxseSBwb2x5ZmlsbHMuIFNvIHRoZSBwbHVnaW5cbiAgLy8gc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWQgc29tZXdoZXJlIGFuZCBoYXZlIGl0cyBsb2dpY1xuICAvLyBiZSBjb3JlIHRoZSB0byBldmVudCBzeXN0ZW0uIFRoaXMgd291bGQgcG90ZW50aWFsbHkgYWxsb3dcbiAgLy8gdXMgdG8gc2hpcCBidWlsZHMgb2YgUmVhY3Qgd2l0aG91dCB0aGUgcG9seWZpbGxlZCBwbHVnaW5zIGJlbG93LlxuICBleHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICB2YXIgc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucyA9IChldmVudFN5c3RlbUZsYWdzICYgU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlMpID09PSAwOyAvLyBXZSBkb24ndCBwcm9jZXNzIHRoZXNlIGV2ZW50cyB1bmxlc3Mgd2UgYXJlIGluIHRoZVxuICAvLyBldmVudCdzIG5hdGl2ZSBcImJ1YmJsZVwiIHBoYXNlLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4gIC8vIG5vdCBpbiB0aGUgY2FwdHVyZSBwaGFzZS4gVGhhdCdzIGJlY2F1c2Ugd2UgZW11bGF0ZVxuICAvLyB0aGUgY2FwdHVyZSBwaGFzZSBoZXJlIHN0aWxsLiBUaGlzIGlzIGEgdHJhZGUtb2ZmLFxuICAvLyBiZWNhdXNlIGluIGFuIGlkZWFsIHdvcmxkIHdlIHdvdWxkIG5vdCBlbXVsYXRlIGFuZCB1c2VcbiAgLy8gdGhlIHBoYXNlcyBwcm9wZXJseSwgbGlrZSB3ZSBkbyB3aXRoIHRoZSBTaW1wbGVFdmVudFxuICAvLyBwbHVnaW4uIEhvd2V2ZXIsIHRoZSBwbHVnaW5zIGJlbG93IGVpdGhlciBleHBlY3RcbiAgLy8gZW11bGF0aW9uIChFbnRlckxlYXZlKSBvciB1c2Ugc3RhdGUgbG9jYWxpemVkIHRvIHRoYXRcbiAgLy8gcGx1Z2luIChCZWZvcmVJbnB1dCwgQ2hhbmdlLCBTZWxlY3QpLiBUaGUgc3RhdGUgaW5cbiAgLy8gdGhlc2UgbW9kdWxlcyBjb21wbGljYXRlcyB0aGluZ3MsIGFzIHlvdSdsbCBlc3NlbnRpYWxseVxuICAvLyBnZXQgdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgcGhhc2UgZXZlbnQgbWlnaHQgY2hhbmdlXG4gIC8vIHN0YXRlLCBvbmx5IGZvciB0aGUgZm9sbG93aW5nIGJ1YmJsZSBldmVudCB0byBjb21lIGluXG4gIC8vIGxhdGVyIGFuZCBub3QgdHJpZ2dlciBhbnl0aGluZyBhcyB0aGUgc3RhdGUgbm93XG4gIC8vIGludmFsaWRhdGVzIHRoZSBoZXVyaXN0aWNzIG9mIHRoZSBldmVudCBwbHVnaW4uIFdlXG4gIC8vIGNvdWxkIGFsdGVyIGFsbCB0aGVzZSBwbHVnaW5zIHRvIHdvcmsgaW4gc3VjaCB3YXlzLCBidXRcbiAgLy8gdGhhdCBtaWdodCBjYXVzZSBvdGhlciB1bmtub3duIHNpZGUtZWZmZWN0cyB0aGF0IHdlXG4gIC8vIGNhbid0IGZvcmVzZWUgcmlnaHQgbm93LlxuXG4gIGlmIChzaG91bGRQcm9jZXNzUG9seWZpbGxQbHVnaW5zKSB7XG4gICAgZXh0cmFjdEV2ZW50cyQyKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGV4dHJhY3RFdmVudHMkMyhkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIH1cbn0gLy8gTGlzdCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIGluZGl2aWR1YWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50cy5cblxuXG52YXIgbWVkaWFFdmVudFR5cGVzID0gWydhYm9ydCcsICdjYW5wbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ2R1cmF0aW9uY2hhbmdlJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2xvYWRlZGRhdGEnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZHN0YXJ0JywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwcm9ncmVzcycsICdyYXRlY2hhbmdlJywgJ3Jlc2l6ZScsICdzZWVrZWQnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1c3BlbmQnLCAndGltZXVwZGF0ZScsICd2b2x1bWVjaGFuZ2UnLCAnd2FpdGluZyddOyAvLyBXZSBzaG91bGQgbm90IGRlbGVnYXRlIHRoZXNlIGV2ZW50cyB0byB0aGUgY29udGFpbmVyLCBidXQgcmF0aGVyXG4vLyBzZXQgdGhlbSBvbiB0aGUgYWN0dWFsIHRhcmdldCBlbGVtZW50IGl0c2VsZi4gVGhpcyBpcyBwcmltYXJpbHlcbi8vIGJlY2F1c2UgdGhlc2UgZXZlbnRzIGRvIG5vdCBjb25zaXN0ZW50bHkgYnViYmxlIGluIHRoZSBET00uXG5cbnZhciBub25EZWxlZ2F0ZWRFdmVudHMgPSBuZXcgU2V0KFsnY2FuY2VsJywgJ2Nsb3NlJywgJ2ludmFsaWQnLCAnbG9hZCcsICdzY3JvbGwnLCAndG9nZ2xlJ10uY29uY2F0KG1lZGlhRXZlbnRUeXBlcykpO1xuXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcHJldmlvdXNJbnN0YW5jZTtcblxuICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICBmb3IgKHZhciBpID0gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkaSA9IGRpc3BhdGNoTGlzdGVuZXJzW2ldLFxuICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsXG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgbGlzdGVuZXIgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5saXN0ZW5lcjtcblxuICAgICAgaWYgKGluc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kaXNwYXRjaExpc3RlbmVycyRfaSA9IGRpc3BhdGNoTGlzdGVuZXJzW19pXSxcbiAgICAgICAgICBfaW5zdGFuY2UgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuaW5zdGFuY2UsXG4gICAgICAgICAgX2N1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBfbGlzdGVuZXIgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kubGlzdGVuZXI7XG5cbiAgICAgIGlmIChfaW5zdGFuY2UgIT09IHByZXZpb3VzSW5zdGFuY2UgJiYgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgX2xpc3RlbmVyLCBfY3VycmVudFRhcmdldCk7XG4gICAgICBwcmV2aW91c0luc3RhbmNlID0gX2luc3RhbmNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gIHZhciBpbkNhcHR1cmVQaGFzZSA9IChldmVudFN5c3RlbUZsYWdzICYgSVNfQ0FQVFVSRV9QSEFTRSkgIT09IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9kaXNwYXRjaFF1ZXVlJGkgPSBkaXNwYXRjaFF1ZXVlW2ldLFxuICAgICAgICBldmVudCA9IF9kaXNwYXRjaFF1ZXVlJGkuZXZlbnQsXG4gICAgICAgIGxpc3RlbmVycyA9IF9kaXNwYXRjaFF1ZXVlJGkubGlzdGVuZXJzO1xuICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LCBsaXN0ZW5lcnMsIGluQ2FwdHVyZVBoYXNlKTsgLy8gIGV2ZW50IHN5c3RlbSBkb2Vzbid0IHVzZSBwb29saW5nLlxuICB9IC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuXG5cbiAgcmV0aHJvd0NhdWdodEVycm9yKCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICBleHRyYWN0RXZlbnRzJDUoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEVsZW1lbnQpIHtcbiAge1xuICAgIGlmICghbm9uRGVsZWdhdGVkRXZlbnRzLmhhcyhkb21FdmVudE5hbWUpKSB7XG4gICAgICBlcnJvcignRGlkIG5vdCBleHBlY3QgYSBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCkgY2FsbCBmb3IgXCIlc1wiLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGRvbUV2ZW50TmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIgPSBmYWxzZTtcbiAgdmFyIGxpc3RlbmVyU2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXRFbGVtZW50KTtcbiAgdmFyIGxpc3RlbmVyU2V0S2V5ID0gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcblxuICBpZiAoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpIHtcbiAgICBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBkb21FdmVudE5hbWUsIElTX05PTl9ERUxFR0FURUQsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpO1xuICAgIGxpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCB0YXJnZXQpIHtcbiAge1xuICAgIGlmIChub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkgJiYgIWlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpIHtcbiAgICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBhIGxpc3RlblRvTmF0aXZlRXZlbnQoKSBjYWxsIGZvciBcIiVzXCIgaW4gdGhlIGJ1YmJsZSBwaGFzZS4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBkb21FdmVudE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudFN5c3RlbUZsYWdzID0gMDtcblxuICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgIGV2ZW50U3lzdGVtRmxhZ3MgfD0gSVNfQ0FQVFVSRV9QSEFTRTtcbiAgfVxuXG4gIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbn0gLy8gVGhpcyBpcyBvbmx5IHVzZWQgYnkgY3JlYXRlRXZlbnRIYW5kbGUgd2hlbiB0aGVcbnZhciBsaXN0ZW5pbmdNYXJrZXIgPSAnX3JlYWN0TGlzdGVuaW5nJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuZnVuY3Rpb24gbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgaWYgKCFyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdKSB7XG4gICAgcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSA9IHRydWU7XG4gICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgLy8gV2UgaGFuZGxlIHNlbGVjdGlvbmNoYW5nZSBzZXBhcmF0ZWx5IGJlY2F1c2UgaXRcbiAgICAgIC8vIGRvZXNuJ3QgYnViYmxlIGFuZCBuZWVkcyB0byBiZSBvbiB0aGUgZG9jdW1lbnQuXG4gICAgICBpZiAoZG9tRXZlbnROYW1lICE9PSAnc2VsZWN0aW9uY2hhbmdlJykge1xuICAgICAgICBpZiAoIW5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSkge1xuICAgICAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBmYWxzZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIHRydWUsIHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuXG4gICAgaWYgKG93bmVyRG9jdW1lbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQgYWxzbyBuZWVkcyBkZWR1cGxpY2F0aW9uXG4gICAgICAvLyBidXQgaXQgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAgaWYgKCFvd25lckRvY3VtZW50W2xpc3RlbmluZ01hcmtlcl0pIHtcbiAgICAgICAgb3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdID0gdHJ1ZTtcbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudCgnc2VsZWN0aW9uY2hhbmdlJywgZmFsc2UsIG93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciwgaXNEZWZlcnJlZExpc3RlbmVyRm9yTGVnYWN5RkJTdXBwb3J0KSB7XG4gIHZhciBsaXN0ZW5lciA9IGNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5KHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzKTsgLy8gSWYgcGFzc2l2ZSBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCwgdGhlbiB0aGUgZXZlbnQgd2lsbCBiZVxuICAvLyBhY3RpdmUgYW5kIG5vdCBwYXNzaXZlLlxuXG4gIHZhciBpc1Bhc3NpdmVMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICBpZiAocGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAvLyBCcm93c2VycyBpbnRyb2R1Y2VkIGFuIGludGVydmVudGlvbiwgbWFraW5nIHRoZXNlIGV2ZW50c1xuICAgIC8vIHBhc3NpdmUgYnkgZGVmYXVsdCBvbiBkb2N1bWVudC4gUmVhY3QgZG9lc24ndCBiaW5kIHRoZW1cbiAgICAvLyB0byBkb2N1bWVudCBhbnltb3JlLCBidXQgY2hhbmdpbmcgdGhpcyBub3cgd291bGQgdW5kb1xuICAgIC8vIHRoZSBwZXJmb3JtYW5jZSB3aW5zIGZyb20gdGhlIGNoYW5nZS4gU28gd2UgZW11bGF0ZVxuICAgIC8vIHRoZSBleGlzdGluZyBiZWhhdmlvciBtYW51YWxseSBvbiB0aGUgcm9vdHMgbm93LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTk2NTFcbiAgICBpZiAoZG9tRXZlbnROYW1lID09PSAndG91Y2hzdGFydCcgfHwgZG9tRXZlbnROYW1lID09PSAndG91Y2htb3ZlJyB8fCBkb21FdmVudE5hbWUgPT09ICd3aGVlbCcpIHtcbiAgICAgIGlzUGFzc2l2ZUxpc3RlbmVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB0YXJnZXRDb250YWluZXIgPSAgdGFyZ2V0Q29udGFpbmVyO1xuICB2YXIgdW5zdWJzY3JpYmVMaXN0ZW5lcjsgLy8gV2hlbiBsZWdhY3lGQlN1cHBvcnQgaXMgZW5hYmxlZCwgaXQncyBmb3Igd2hlbiB3ZVxuXG5cbiAgaWYgKGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpIHtcbiAgICBpZiAoaXNQYXNzaXZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lciwgaXNQYXNzaXZlTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzUGFzc2l2ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lciwgaXNQYXNzaXZlTGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHJldHVybiBncmFuZENvbnRhaW5lciA9PT0gdGFyZ2V0Q29udGFpbmVyIHx8IGdyYW5kQ29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgZ3JhbmRDb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGFyZ2V0Q29udGFpbmVyO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBhbmNlc3Rvckluc3QgPSB0YXJnZXRJbnN0O1xuXG4gIGlmICgoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFKSA9PT0gMCAmJiAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX05PTl9ERUxFR0FURUQpID09PSAwKSB7XG4gICAgdmFyIHRhcmdldENvbnRhaW5lck5vZGUgPSB0YXJnZXRDb250YWluZXI7IC8vIElmIHdlIGFyZSB1c2luZyB0aGUgbGVnYWN5IEZCIHN1cHBvcnQgZmxhZywgd2VcblxuICAgIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGUgYmVsb3cgbG9naWMgYXR0ZW1wdHMgdG8gd29yayBvdXQgaWYgd2UgbmVlZCB0byBjaGFuZ2VcbiAgICAgIC8vIHRoZSB0YXJnZXQgZmliZXIgdG8gYSBkaWZmZXJlbnQgYW5jZXN0b3IuIFdlIGhhZCBzaW1pbGFyIGxvZ2ljXG4gICAgICAvLyBpbiB0aGUgbGVnYWN5IGV2ZW50IHN5c3RlbSwgZXhjZXB0IHRoZSBiaWcgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gICAgICAvLyBzeXN0ZW1zIGlzIHRoYXQgdGhlIG1vZGVybiBldmVudCBzeXN0ZW0gbm93IGhhcyBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgLy8gYXR0YWNoZWQgdG8gZWFjaCBSZWFjdCBSb290IGFuZCBSZWFjdCBQb3J0YWwgUm9vdC4gVG9nZXRoZXIsXG4gICAgICAvLyB0aGUgRE9NIG5vZGVzIHJlcHJlc2VudGluZyB0aGVzZSByb290cyBhcmUgdGhlIFwicm9vdENvbnRhaW5lclwiLlxuICAgICAgLy8gVG8gZmlndXJlIG91dCB3aGljaCBhbmNlc3RvciBpbnN0YW5jZSB3ZSBzaG91bGQgdXNlLCB3ZSB0cmF2ZXJzZVxuICAgICAgLy8gdXAgdGhlIGZpYmVyIHRyZWUgZnJvbSB0aGUgdGFyZ2V0IGluc3RhbmNlIGFuZCBhdHRlbXB0IHRvIGZpbmRcbiAgICAgIC8vIHJvb3QgYm91bmRhcmllcyB0aGF0IG1hdGNoIHRoYXQgb2Ygb3VyIGN1cnJlbnQgXCJyb290Q29udGFpbmVyXCIuXG4gICAgICAvLyBJZiB3ZSBmaW5kIHRoYXQgXCJyb290Q29udGFpbmVyXCIsIHdlIGZpbmQgdGhlIHBhcmVudCBmaWJlclxuICAgICAgLy8gc3ViLXRyZWUgZm9yIHRoYXQgcm9vdCBhbmQgbWFrZSB0aGF0IG91ciBhbmNlc3RvciBpbnN0YW5jZS5cbiAgICAgIHZhciBub2RlID0gdGFyZ2V0SW5zdDtcblxuICAgICAgbWFpbkxvb3A6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGVUYWcgPSBub2RlLnRhZztcblxuICAgICAgICBpZiAobm9kZVRhZyA9PT0gSG9zdFJvb3QgfHwgbm9kZVRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgaWYgKGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGNvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlVGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IGlzIGEgcG9ydGFsLCBidXQgaXQncyBub3QgdGhlIHJvb3RDb250YWluZXIgd2UncmUgbG9va2luZyBmb3IuXG4gICAgICAgICAgICAvLyBOb3JtYWxseSBwb3J0YWxzIGhhbmRsZSB0aGVpciBvd24gZXZlbnRzIGFsbCB0aGUgd2F5IGRvd24gdG8gdGhlIHJvb3QuXG4gICAgICAgICAgICAvLyBTbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBzdG9wIG5vdy4gSG93ZXZlciwgd2UgZG9uJ3Qga25vdyBpZiB0aGlzIHBvcnRhbFxuICAgICAgICAgICAgLy8gd2FzIHBhcnQgb2YgKm91ciogcm9vdC5cbiAgICAgICAgICAgIHZhciBncmFuZE5vZGUgPSBub2RlLnJldHVybjtcblxuICAgICAgICAgICAgd2hpbGUgKGdyYW5kTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgZ3JhbmRUYWcgPSBncmFuZE5vZGUudGFnO1xuXG4gICAgICAgICAgICAgIGlmIChncmFuZFRhZyA9PT0gSG9zdFJvb3QgfHwgZ3JhbmRUYWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhbmRDb250YWluZXIgPSBncmFuZE5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoZ3JhbmRDb250YWluZXIsIHRhcmdldENvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByb290Q29udGFpbmVyIHdlJ3JlIGxvb2tpbmcgZm9yIGFuZCB3ZSBmb3VuZCBpdCBhc1xuICAgICAgICAgICAgICAgICAgLy8gYSBwYXJlbnQgb2YgdGhlIFBvcnRhbC4gVGhhdCBtZWFucyB3ZSBjYW4gaWdub3JlIGl0IGJlY2F1c2UgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBQb3J0YWwgd2lsbCBidWJibGUgdGhyb3VnaCB0byB1cy5cbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBncmFuZE5vZGUgPSBncmFuZE5vZGUucmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gTm93IHdlIG5lZWQgdG8gZmluZCBpdCdzIGNvcnJlc3BvbmRpbmcgaG9zdCBmaWJlciBpbiB0aGUgb3RoZXJcbiAgICAgICAgICAvLyB0cmVlLiBUbyBkbyB0aGlzIHdlIGNhbiB1c2UgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsIGJ1dCB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gdmFsaWRhdGUgdGhhdCB0aGUgZmliZXIgaXMgYSBob3N0IGluc3RhbmNlLCBvdGhlcndpc2VcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHRyYXZlcnNlIHVwIHRocm91Z2ggdGhlIERPTSB0aWxsIHdlIGZpbmQgdGhlIGNvcnJlY3RcbiAgICAgICAgICAvLyBub2RlIHRoYXQgaXMgZnJvbSB0aGUgb3RoZXIgdHJlZS5cblxuXG4gICAgICAgICAgd2hpbGUgKGNvbnRhaW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnROb2RlLnRhZztcblxuICAgICAgICAgICAgaWYgKHBhcmVudFRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBwYXJlbnRUYWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICAgIG5vZGUgPSBhbmNlc3Rvckluc3QgPSBwYXJlbnROb2RlO1xuICAgICAgICAgICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudHNGb3JQbHVnaW5zKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIGFuY2VzdG9ySW5zdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICByZXR1cm4ge1xuICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldFxuICB9O1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnModGFyZ2V0RmliZXIsIHJlYWN0TmFtZSwgbmF0aXZlRXZlbnRUeXBlLCBpbkNhcHR1cmVQaGFzZSwgYWNjdW11bGF0ZVRhcmdldE9ubHksIG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSAhPT0gbnVsbCA/IHJlYWN0TmFtZSArICdDYXB0dXJlJyA6IG51bGw7XG4gIHZhciByZWFjdEV2ZW50TmFtZSA9IGluQ2FwdHVyZVBoYXNlID8gY2FwdHVyZU5hbWUgOiByZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0RmliZXI7XG4gIHZhciBsYXN0SG9zdENvbXBvbmVudCA9IG51bGw7IC8vIEFjY3VtdWxhdGUgYWxsIGluc3RhbmNlcyBhbmQgbGlzdGVuZXJzIHZpYSB0aGUgdGFyZ2V0IC0+IHJvb3QgcGF0aC5cblxuICB3aGlsZSAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICB2YXIgX2luc3RhbmNlMiA9IGluc3RhbmNlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UyLnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gX2luc3RhbmNlMi50YWc7IC8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50ICYmIHN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBzdGF0ZU5vZGU7IC8vIGNyZWF0ZUV2ZW50SGFuZGxlIGxpc3RlbmVyc1xuXG5cbiAgICAgIGlmIChyZWFjdEV2ZW50TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVhY3RFdmVudE5hbWUpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGxhc3RIb3N0Q29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIElmIHdlIGFyZSBvbmx5IGFjY3VtdWxhdGluZyBldmVudHMgZm9yIHRoZSB0YXJnZXQsIHRoZW4gd2UgZG9uJ3RcbiAgICAvLyBjb250aW51ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgUmVhY3QgZmliZXIgdHJlZSB0byBmaW5kIG90aGVyXG4gICAgLy8gbGlzdGVuZXJzLlxuXG5cbiAgICBpZiAoYWNjdW11bGF0ZVRhcmdldE9ubHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gLy8gSWYgd2UgYXJlIHByb2Nlc3NpbmcgdGhlIG9uQmVmb3JlQmx1ciBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIHRha2VcblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn0gLy8gV2Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yOlxuLy8gLSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4vLyAtIENoYW5nZUV2ZW50UGx1Z2luXG4vLyAtIFNlbGVjdEV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoZXNlIHBsdWdpbnNcbi8vIGluIHRoZSBidWJibGUgcGhhc2UsIHNvIHdlIG5lZWQgdG8gYWNjdW11bGF0ZSB0d29cbi8vIHBoYXNlIGV2ZW50IGxpc3RlbmVycyAodmlhIGVtdWxhdGlvbikuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArICdDYXB0dXJlJztcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRGaWJlcjsgLy8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBfaW5zdGFuY2UzID0gaW5zdGFuY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTMuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBfaW5zdGFuY2UzLnRhZzsgLy8gSGFuZGxlIGxpc3RlbmVycyB0aGF0IGFyZSBvbiBIb3N0Q29tcG9uZW50cyAoaS5lLiA8ZGl2PilcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgJiYgc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRhcmdldCA9IHN0YXRlTm9kZTtcbiAgICAgIHZhciBjYXB0dXJlTGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZU5hbWUpO1xuXG4gICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZUxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWJibGVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdE5hbWUpO1xuXG4gICAgICBpZiAoYnViYmxlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBidWJibGVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgaWYgKGluc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47IC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcblxuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIG5vZGVBID0gaW5zdEE7XG4gIHZhciBub2RlQiA9IGluc3RCO1xuICB2YXIgZGVwdGhBID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQSA9IG5vZGVBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cblxuICB2YXIgZGVwdGhCID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQiA9IG5vZGVCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH0gLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgZGVwdGhBLS07XG4gIH0gLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBub2RlQiA9IGdldFBhcmVudChub2RlQik7XG4gICAgZGVwdGhCLS07XG4gIH0gLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG5cblxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG5cbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCIHx8IG5vZGVCICE9PSBudWxsICYmIG5vZGVBID09PSBub2RlQi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBub2RlQTtcbiAgICB9XG5cbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgbm9kZUIgPSBnZXRQYXJlbnQobm9kZUIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZXZlbnQsIHRhcmdldCwgY29tbW9uLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50Ll9yZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0O1xuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGlmIChpbnN0YW5jZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgX2luc3RhbmNlNCA9IGluc3RhbmNlLFxuICAgICAgICBhbHRlcm5hdGUgPSBfaW5zdGFuY2U0LmFsdGVybmF0ZSxcbiAgICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlNC5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IF9pbnN0YW5jZTQudGFnO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBzdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGNhcHR1cmVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGJ1YmJsZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIGlmIChidWJibGVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgYnViYmxlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggIT09IDApIHtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufSAvLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEVudGVyTGVhdmVFdmVudFBsdWdpblxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgcHJvY2VzcyB0aGlzIHBsdWdpblxuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzLlxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmVFdmVudCwgZW50ZXJFdmVudCwgZnJvbSwgdG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuXG4gIGlmIChmcm9tICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBsZWF2ZUV2ZW50LCBmcm9tLCBjb21tb24sIGZhbHNlKTtcbiAgfVxuXG4gIGlmICh0byAhPT0gbnVsbCAmJiBlbnRlckV2ZW50ICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBlbnRlckV2ZW50LCB0bywgY29tbW9uLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBjYXB0dXJlKSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgKyBcIl9fXCIgKyAoY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnKTtcbn1cblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MJDEgPSAnX19odG1sJztcbnZhciB3YXJuZWRVbmtub3duVGFncztcbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50O1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZTtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcjtcbnZhciBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nO1xudmFyIG5vcm1hbGl6ZUhUTUw7XG5cbntcbiAgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlLFxuICAgIC8vIEVsZWN0cm9uIHNoaXBzIGEgY3VzdG9tIDx3ZWJ2aWV3PiB0YWcgdG8gZGlzcGxheSBleHRlcm5hbCB3ZWIgY29udGVudCBpblxuICAgIC8vIGFuIGlzb2xhdGVkIGZyYW1lIGFuZCBwcm9jZXNzLlxuICAgIC8vIFRoaXMgdGFnIGlzIG5vdCBwcmVzZW50IGluIG5vbiBFbGVjdHJvbiBlbnZpcm9ubWVudHMgc3VjaCBhcyBKU0RvbSB3aGljaFxuICAgIC8vIGlzIG9mdGVuIHVzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgLy8gQHNlZSBodHRwczovL2VsZWN0cm9uanMub3JnL2RvY3MvYXBpL3dlYnZpZXctdGFnXG4gICAgd2VidmlldzogdHJ1ZVxuICB9O1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywge1xuICAgICAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczogcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNcbiAgICB9KTtcbiAgfTsgLy8gSUUgMTEgcGFyc2VzICYgbm9ybWFsaXplcyB0aGUgc3R5bGUgYXR0cmlidXRlIGFzIG9wcG9zZWQgdG8gb3RoZXJcbiAgLy8gYnJvd3NlcnMuIEl0IGFkZHMgc3BhY2VzIGFuZCBzb3J0cyB0aGUgcHJvcGVydGllcyBpbiBzb21lXG4gIC8vIG5vbi1hbHBoYWJldGljYWwgb3JkZXIuIEhhbmRsaW5nIHRoYXQgd291bGQgcmVxdWlyZSBzb3J0aW5nIENTU1xuICAvLyBwcm9wZXJ0aWVzIGluIHRoZSBjbGllbnQgJiBzZXJ2ZXIgdmVyc2lvbnMgb3IgYXBwbHlpbmdcbiAgLy8gYGV4cGVjdGVkU3R5bGVgIHRvIGEgdGVtcG9yYXJ5IERPTSBub2RlIHRvIHJlYWQgaXRzIGBzdHlsZWAgYXR0cmlidXRlXG4gIC8vIG5vcm1hbGl6ZWQuIFNpbmNlIGl0IG9ubHkgYWZmZWN0cyBJRSwgd2UncmUgc2tpcHBpbmcgc3R5bGUgd2FybmluZ3NcbiAgLy8gaW4gdGhhdCBicm93c2VyIGNvbXBsZXRlbHkgaW4gZmF2b3Igb2YgZG9pbmcgYWxsIHRoYXQgd29yay5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE4MDdcblxuXG4gIGNhbkRpZmZTdHlsZUZvckh5ZHJhdGlvbldhcm5pbmcgPSBjYW5Vc2VET00gJiYgIWRvY3VtZW50LmRvY3VtZW50TW9kZTtcblxuICB3YXJuRm9yUHJvcERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHNlcnZlclZhbHVlLCBjbGllbnRWYWx1ZSkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9PT0gbm9ybWFsaXplZENsaWVudFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Byb3AgYCVzYCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6ICVzIENsaWVudDogJXMnLCBwcm9wTmFtZSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZFNlcnZlclZhbHVlKSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZENsaWVudFZhbHVlKSk7XG4gIH07XG5cbiAgd2FybkZvckV4dHJhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lcykge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuXG4gICAgZXJyb3IoJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsIG5hbWVzKTtcbiAgfTtcblxuICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBgZmFsc2VgLlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcik7XG4gICAgfVxuICB9OyAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cblxuXG4gIG5vcm1hbGl6ZUhUTUwgPSBmdW5jdGlvbiAocGFyZW50LCBodG1sKSB7XG4gICAgLy8gV2UgY291bGQgaGF2ZSBjcmVhdGVkIGEgc2VwYXJhdGUgZG9jdW1lbnQgaGVyZSB0byBhdm9pZFxuICAgIC8vIHJlLWluaXRpYWxpemluZyBjdXN0b20gZWxlbWVudHMgaWYgdGhleSBleGlzdC4gQnV0IHRoaXMgYnJlYWtzXG4gICAgLy8gaG93IDxub3NjcmlwdD4gaXMgYmVpbmcgaGFuZGxlZC4gU28gd2UgdXNlIHRoZSBzYW1lIGRvY3VtZW50LlxuICAgIC8vIFNlZSB0aGUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMTE1Ny5cbiAgICB2YXIgdGVzdEVsZW1lbnQgPSBwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSA/IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHBhcmVudC5uYW1lc3BhY2VVUkksIHBhcmVudC50YWdOYW1lKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59IC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbi8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cblxuXG52YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbnZhciBOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVggPSAvXFx1MDAwMHxcXHVGRkZEL2c7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShtYXJrdXApIHtcbiAge1xuICAgIGNoZWNrSHRtbFN0cmluZ0NvZXJjaW9uKG1hcmt1cCk7XG4gIH1cblxuICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChzZXJ2ZXJUZXh0LCBjbGllbnRUZXh0LCBpc0NvbmN1cnJlbnRNb2RlLCBzaG91bGRXYXJuRGV2KSB7XG4gIHZhciBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuXG4gIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc2hvdWxkV2FybkRldikge1xuICAgIHtcbiAgICAgIGlmICghZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc0NvbmN1cnJlbnRNb2RlICYmIGVuYWJsZUNsaWVudFJlbmRlckZhbGxiYWNrT25UZXh0TWlzbWF0Y2gpIHtcbiAgICAvLyBJbiBjb25jdXJyZW50IHJvb3RzLCB3ZSB0aHJvdyB3aGVuIHRoZXJlJ3MgYSB0ZXh0IG1pc21hdGNoIGFuZCByZXZlcnQgdG9cbiAgICAvLyBjbGllbnQgcmVuZGVyaW5nLCB1cCB0byB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgY29udGVudCBkb2VzIG5vdCBtYXRjaCBzZXJ2ZXItcmVuZGVyZWQgSFRNTC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cblxuXG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuXG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWc7IC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQ7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cblxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpOyAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG5cbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgdHlwZSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuXG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgZG9tRWxlbWVudCA9IGRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLCB7XG4gICAgICAgIGlzOiBwcm9wcy5pc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy8gTm9ybWFsbHkgYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgaW4gYHNldEluaXRpYWxET01Qcm9wZXJ0aWVzYCwgaG93ZXZlciB0aGUgYG11bHRpcGxlYCBhbmQgYHNpemVgXG4gICAgICAvLyBhdHRyaWJ1dGVzIG9uIGBzZWxlY3RgcyBuZWVkcyB0byBiZSBhZGRlZCBiZWZvcmUgYG9wdGlvbmBzIGFyZSBpbnNlcnRlZC5cbiAgICAgIC8vIFRoaXMgcHJldmVudHM6XG4gICAgICAvLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBkb2VzIG5vdCBzY3JvbGwgdG8gdGhlIGNvcnJlY3Qgb3B0aW9uIGJlY2F1c2Ugc2luZ3VsYXJcbiAgICAgIC8vICBgc2VsZWN0YCBlbGVtZW50cyBhdXRvbWF0aWNhbGx5IHBpY2sgdGhlIGZpcnN0IGl0ZW0gIzEzMjIyXG4gICAgICAvLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBzZXQgdGhlIGZpcnN0IGl0ZW0gYXMgc2VsZWN0ZWQgZGVzcGl0ZSB0aGUgYHNpemVgIGF0dHJpYnV0ZSAjMTQyMzlcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjIyXG4gICAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDIzOVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb21FbGVtZW50O1xuXG4gICAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICAgIG5vZGUubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnNpemUpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGEgc2l6ZSBncmVhdGVyIHRoYW4gMSBjYXVzZXMgYSBzZWxlY3QgdG8gYmVoYXZlIGxpa2UgYG11bHRpcGxlPXRydWVgLCB3aGVyZVxuICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSB3aGVuIGEgc2VsZWN0IGluIFwic2luZ2xlIHNlbGVjdGlvbiBtb2RlXCIuXG4gICAgICAgICAgbm9kZS5zaXplID0gcHJvcHMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0eXBlKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBSZWFjdCBjb21wb25lbnQsIHN0YXJ0IGl0cyBuYW1lIHdpdGggJyArICdhbiB1cHBlcmNhc2UgbGV0dGVyLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5mdW5jdGlvbiBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcblxuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgfSAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuXG5cbiAgdmFyIHByb3BzO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2NhbmNlbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2xvc2UnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgbG9hZCBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGFsbCB0aGUgbWVkaWEgZXZlbnRzLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYUV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sIGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBlcnJvciBhbmQgbG9hZCBldmVudHMuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgdG9nZ2xlIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxufSAvLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG5cbiAgICAgIGlmICh0eXBlb2YgbGFzdFByb3BzLm9uQ2xpY2sgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG5leHRQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMpO1xuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG5cbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB2YXIgbGFzdFN0eWxlID0gbGFzdFByb3BzW3Byb3BLZXldO1xuXG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORykgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIDsgZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIGZpYmVyIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYWxsIG90aGVyIGRlbGV0ZWQgcHJvcGVydGllcyB3ZSBhZGQgaXQgdG8gdGhlIHF1ZXVlLiBXZSB1c2VcbiAgICAgIC8vIHRoZSBhbGxvd2VkIHByb3BlcnR5IGxpc3QgaW4gdGhlIGNvbW1pdCBwaGFzZSBpbnN0ZWFkLlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuXG5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlUGF5bG9hZC5wdXNoKHByb3BLZXksIHN0eWxlVXBkYXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dEh0bWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpIDsgZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgLy8gV2UgZWFnZXJseSBsaXN0ZW4gdG8gdGhpcyBldmVuIHRob3VnaCB3ZSBoYXZlbid0IGNvbW1pdHRlZCB5ZXQuXG4gICAgICAgIGlmICggdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wS2V5ID09PSAnb25TY3JvbGwnKSB7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJywgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkICYmIGxhc3RQcm9wICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBwcm9wcyBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuICAgICAgLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgYWxsb3dlZCBwcm9wZXJ0eSBsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAge1xuICAgICAgdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2KHN0eWxlVXBkYXRlcywgbmV4dFByb3BzW1NUWUxFXSk7XG4gICAgfVxuXG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59IC8vIEFwcGx5IHRoZSBkaWZmLlxuXG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTsgLy8gQXBwbHkgdGhlIGRpZmYuXG5cbiAgdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTsgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgIC8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgdXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICghcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0gfHwgbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQsIGlzQ29uY3VycmVudE1vZGUsIHNob3VsZFdhcm5EZXYpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnO1xuICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcztcblxuICB7XG4gICAgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICB9IC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG5cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjYW5jZWwnLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Nsb3NlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICBjYXNlICdlbWJlZCc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgbG9hZCBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgYWxsIHRoZSBtZWRpYSBldmVudHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBlcnJvciBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBlcnJvciBhbmQgbG9hZCBldmVudHMuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSB0b2dnbGUgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcyk7XG5cbiAge1xuICAgIGV4dHJhQXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXR0cmlidXRlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tfaV0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tfaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcblxuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY2hlY2tGb3JVbm1hdGNoZWRUZXh0KGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wLCBpc0NvbmN1cnJlbnRNb2RlLCBzaG91bGRXYXJuRGV2KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChyYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yVW5tYXRjaGVkVGV4dChkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCwgaXNDb25jdXJyZW50TW9kZSwgc2hvdWxkV2FybkRldik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgJycgKyBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICggdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wS2V5ID09PSAnb25TY3JvbGwnKSB7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJywgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFdhcm5EZXYgJiYgdHJ1ZSAmJiAvLyBDb252aW5jZSBGbG93IHdlJ3ZlIGNhbGN1bGF0ZWQgaXQgKGl0J3MgREVWLW9ubHkgaW4gdGhpcyBtZXRob2QuKVxuICAgIHR5cGVvZiBpc0N1c3RvbUNvbXBvbmVudFRhZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlID0gdm9pZCAwO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIGVuYWJsZUN1c3RvbUVsZW1lbnRQcm9wZXJ0eVN1cHBvcnQgPyBudWxsIDogZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpO1xuXG4gICAgICBpZiAocmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddID09PSB0cnVlKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyB8fCAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG5cbiAgICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcblxuICAgICAgICBpZiAoY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgICAgIHZhciBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BLZXkpO1xuXG4gICAgICAgICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBudWxsICYmIHN0YW5kYXJkTmFtZSAhPT0gcHJvcEtleSkge1xuICAgICAgICAgICAgICAvLyBJZiBhbiBTVkcgcHJvcCBpcyBzdXBwbGllZCB3aXRoIGJhZCBjYXNpbmcsIGl0IHdpbGxcbiAgICAgICAgICAgICAgLy8gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBmcm9tIEhUTUwsIGJ1dCB3aWxsIHByb2R1Y2UgYSBtaXNtYXRjaFxuICAgICAgICAgICAgICAvLyAoYW5kIHdvdWxkIGJlIGluY29ycmVjdGx5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQpLlxuICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBhbHJlYWR5IHdhcm4gYWJvdXQgYmFkIGNhc2luZyBlbHNld2hlcmUuXG4gICAgICAgICAgICAgIC8vIFNvIHdlJ2xsIHNraXAgdGhlIG1pc2xlYWRpbmcgZXh0cmEgbWlzbWF0Y2ggd2FybmluZyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgIGlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZyA9IHRydWU7IC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cblxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5cblxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9udFdhcm5DdXN0b21FbGVtZW50ID0gZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCAgO1xuXG4gICAgICAgIGlmICghZG9udFdhcm5DdXN0b21FbGVtZW50ICYmIG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKHNob3VsZFdhcm5EZXYpIHtcbiAgICAgIGlmICggLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcywgdHJ1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0Tm9kZSwgdGV4dCwgaXNDb25jdXJyZW50TW9kZSkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgfVxufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKCkge307XG5cbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG5cbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJywgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcblxuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcblxuICAgIHZhciBpbmZvID0ge1xuICAgICAgdGFnOiB0YWdcbiAgICB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9IC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuXG5cbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG5cblxuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuXG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuXG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcblxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuXG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcblxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG5cbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keScgfHwgdGFnID09PSAnZnJhbWVzZXQnO1xuXG4gICAgICBjYXNlICdmcmFtZXNldCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdmcmFtZSc7XG5cbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9IC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuXG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWVzZXQnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cblxuXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuJDEgPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZFRhZyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRUYWcgPSAnI3RleHQnO1xuICAgIH1cblxuICAgIHZhciBpbnZhbGlkUGFyZW50ID0gaXNUYWdWYWxpZFdpdGhQYXJlbnQoY2hpbGRUYWcsIHBhcmVudFRhZykgPyBudWxsIDogcGFyZW50SW5mbztcbiAgICB2YXIgaW52YWxpZEFuY2VzdG9yID0gaW52YWxpZFBhcmVudCA/IG51bGwgOiBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKGNoaWxkVGFnLCBhbmNlc3RvckluZm8pO1xuICAgIHZhciBpbnZhbGlkUGFyZW50T3JBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgfHwgaW52YWxpZEFuY2VzdG9yO1xuXG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvclRhZyA9IGludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZztcbiAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWc7XG5cbiAgICBpZiAoZGlkV2FybiQxW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybiQxW3dhcm5LZXldID0gdHJ1ZTtcbiAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcblxuICAgIGlmIChjaGlsZFRhZyA9PT0gJyN0ZXh0Jykge1xuICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGRUZXh0KSkge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1doaXRlc3BhY2UgdGV4dCBub2Rlcyc7XG4gICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgIH1cblxuICAgIGlmIChpbnZhbGlkUGFyZW50KSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4sIDx0aGVhZD4gb3IgPHRmb290PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMlcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIGluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcigndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4nLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBTVVNQRU5TRV9TVEFSVF9EQVRBID0gJyQnO1xudmFyIFNVU1BFTlNFX0VORF9EQVRBID0gJy8kJztcbnZhciBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgPSAnJD8nO1xudmFyIFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgPSAnJCEnO1xudmFyIFNUWUxFJDEgPSAnc3R5bGUnO1xudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHR5cGU7XG4gIHZhciBuYW1lc3BhY2U7XG4gIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcblxuICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgIHtcbiAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHZhciBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbiAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIHJldHVybiBhY3RpdmVJbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoY29udGFpbmVySW5mbykge1xuICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHZhciBwYXJlbnROYW1lc3BhY2U7XG5cbiAge1xuICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cblxuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfVxuXG4gIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcblxuICAgIGNhc2UgJ2ltZyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVVcGRhdGUoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcblxuICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgb3duQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUpO1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbn1cbmZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByb3BzKSB7XG4gIHJldHVybiB0eXBlID09PSAndGV4dGFyZWEnIHx8IHR5cGUgPT09ICdub3NjcmlwdCcgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sICE9IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0SW5zdGFuY2UodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKG51bGwsIHRleHQsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gIH1cblxuICB2YXIgdGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0Tm9kZSk7XG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCkge1xuICB2YXIgY3VycmVudEV2ZW50ID0gd2luZG93LmV2ZW50O1xuXG4gIGlmIChjdXJyZW50RXZlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIHJldHVybiBnZXRFdmVudFByaW9yaXR5KGN1cnJlbnRFdmVudC50eXBlKTtcbn1cbi8vIGlmIGEgY29tcG9uZW50IGp1c3QgaW1wb3J0cyBSZWFjdERPTSAoZS5nLiBmb3IgZmluZERPTU5vZGUpLlxuLy8gU29tZSBlbnZpcm9ubWVudHMgbWlnaHQgbm90IGhhdmUgc2V0VGltZW91dCBvciBjbGVhclRpbWVvdXQuXG5cbnZhciBzY2hlZHVsZVRpbWVvdXQgPSB0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IHNldFRpbWVvdXQgOiB1bmRlZmluZWQ7XG52YXIgY2FuY2VsVGltZW91dCA9IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiB1bmRlZmluZWQ7XG52YXIgbm9UaW1lb3V0ID0gLTE7XG52YXIgbG9jYWxQcm9taXNlID0gdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlIDogdW5kZWZpbmVkOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgc2NoZWR1bGVNaWNyb3Rhc2sgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicgPyBxdWV1ZU1pY3JvdGFzayA6IHR5cGVvZiBsb2NhbFByb21pc2UgIT09ICd1bmRlZmluZWQnID8gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHJldHVybiBsb2NhbFByb21pc2UucmVzb2x2ZShudWxsKS50aGVuKGNhbGxiYWNrKS5jYXRjaChoYW5kbGVFcnJvckluTmV4dFRpY2spO1xufSA6IHNjaGVkdWxlVGltZW91dDsgLy8gVE9ETzogRGV0ZXJtaW5lIHRoZSBiZXN0IGZhbGxiYWNrIGhlcmUuXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ySW5OZXh0VGljayhlcnJvcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG59IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGNvbW1pdE1vdW50KGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIC8vIERlc3BpdGUgdGhlIG5hbWluZyB0aGF0IG1pZ2h0IGltcGx5IG90aGVyd2lzZSwgdGhpcyBtZXRob2Qgb25seVxuICAvLyBmaXJlcyBpZiB0aGVyZSBpcyBhbiBgVXBkYXRlYCBlZmZlY3Qgc2NoZWR1bGVkIGR1cmluZyBtb3VudGluZy5cbiAgLy8gVGhpcyBoYXBwZW5zIGlmIGBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbmAgcmV0dXJucyBgdHJ1ZWAgKHdoaWNoIGl0XG4gIC8vIGRvZXMgdG8gaW1wbGVtZW50IHRoZSBgYXV0b0ZvY3VzYCBhdHRyaWJ1dGUgb24gdGhlIGNsaWVudCkuIEJ1dFxuICAvLyB0aGVyZSBhcmUgYWxzbyBvdGhlciBjYXNlcyB3aGVuIHRoaXMgbWlnaHQgaGFwcGVuIChzdWNoIGFzIHBhdGNoaW5nXG4gIC8vIHVwIHRleHQgY29udGVudCBkdXJpbmcgaHlkcmF0aW9uIG1pc21hdGNoKS4gU28gd2UnbGwgY2hlY2sgdGhpcyBhZ2Fpbi5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpZiAobmV3UHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKG5ld1Byb3BzLnNyYykge1xuICAgICAgICAgIGRvbUVsZW1lbnQuc3JjID0gbmV3UHJvcHMuc3JjO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21taXRVcGRhdGUoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpOyAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuXG4gIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgbmV3UHJvcHMpO1xufVxuZnVuY3Rpb24gcmVzZXRUZXh0Q29udGVudChkb21FbGVtZW50KSB7XG4gIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkVG9Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICB2YXIgcGFyZW50Tm9kZTtcblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGNvbnRhaW5lcik7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lcjtcbiAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSAvLyBUaGlzIGNvbnRhaW5lciBtaWdodCBiZSB1c2VkIGZvciBhIHBvcnRhbC5cbiAgLy8gSWYgc29tZXRoaW5nIGluc2lkZSBhIHBvcnRhbCBpcyBjbGlja2VkLCB0aGF0IGNsaWNrIHNob3VsZCBidWJibGVcbiAgLy8gdGhyb3VnaCB0aGUgUmVhY3QgdHJlZS4gSG93ZXZlciwgb24gTW9iaWxlIFNhZmFyaSB0aGUgY2xpY2sgd291bGRcbiAgLy8gbmV2ZXIgYnViYmxlIHRocm91Z2ggdGhlICpET00qIHRyZWUgdW5sZXNzIGFuIGFuY2VzdG9yIHdpdGggb25jbGlja1xuICAvLyBldmVudCBleGlzdHMuIFNvIHdlIHdvdWxkbid0IHNlZSBpdCBhbmQgZGlzcGF0Y2ggaXQuXG4gIC8vIFRoaXMgaXMgd2h5IHdlIGVuc3VyZSB0aGF0IG5vbiBSZWFjdCByb290IGNvbnRhaW5lcnMgaGF2ZSBpbmxpbmUgb25jbGlja1xuICAvLyBkZWZpbmVkLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExOTE4XG5cblxuICB2YXIgcmVhY3RSb290Q29udGFpbmVyID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG5cbiAgaWYgKChyZWFjdFJvb3RDb250YWluZXIgPT09IG51bGwgfHwgcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQpICYmIHBhcmVudE5vZGUub25jbGljayA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50Tm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xufVxuZnVuY3Rpb24gaW5zZXJ0SW5Db250YWluZXJCZWZvcmUoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KHBhcmVudEluc3RhbmNlLCBzdXNwZW5zZUluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gc3VzcGVuc2VJbnN0YW5jZTsgLy8gRGVsZXRlIGFsbCBub2RlcyB3aXRoaW4gdGhpcyBzdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbiAgLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG5cbiAgdmFyIGRlcHRoID0gMDtcblxuICBkbyB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChub2RlKTtcblxuICAgIGlmIChuZXh0Tm9kZSAmJiBuZXh0Tm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5leHROb2RlLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChuZXh0Tm9kZSk7IC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cblxuICAgICAgICAgIHJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSB8fCBkYXRhID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfSB3aGlsZSAobm9kZSk7IC8vIFRPRE86IFdhcm4sIHdlIGRpZG4ndCBmaW5kIHRoZSBlbmQgY29tbWVudCBib3VuZGFyeS5cbiAgLy8gUmV0cnkgaWYgYW55IGV2ZW50IHJlcGxheWluZyB3YXMgYmxvY2tlZCBvbiB0aGlzLlxuXG5cbiAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoY29udGFpbmVyLCBzdXNwZW5zZUluc3RhbmNlKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShjb250YWluZXIucGFyZW50Tm9kZSwgc3VzcGVuc2VJbnN0YW5jZSk7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkoY29udGFpbmVyLCBzdXNwZW5zZUluc3RhbmNlKTtcbiAgfSAvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG5cblxuICByZXRyeUlmQmxvY2tlZE9uKGNvbnRhaW5lcik7XG59XG5mdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgLy8gVE9ETzogRG9lcyB0aGlzIHdvcmsgZm9yIGFsbCBlbGVtZW50IHR5cGVzPyBXaGF0IGFib3V0IE1hdGhNTD8gU2hvdWxkIHdlXG4gIC8vIHBhc3MgaG9zdCBjb250ZXh0IHRvIHRoaXMgbWV0aG9kP1xuICBpbnN0YW5jZSA9IGluc3RhbmNlO1xuICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5zdHlsZTtcblxuICBpZiAodHlwZW9mIHN0eWxlLnNldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gJyc7XG59XG5mdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdmFyIHN0eWxlUHJvcCA9IHByb3BzW1NUWUxFJDFdO1xuICB2YXIgZGlzcGxheSA9IHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlUHJvcCAhPT0gbnVsbCAmJiBzdHlsZVByb3AuaGFzT3duUHJvcGVydHkoJ2Rpc3BsYXknKSA/IHN0eWxlUHJvcC5kaXNwbGF5IDogbnVsbDtcbiAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLCBkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IHRleHQ7XG59XG5mdW5jdGlvbiBjbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgdmFyIGJvZHkgPSBjb250YWluZXIuYm9keTtcblxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGJvZHkudGV4dENvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbn0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSBzdXNwZW5zZSBub2RlLlxuXG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UuZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEE7XG59XG5mdW5jdGlvbiByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeShpbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgaW5zdGFuY2UuX3JlYWN0UmV0cnkgPSBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gZ2V0TmV4dEh5ZHJhdGFibGUobm9kZSkge1xuICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICBmb3IgKDsgbm9kZSAhPSBudWxsOyBub2RlID0gbm9kZS5uZXh0U2libGluZykge1xuICAgIHZhciBub2RlVHlwZSA9IG5vZGUubm9kZVR5cGU7XG5cbiAgICBpZiAobm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAobm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIG5vZGVEYXRhID0gbm9kZS5kYXRhO1xuXG4gICAgICBpZiAobm9kZURhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgfHwgbm9kZURhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgbm9kZURhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVEYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGluc3RhbmNlKSB7XG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZShpbnN0YW5jZS5uZXh0U2libGluZyk7XG59XG5mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSkge1xuICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUocGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZCk7XG59XG5mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIpIHtcbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKHBhcmVudENvbnRhaW5lci5maXJzdENoaWxkKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSkge1xuICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUocGFyZW50SW5zdGFuY2UubmV4dFNpYmxpbmcpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgc2hvdWxkV2FybkRldikge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7IC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAvLyBnZXQgYXR0YWNoZWQuXG5cbiAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICB2YXIgcGFyZW50TmFtZXNwYWNlO1xuXG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH0gLy8gVE9ETzogVGVtcG9yYXJ5IGhhY2sgdG8gY2hlY2sgaWYgd2UncmUgaW4gYSBjb25jdXJyZW50IHJvb3QuIFdlIGNhbiBkZWxldGVcbiAgLy8gd2hlbiB0aGUgbGVnYWN5IHJvb3QgQVBJIGlzIHJlbW92ZWQuXG5cblxuICB2YXIgaXNDb25jdXJyZW50TW9kZSA9IChpbnRlcm5hbEluc3RhbmNlSGFuZGxlLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaXNDb25jdXJyZW50TW9kZSwgc2hvdWxkV2FybkRldik7XG59XG5mdW5jdGlvbiBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgc2hvdWxkV2FybkRldikge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0SW5zdGFuY2UpOyAvLyBUT0RPOiBUZW1wb3JhcnkgaGFjayB0byBjaGVjayBpZiB3ZSdyZSBpbiBhIGNvbmN1cnJlbnQgcm9vdC4gV2UgY2FuIGRlbGV0ZVxuICAvLyB3aGVuIHRoZSBsZWdhY3kgcm9vdCBBUEkgaXMgcmVtb3ZlZC5cblxuICB2YXIgaXNDb25jdXJyZW50TW9kZSA9IChpbnRlcm5hbEluc3RhbmNlSGFuZGxlLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSBzdXNwZW5zZUluc3RhbmNlLm5leHRTaWJsaW5nOyAvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAvLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuICAvLyBkZWVwIHdlIGFyZSBhbmQgb25seSBicmVhayBvdXQgd2hlbiB3ZSdyZSBiYWNrIG9uIHRvcC5cblxuICB2YXIgZGVwdGggPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGRhdGEgPSBub2RlLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSB8fCBkYXRhID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9IC8vIFRPRE86IFdhcm4sIHdlIGRpZG4ndCBmaW5kIHRoZSBlbmQgY29tbWVudCBib3VuZGFyeS5cblxuXG4gIHJldHVybiBudWxsO1xufSAvLyBSZXR1cm5zIHRoZSBTdXNwZW5zZUluc3RhbmNlIGlmIHRoaXMgbm9kZSBpcyBhIGRpcmVjdCBjaGlsZCBvZiBhXG4vLyBTdXNwZW5zZUluc3RhbmNlLiBJLmUuIGlmIGl0cyBwcmV2aW91cyBzaWJsaW5nIGlzIGEgQ29tbWVudCB3aXRoXG4vLyBTVVNQRU5TRV94X1NUQVJUX0RBVEEuIE90aGVyd2lzZSwgbnVsbC5cblxuZnVuY3Rpb24gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXRJbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IHRhcmdldEluc3RhbmNlLnByZXZpb3VzU2libGluZzsgLy8gU2tpcCBwYXN0IGFsbCBub2RlcyB3aXRoaW4gdGhpcyBzdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbiAgLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG5cbiAgdmFyIGRlcHRoID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBkYXRhID0gbm9kZS5kYXRhO1xuXG4gICAgICBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSB8fCBkYXRhID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSkge1xuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb21taXRIeWRyYXRlZENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgLy8gUmV0cnkgaWYgYW55IGV2ZW50IHJlcGxheWluZyB3YXMgYmxvY2tlZCBvbiB0aGlzLlxuICByZXRyeUlmQmxvY2tlZE9uKGNvbnRhaW5lcik7XG59XG5mdW5jdGlvbiBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICAvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG4gIHJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhwYXJlbnRUeXBlKSB7XG4gIHJldHVybiBwYXJlbnRUeXBlICE9PSAnaGVhZCcgJiYgcGFyZW50VHlwZSAhPT0gJ2JvZHknO1xufVxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCwgaXNDb25jdXJyZW50TW9kZSkge1xuICB2YXIgc2hvdWxkV2FybkRldiA9IHRydWU7XG4gIGNoZWNrRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlLCB0ZXh0LCBpc0NvbmN1cnJlbnRNb2RlLCBzaG91bGRXYXJuRGV2KTtcbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQsIGlzQ29uY3VycmVudE1vZGUpIHtcbiAgaWYgKHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgdmFyIHNob3VsZFdhcm5EZXYgPSB0cnVlO1xuICAgIGNoZWNrRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlLCB0ZXh0LCBpc0NvbmN1cnJlbnRNb2RlLCBzaG91bGRXYXJuRGV2KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkgOyBlbHNlIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWROb3RIeWRyYXRlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZTogT25seSBFbGVtZW50IG9yIERvY3VtZW50IGNhbiBiZSBwYXJlbnQgbm9kZXMuXG4gICAgdmFyIHBhcmVudE5vZGUgPSBwYXJlbnRJbnN0YW5jZS5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Tm9kZSwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSA7IGVsc2Uge1xuICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudE5vZGUsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIGluc3RhbmNlLCBpc0NvbmN1cnJlbnRNb2RlKSB7XG4gIHtcbiAgICBpZiAoaXNDb25jdXJyZW50TW9kZSB8fCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSA7IGVsc2Uge1xuICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWU6IE9ubHkgRWxlbWVudCBvciBEb2N1bWVudCBjYW4gYmUgcGFyZW50IG5vZGVzLlxuICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50SW5zdGFuY2UucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSAhPT0gbnVsbCkgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudE5vZGUsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UsIHRleHQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWU6IE9ubHkgRWxlbWVudCBvciBEb2N1bWVudCBjYW4gYmUgcGFyZW50IG5vZGVzLlxuICAgIHZhciBwYXJlbnROb2RlID0gcGFyZW50SW5zdGFuY2UucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSAhPT0gbnVsbCkgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudE5vZGUsIHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMsIGlzQ29uY3VycmVudE1vZGUpIHtcbiAge1xuICAgIGlmIChpc0NvbmN1cnJlbnRNb2RlIHx8IHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0LCBpc0NvbmN1cnJlbnRNb2RlKSB7XG4gIHtcbiAgICBpZiAoaXNDb25jdXJyZW50TW9kZSB8fCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9ySHlkcmF0aW5nQ29udGFpbmVyKHBhcmVudENvbnRhaW5lcikge1xuICB7XG4gICAgLy8gVE9ETzogVGhpcyBnZXRzIGxvZ2dlZCBieSBvblJlY292ZXJhYmxlRXJyb3IsIHRvbywgc28gd2Ugc2hvdWxkIGJlXG4gICAgLy8gYWJsZSB0byByZW1vdmUgaXQuXG4gICAgZXJyb3IoJ0FuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24uIFRoZSBzZXJ2ZXIgSFRNTCB3YXMgcmVwbGFjZWQgd2l0aCBjbGllbnQgY29udGVudCBpbiA8JXM+LicsIHBhcmVudENvbnRhaW5lci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVBvcnRhbE1vdW50KHBvcnRhbEluc3RhbmNlKSB7XG4gIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHBvcnRhbEluc3RhbmNlKTtcbn1cblxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEZpYmVyJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxQcm9wc0tleSA9ICdfX3JlYWN0UHJvcHMkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5ID0gJ19fcmVhY3RDb250YWluZXIkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSAnX19yZWFjdEV2ZW50cyQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyTGlzdGVuZXJzS2V5ID0gJ19fcmVhY3RMaXN0ZW5lcnMkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbEV2ZW50SGFuZGxlc1NldEtleSA9ICdfX3JlYWN0SGFuZGxlcyQnICsgcmFuZG9tS2V5O1xuZnVuY3Rpb24gZGV0YWNoRGVsZXRlZEluc3RhbmNlKG5vZGUpIHtcbiAgLy8gVE9ETzogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBvbiBob3N0IGNvbXBvbmVudHMuIEkgZG9uJ3QgdGhpbmsgYWxsIG9mXG4gIC8vIHRoZXNlIGZpZWxkcyBhcmUgcmVsZXZhbnQuXG4gIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbFByb3BzS2V5XTtcbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XTtcbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXldO1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlc1NldEtleV07XG59XG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5mdW5jdGlvbiBtYXJrQ29udGFpbmVyQXNSb290KGhvc3RSb290LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBob3N0Um9vdDtcbn1cbmZ1bmN0aW9uIHVubWFya0NvbnRhaW5lckFzUm9vdChub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBudWxsO1xufVxuZnVuY3Rpb24gaXNDb250YWluZXJNYXJrZWRBc1Jvb3Qobm9kZSkge1xuICByZXR1cm4gISFub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO1xufSAvLyBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgSG9zdENvbXBvbmVudCBvciBIb3N0VGV4dCBmaWJlciBhbmNlc3Rvci5cbi8vIElmIHRoZSB0YXJnZXQgbm9kZSBpcyBwYXJ0IG9mIGEgaHlkcmF0ZWQgb3Igbm90IHlldCByZW5kZXJlZCBzdWJ0cmVlLCB0aGVuXG4vLyB0aGlzIG1heSBhbHNvIHJldHVybiBhIFN1c3BlbnNlQ29tcG9uZW50IG9yIEhvc3RSb290IHRvIGluZGljYXRlIHRoYXQuXG4vLyBDb25jZXB0dWFsbHkgdGhlIEhvc3RSb290IGZpYmVyIGlzIGEgY2hpbGQgb2YgdGhlIENvbnRhaW5lciBub2RlLiBTbyBpZiB5b3Vcbi8vIHBhc3MgdGhlIENvbnRhaW5lciBub2RlIGFzIHRoZSB0YXJnZXROb2RlLCB5b3Ugd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHRoZVxuLy8gSG9zdFJvb3QgYmFjay4gVG8gZ2V0IHRvIHRoZSBIb3N0Um9vdCwgeW91IG5lZWQgdG8gcGFzcyBhIGNoaWxkIG9mIGl0LlxuLy8gVGhlIHNhbWUgdGhpbmcgYXBwbGllcyB0byBTdXNwZW5zZSBib3VuZGFyaWVzLlxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gdGFyZ2V0Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcblxuICBpZiAodGFyZ2V0SW5zdCkge1xuICAgIC8vIERvbid0IHJldHVybiBIb3N0Um9vdCBvciBTdXNwZW5zZUNvbXBvbmVudCBoZXJlLlxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9IC8vIElmIHRoZSBkaXJlY3QgZXZlbnQgdGFyZ2V0IGlzbid0IGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUsIHdlIG5lZWQgdG8gbG9va1xuICAvLyB0byBzZWUgaWYgb25lIG9mIGl0cyBwYXJlbnRzIGlzIGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUuXG5cblxuICB2YXIgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgIC8vIFdlJ2xsIGNoZWNrIGlmIHRoaXMgaXMgYSBjb250YWluZXIgcm9vdCB0aGF0IGNvdWxkIGluY2x1ZGVcbiAgICAvLyBSZWFjdCBub2RlcyBpbiB0aGUgZnV0dXJlLiBXZSBuZWVkIHRvIGNoZWNrIHRoaXMgZmlyc3QgYmVjYXVzZVxuICAgIC8vIGlmIHdlJ3JlIGEgY2hpbGQgb2YgYSBkZWh5ZHJhdGVkIGNvbnRhaW5lciwgd2UgbmVlZCB0byBmaXJzdFxuICAgIC8vIGZpbmQgdGhhdCBpbm5lciBjb250YWluZXIgYmVmb3JlIG1vdmluZyBvbiB0byBmaW5kaW5nIHRoZSBwYXJlbnRcbiAgICAvLyBpbnN0YW5jZS4gTm90ZSB0aGF0IHdlIGRvbid0IGNoZWNrIHRoaXMgZmllbGQgb24gIHRoZSB0YXJnZXROb2RlXG4gICAgLy8gaXRzZWxmIGJlY2F1c2UgdGhlIGZpYmVycyBhcmUgY29uY2VwdHVhbGx5IGJldHdlZW4gdGhlIGNvbnRhaW5lclxuICAgIC8vIG5vZGUgYW5kIHRoZSBmaXJzdCBjaGlsZC4gSXQgaXNuJ3Qgc3Vycm91bmRpbmcgdGhlIGNvbnRhaW5lciBub2RlLlxuICAgIC8vIElmIGl0J3Mgbm90IGEgY29udGFpbmVyLCB3ZSBjaGVjayBpZiBpdCdzIGFuIGluc3RhbmNlLlxuICAgIHRhcmdldEluc3QgPSBwYXJlbnROb2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldIHx8IHBhcmVudE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgICBpZiAodGFyZ2V0SW5zdCkge1xuICAgICAgLy8gU2luY2UgdGhpcyB3YXNuJ3QgdGhlIGRpcmVjdCB0YXJnZXQgb2YgdGhlIGV2ZW50LCB3ZSBtaWdodCBoYXZlXG4gICAgICAvLyBzdGVwcGVkIHBhc3QgZGVoeWRyYXRlZCBET00gbm9kZXMgdG8gZ2V0IGhlcmUuIEhvd2V2ZXIgdGhleSBjb3VsZFxuICAgICAgLy8gYWxzbyBoYXZlIGJlZW4gbm9uLVJlYWN0IG5vZGVzLiBXZSBuZWVkIHRvIGFuc3dlciB3aGljaCBvbmUuXG4gICAgICAvLyBJZiB3ZSB0aGUgaW5zdGFuY2UgZG9lc24ndCBoYXZlIGFueSBjaGlsZHJlbiwgdGhlbiB0aGVyZSBjYW4ndCBiZVxuICAgICAgLy8gYSBuZXN0ZWQgc3VzcGVuc2UgYm91bmRhcnkgd2l0aGluIGl0LiBTbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBmYXN0XG4gICAgICAvLyBiYWlsb3V0LiBNb3N0IG9mIHRoZSB0aW1lLCB3aGVuIHBlb3BsZSBhZGQgbm9uLVJlYWN0IGNoaWxkcmVuIHRvXG4gICAgICAvLyB0aGUgdHJlZSwgaXQgaXMgdXNpbmcgYSByZWYgdG8gYSBjaGlsZC1sZXNzIERPTSBub2RlLlxuICAgICAgLy8gTm9ybWFsbHkgd2UnZCBvbmx5IG5lZWQgdG8gY2hlY2sgb25lIG9mIHRoZSBmaWJlcnMgYmVjYXVzZSBpZiBpdFxuICAgICAgLy8gaGFzIGV2ZXIgZ29uZSBmcm9tIGhhdmluZyBjaGlsZHJlbiB0byBkZWxldGluZyB0aGVtIG9yIHZpY2UgdmVyc2FcbiAgICAgIC8vIGl0IHdvdWxkIGhhdmUgZGVsZXRlZCB0aGUgZGVoeWRyYXRlZCBib3VuZGFyeSBuZXN0ZWQgaW5zaWRlIGFscmVhZHkuXG4gICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGUgSG9zdFJvb3Qgc3RhcnRzIG91dCB3aXRoIGFuIGFsdGVybmF0ZSBpdCBtaWdodFxuICAgICAgLy8gaGF2ZSBvbmUgb24gdGhlIGFsdGVybmF0ZSBzbyB3ZSBuZWVkIHRvIGNoZWNrIGluIGNhc2UgdGhpcyB3YXMgYVxuICAgICAgLy8gcm9vdC5cbiAgICAgIHZhciBhbHRlcm5hdGUgPSB0YXJnZXRJbnN0LmFsdGVybmF0ZTtcblxuICAgICAgaWYgKHRhcmdldEluc3QuY2hpbGQgIT09IG51bGwgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBOZXh0IHdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGUgbm9kZSB0aGF0IHNraXBwZWQgcGFzdCBpc1xuICAgICAgICAvLyBuZXN0ZWQgd2l0aGluIGEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbmQgaWYgc28sIHdoaWNoIG9uZS5cbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuXG4gICAgICAgIHdoaWxlIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgZm91bmQgYSBzdXNwZW5zZSBpbnN0YW5jZS4gVGhhdCBtZWFucyB0aGF0IHdlIGhhdmVuJ3RcbiAgICAgICAgICAvLyBoeWRyYXRlZCBpdCB5ZXQuIEV2ZW4gdGhvdWdoIHdlIGxlYXZlIHRoZSBjb21tZW50cyBpbiB0aGVcbiAgICAgICAgICAvLyBET00gYWZ0ZXIgaHlkcmF0aW5nLCBhbmQgdGhlcmUgYXJlIGJvdW5kYXJpZXMgaW4gdGhlIERPTVxuICAgICAgICAgIC8vIHRoYXQgY291bGQgYWxyZWFkeSBiZSBoeWRyYXRlZCwgd2Ugd291bGRuJ3QgaGF2ZSBmb3VuZCB0aGVtXG4gICAgICAgICAgLy8gdGhyb3VnaCB0aGlzIHBhc3Mgc2luY2UgaWYgdGhlIHRhcmdldCBpcyBoeWRyYXRlZCBpdCB3b3VsZFxuICAgICAgICAgIC8vIGhhdmUgaGFkIGFuIGludGVybmFsSW5zdGFuY2VLZXkgb24gaXQuXG4gICAgICAgICAgLy8gTGV0J3MgZ2V0IHRoZSBmaWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIFN1c3BlbnNlQ29tcG9uZW50XG4gICAgICAgICAgLy8gYXMgdGhlIGRlZXBlc3QgaW5zdGFuY2UuXG4gICAgICAgICAgdmFyIHRhcmdldFN1c3BlbnNlSW5zdCA9IHN1c3BlbnNlSW5zdGFuY2VbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgICAgICAgICBpZiAodGFyZ2V0U3VzcGVuc2VJbnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0U3VzcGVuc2VJbnN0O1xuICAgICAgICAgIH0gLy8gSWYgd2UgZG9uJ3QgZmluZCBhIEZpYmVyIG9uIHRoZSBjb21tZW50LCBpdCBtaWdodCBiZSBiZWNhdXNlXG4gICAgICAgICAgLy8gd2UgaGF2ZW4ndCBnb3R0ZW4gdG8gaHlkcmF0ZSBpdCB5ZXQuIFRoZXJlIG1pZ2h0IHN0aWxsIGJlIGFcbiAgICAgICAgICAvLyBwYXJlbnQgYm91bmRhcnkgdGhhdCBoYXNuJ3QgYWJvdmUgdGhpcyBvbmUgc28gd2UgbmVlZCB0byBmaW5kXG4gICAgICAgICAgLy8gdGhlIG91dGVyIG1vc3QgdGhhdCBpcyBrbm93bi5cblxuXG4gICAgICAgICAgc3VzcGVuc2VJbnN0YW5jZSA9IGdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7IC8vIElmIHdlIGRvbid0IGZpbmQgb25lLCB0aGVuIHRoYXQgc2hvdWxkIG1lYW4gdGhhdCB0aGUgcGFyZW50XG4gICAgICAgICAgLy8gaG9zdCBjb21wb25lbnQgYWxzbyBoYXNuJ3QgaHlkcmF0ZWQgeWV0LiBXZSBjYW4gcmV0dXJuIGl0XG4gICAgICAgICAgLy8gYmVsb3cgc2luY2UgaXQgd2lsbCBiYWlsIG91dCBvbiB0aGUgaXNNb3VudGVkIGNoZWNrIGxhdGVyLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIHRhcmdldE5vZGUgPSBwYXJlbnROb2RlO1xuICAgIHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8IG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV07XG5cbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0IHx8IGluc3QudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH0gLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO1xufVxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzKG5vZGUsIHByb3BzKSB7XG4gIG5vZGVbaW50ZXJuYWxQcm9wc0tleV0gPSBwcm9wcztcbn1cbmZ1bmN0aW9uIGdldEV2ZW50TGlzdGVuZXJTZXQobm9kZSkge1xuICB2YXIgZWxlbWVudExpc3RlbmVyU2V0ID0gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldO1xuXG4gIGlmIChlbGVtZW50TGlzdGVuZXJTZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVsZW1lbnRMaXN0ZW5lclNldCA9IG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50TGlzdGVuZXJTZXQ7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcbnZhciBmaWJlclN0YWNrO1xuXG57XG4gIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn0gLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cblxuXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7IC8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyKSB7XG4gIHtcbiAgICBpZiAoZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyICYmIGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAgIC8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgfSAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAgIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcbiAgICAgIGNoZWNrUHJvcFR5cGVzKGNvbnRleHRUeXBlcywgY29udGV4dCwgJ2NvbnRleHQnLCBuYW1lKTtcbiAgICB9IC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYmVmb3JlIHRoZSBjbGFzcyBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIHNvIGNoZWNrIGZvciBpbnN0YW5jZS5cblxuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHtcbiAgICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKHR5cGUpIHtcbiAge1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IHR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG4gICAgcmV0dXJuIGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dChmaWJlcikge1xuICB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAge1xuICAgIGlmIChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZW1wdHlDb250ZXh0T2JqZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGV4dCBmb3VuZCBvbiBzdGFjay4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCB0eXBlLCBwYXJlbnRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlczsgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgICAvLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcblxuICAgIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICBpZiAoIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAgIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAgIC8vIGFuZCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBsYXRlciB3aGVuIGludmFsaWRhdGluZyB0aGUgY29udGV4dC5cblxuICAgIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5Q29udGV4dE9iamVjdDsgLy8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuICAgIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuXG4gICAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0eXBlLCBkaWRDaGFuZ2UpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAgIC8vIFRoaXMgYXZvaWRzIHVubmVjZXNzYXJpbHkgcmVjb21wdXRpbmcgbWVtb2l6ZWQgdmFsdWVzLlxuICAgICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcmV2aW91c0NvbnRleHQpO1xuICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBtZXJnZWRDb250ZXh0OyAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuXG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpOyAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cblxuICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lcmdlZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcikge1xuICB7XG4gICAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gICAgLy8gbWFrZXMgc2Vuc2UgZWxzZXdoZXJlXG4gICAgaWYgKCFpc0ZpYmVyTW91bnRlZChmaWJlcikgfHwgZmliZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBub2RlLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuXG52YXIgTGVnYWN5Um9vdCA9IDA7XG52YXIgQ29uY3VycmVudFJvb3QgPSAxO1xuXG52YXIgc3luY1F1ZXVlID0gbnVsbDtcbnZhciBpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MgPSBmYWxzZTtcbnZhciBpc0ZsdXNoaW5nU3luY1F1ZXVlID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZVN5bmNDYWxsYmFjayhjYWxsYmFjaykge1xuICAvLyBQdXNoIHRoaXMgY2FsbGJhY2sgaW50byBhbiBpbnRlcm5hbCBxdWV1ZS4gV2UnbGwgZmx1c2ggdGhlc2UgZWl0aGVyIGluXG4gIC8vIHRoZSBuZXh0IHRpY2ssIG9yIGVhcmxpZXIgaWYgc29tZXRoaW5nIGNhbGxzIGBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlYC5cbiAgaWYgKHN5bmNRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHN5bmNRdWV1ZSA9IFtjYWxsYmFja107XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuICAgIC8vIHdlIGFscmVhZHkgc2NoZWR1bGVkIG9uZSB3aGVuIHdlIGNyZWF0ZWQgdGhlIHF1ZXVlLlxuICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVMZWdhY3lTeW5jQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gdHJ1ZTtcbiAgc2NoZWR1bGVTeW5jQ2FsbGJhY2soY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpIHtcbiAgLy8gT25seSBmbHVzaGVzIHRoZSBxdWV1ZSBpZiB0aGVyZSdzIGEgbGVnYWN5IHN5bmMgY2FsbGJhY2sgc2NoZWR1bGVkLlxuICAvLyBUT0RPOiBUaGVyZSdzIG9ubHkgYSBzaW5nbGUgdHlwZSBvZiBjYWxsYmFjazogcGVyZm9ybVN5bmNPbldvcmtPblJvb3QuIFNvXG4gIC8vIGl0IG1pZ2h0IG1ha2UgbW9yZSBzZW5zZSBmb3IgdGhlIHF1ZXVlIHRvIGJlIGEgbGlzdCBvZiByb290cyBpbnN0ZWFkIG9mIGFcbiAgLy8gbGlzdCBvZiBnZW5lcmljIGNhbGxiYWNrcy4gVGhlbiB3ZSBjYW4gaGF2ZSB0d286IG9uZSBmb3IgbGVnYWN5IHJvb3RzLCBvbmVcbiAgLy8gZm9yIGNvbmN1cnJlbnQgcm9vdHMuIEFuZCB0aGlzIG1ldGhvZCB3b3VsZCBvbmx5IGZsdXNoIHRoZSBsZWdhY3kgb25lcy5cbiAgaWYgKGluY2x1ZGVzTGVnYWN5U3luY0NhbGxiYWNrcykge1xuICAgIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja3MoKSB7XG4gIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmNlLlxuICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSB0cnVlO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc1N5bmMgPSB0cnVlO1xuICAgICAgdmFyIHF1ZXVlID0gc3luY1F1ZXVlOyAvLyBUT0RPOiBJcyB0aGlzIG5lY2Vzc2FyeSBhbnltb3JlPyBUaGUgb25seSB1c2VyIGNvZGUgdGhhdCBydW5zIGluIHRoaXNcbiAgICAgIC8vIHF1ZXVlIGlzIGluIHRoZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlcy5cblxuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG5cbiAgICAgIGZvciAoOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soaXNTeW5jKTtcbiAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgfVxuXG4gICAgICBzeW5jUXVldWUgPSBudWxsO1xuICAgICAgaW5jbHVkZXNMZWdhY3lTeW5jQ2FsbGJhY2tzID0gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElmIHNvbWV0aGluZyB0aHJvd3MsIGxlYXZlIHRoZSByZW1haW5pbmcgY2FsbGJhY2tzIG9uIHRoZSBxdWV1ZS5cbiAgICAgIGlmIChzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgc3luY1F1ZXVlID0gc3luY1F1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgIH0gLy8gUmVzdW1lIGZsdXNoaW5nIGluIHRoZSBuZXh0IHRpY2tcblxuXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5LCBmbHVzaFN5bmNDYWxsYmFja3MpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZVByaW9yaXR5KTtcbiAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbnZhciBOb1RyYW5zaXRpb24gPSBudWxsO1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkge1xuICByZXR1cm4gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xufVxuXG52YXIgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgPSB7XG4gIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICByZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fVxufTtcblxue1xuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVTdHJpY3RSb290ID0gbnVsbDtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF5YmVTdHJpY3RSb290O1xuICB9O1xuXG4gIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTtcbiAgfTtcblxuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICAvLyBEZWR1cGUgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgZG8gYW4gaW5pdGlhbCBwYXNzIHRvIGdhdGhlciBjb21wb25lbnQgbmFtZXNcbiAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH0gLy8gRmluYWxseSwgd2UgZmx1c2ggYWxsIHRoZSB3YXJuaW5nc1xuICAgIC8vIFVOU0FGRV8gb25lcyBiZWZvcmUgdGhlIGRlcHJlY2F0ZWQgb25lcywgc2luY2UgdGhleSdsbCBiZSAnbG91ZGVyJ1xuXG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIgKyAncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMyKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczQgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgXCIgKyAnY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczQpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM1ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM1KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcblxuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5cblxuICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG4gICAgaWYgKGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGwgfHwgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh3YXJuaW5nc0ZvclJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3QgPSBbXTtcbiAgICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIGlmIChmaWJlckFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXTtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpcnN0RmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZS4nICsgJ1xcblxcblRoZSBvbGQgQVBJIHdpbGwgYmUgc3VwcG9ydGVkIGluIGFsbCAxNi54IHJlbGVhc2VzLCBidXQgYXBwbGljYXRpb25zICcgKyAndXNpbmcgaXQgc2hvdWxkIG1pZ3JhdGUgdG8gdGhlIG5ldyB2ZXJzaW9uLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvbGVnYWN5LWNvbnRleHQnLCBzb3J0ZWROYW1lcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuICBpZiAoQ29tcG9uZW50ICYmIENvbXBvbmVudC5kZWZhdWx0UHJvcHMpIHtcbiAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHMuIFRha2VuIGZyb20gUmVhY3RFbGVtZW50XG4gICAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSBDb21wb25lbnQuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICByZXR1cm4gYmFzZVByb3BzO1xufVxuXG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG52YXIgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcbnZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuICAvLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xuXG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCwgcHJvdmlkZXJGaWJlcikge1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcblxuICB7XG4gICAge1xuICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgLy8gVXBkYXRlIHRoZSBjaGlsZCBsYW5lcyBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nIHRoZSBhbHRlcm5hdGVzLlxuICB2YXIgbm9kZSA9IHBhcmVudDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcblxuICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBub2RlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmICFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChub2RlICE9PSBwcm9wYWdhdGlvblJvb3QpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcblxuICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7IC8vIFZpc2l0IHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAvLyBNYXRjaCEgU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoaXMgZmliZXIuXG4gICAgICAgICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgZm9yY2UgdXBkYXRlIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTsgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgLy8gSW5saW5lZCBgZW5xdWV1ZVVwZGF0ZWAgdG8gcmVtb3ZlIGludGVybGVhdmVkIHVwZGF0ZSBjaGVja1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICAgICAgICAgIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBpcyBpbiB0aGlzIHN1YnRyZWUsIHdlIGRvbid0IGtub3dcbiAgICAgIC8vIGlmIGl0IHdpbGwgaGF2ZSBhbnkgY29udGV4dCBjb25zdW1lcnMgaW4gaXQuIFRoZSBiZXN0IHdlIGNhbiBkbyBpc1xuICAgICAgLy8gbWFyayBpdCBhcyBoYXZpbmcgdXBkYXRlcy5cbiAgICAgIHZhciBwYXJlbnRTdXNwZW5zZSA9IGZpYmVyLnJldHVybjtcblxuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2UganVzdCBjYW1lIGZyb20gYSBwYXJlbnQgc28gd2UgbXVzdCBoYXZlIGhhZCBhIHBhcmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50U3VzcGVuc2UubGFuZXMgPSBtZXJnZUxhbmVzKHBhcmVudFN1c3BlbnNlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgX2FsdGVybmF0ZSA9IHBhcmVudFN1c3BlbnNlLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgX2FsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoX2FsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgcGFzc2luZyB0aGlzIGZpYmVyIGFzIHRoZSBwYXJlbnRcbiAgICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB0byBzY2hlZHVsZSB0aGlzIGZpYmVyIGFzIGhhdmluZyB3b3JrXG4gICAgICAvLyBvbiBpdHMgY2hpbGRyZW4uIFdlJ2xsIHVzZSB0aGUgY2hpbGRMYW5lcyBvblxuICAgICAgLy8gdGhpcyBmaWJlciB0byBpbmRpY2F0ZSB0aGF0IGEgY29udGV4dCBoYXMgY2hhbmdlZC5cblxuXG4gICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKHBhcmVudFN1c3BlbnNlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuc2libGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhdmVyc2UgZG93bi5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgIH1cblxuICAgIGlmIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXI7XG5cbiAgICAgIHdoaWxlIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXh0RmliZXIuc2libGluZztcblxuICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIHNpYmxpbmcgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICAgICAgc2libGluZy5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIG5leHRGaWJlciA9IHNpYmxpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gTm8gbW9yZSBzaWJsaW5ncy4gVHJhdmVyc2UgdXAuXG5cblxuICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcztcblxuICBpZiAoZGVwZW5kZW5jaWVzICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgdmFyIGZpcnN0Q29udGV4dCA9IGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG5cbiAgICAgIGlmIChmaXJzdENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUoZGVwZW5kZW5jaWVzLmxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgICAvLyBDb250ZXh0IGxpc3QgaGFzIGEgcGVuZGluZyB1cGRhdGUuIE1hcmsgdGhhdCB0aGlzIGZpYmVyIHBlcmZvcm1lZCB3b3JrLlxuICAgICAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICAgIH0gLy8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICAvLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuICAgIC8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG4gICAgaWYgKGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsdWUgPSAgY29udGV4dC5fY3VycmVudFZhbHVlIDtcblxuICBpZiAobGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID09PSBjb250ZXh0KSA7IGVsc2Uge1xuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBtZW1vaXplZFZhbHVlOiB2YWx1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgICB9IC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRlcGVuZGVuY3kgZm9yIHRoaXMgY29tcG9uZW50LiBDcmVhdGUgYSBuZXcgbGlzdC5cblxuXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0SXRlbTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgICAgIGZpcnN0Q29udGV4dDogY29udGV4dEl0ZW1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCBhIG5ldyBjb250ZXh0IGl0ZW0uXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBsYXN0Q29udGV4dERlcGVuZGVuY3kubmV4dCA9IGNvbnRleHRJdGVtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gQW4gYXJyYXkgb2YgYWxsIHVwZGF0ZSBxdWV1ZXMgdGhhdCByZWNlaXZlZCB1cGRhdGVzIGR1cmluZyB0aGUgY3VycmVudFxuLy8gcmVuZGVyLiBXaGVuIHRoaXMgcmVuZGVyIGV4aXRzLCBlaXRoZXIgYmVjYXVzZSBpdCBmaW5pc2hlcyBvciBiZWNhdXNlIGl0IGlzXG4vLyBpbnRlcnJ1cHRlZCwgdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgd2lsbCBiZSB0cmFuc2ZlcnJlZCBvbnRvIHRoZSBtYWluIHBhcnRcbi8vIG9mIHRoZSBxdWV1ZS5cbnZhciBpbnRlcmxlYXZlZFF1ZXVlcyA9IG51bGw7XG5mdW5jdGlvbiBwdXNoSW50ZXJsZWF2ZWRRdWV1ZShxdWV1ZSkge1xuICBpZiAoaW50ZXJsZWF2ZWRRdWV1ZXMgPT09IG51bGwpIHtcbiAgICBpbnRlcmxlYXZlZFF1ZXVlcyA9IFtxdWV1ZV07XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJsZWF2ZWRRdWV1ZXMucHVzaChxdWV1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0ludGVybGVhdmVkVXBkYXRlcygpIHtcbiAgcmV0dXJuIGludGVybGVhdmVkUXVldWVzICE9PSBudWxsO1xufVxuZnVuY3Rpb24gZW5xdWV1ZUludGVybGVhdmVkVXBkYXRlcygpIHtcbiAgLy8gVHJhbnNmZXIgdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgb250byB0aGUgbWFpbiBxdWV1ZS4gRWFjaCBxdWV1ZSBoYXMgYVxuICAvLyBgcGVuZGluZ2AgZmllbGQgYW5kIGFuIGBpbnRlcmxlYXZlZGAgZmllbGQuIFdoZW4gdGhleSBhcmUgbm90IG51bGwsIHRoZXlcbiAgLy8gcG9pbnQgdG8gdGhlIGxhc3Qgbm9kZSBpbiBhIGNpcmN1bGFyIGxpbmtlZCBsaXN0LiBXZSBuZWVkIHRvIGFwcGVuZCB0aGVcbiAgLy8gaW50ZXJsZWF2ZWQgbGlzdCB0byB0aGUgZW5kIG9mIHRoZSBwZW5kaW5nIGxpc3QgYnkgam9pbmluZyB0aGVtIGludG8gYVxuICAvLyBzaW5nbGUsIGNpcmN1bGFyIGxpc3QuXG4gIGlmIChpbnRlcmxlYXZlZFF1ZXVlcyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJsZWF2ZWRRdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZSA9IGludGVybGVhdmVkUXVldWVzW2ldO1xuICAgICAgdmFyIGxhc3RJbnRlcmxlYXZlZFVwZGF0ZSA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgICBpZiAobGFzdEludGVybGVhdmVkVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmludGVybGVhdmVkID0gbnVsbDtcbiAgICAgICAgdmFyIGZpcnN0SW50ZXJsZWF2ZWRVcGRhdGUgPSBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dDtcbiAgICAgICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcXVldWUucGVuZGluZztcblxuICAgICAgICBpZiAobGFzdFBlbmRpbmdVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICAgICAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gZmlyc3RJbnRlcmxlYXZlZFVwZGF0ZTtcbiAgICAgICAgICBsYXN0SW50ZXJsZWF2ZWRVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBsYXN0SW50ZXJsZWF2ZWRVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW50ZXJsZWF2ZWRRdWV1ZXMgPSBudWxsO1xuICB9XG59XG5cbnZhciBVcGRhdGVTdGF0ZSA9IDA7XG52YXIgUmVwbGFjZVN0YXRlID0gMTtcbnZhciBGb3JjZVVwZGF0ZSA9IDI7XG52YXIgQ2FwdHVyZVVwZGF0ZSA9IDM7IC8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG52YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO1xuXG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDoge1xuICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgIGludGVybGVhdmVkOiBudWxsLFxuICAgICAgbGFuZXM6IE5vTGFuZXNcbiAgICB9LFxuICAgIGVmZmVjdHM6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgZXZlbnRUaW1lOiBldmVudFRpbWUsXG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG4gIGlmIChpc0ludGVybGVhdmVkVXBkYXRlKGZpYmVyKSkge1xuICAgIHZhciBpbnRlcmxlYXZlZCA9IHNoYXJlZFF1ZXVlLmludGVybGVhdmVkO1xuXG4gICAgaWYgKGludGVybGVhdmVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCByZW5kZXIsIHRoaXMgcXVldWUncyBpbnRlcmxlYXZlZCB1cGRhdGVzIHdpbGxcbiAgICAgIC8vIGJlIHRyYW5zZmVycmVkIHRvIHRoZSBwZW5kaW5nIHF1ZXVlLlxuXG4gICAgICBwdXNoSW50ZXJsZWF2ZWRRdWV1ZShzaGFyZWRRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gaW50ZXJsZWF2ZWQubmV4dDtcbiAgICAgIGludGVybGVhdmVkLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgc2hhcmVkUXVldWUuaW50ZXJsZWF2ZWQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBlbmRpbmcgPSBzaGFyZWRRdWV1ZS5wZW5kaW5nO1xuXG4gICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG5cbiAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB9XG5cbiAge1xuICAgIGlmIChjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHNoYXJlZFF1ZXVlICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICBlcnJvcignQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuXG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG5cbiAgaWYgKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpIHtcbiAgICB2YXIgcXVldWVMYW5lcyA9IHNoYXJlZFF1ZXVlLmxhbmVzOyAvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5IG11c3RcbiAgICAvLyBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaCByZXByZXNlbnRzXG4gICAgLy8gYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZSBtYXkgZW50YW5nbGVcbiAgICAvLyBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmIHdlICpkb24ndCpcbiAgICAvLyBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cblxuICAgIHF1ZXVlTGFuZXMgPSBpbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLCByb290LnBlbmRpbmdMYW5lcyk7IC8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG5cbiAgICB2YXIgbmV3UXVldWVMYW5lcyA9IG1lcmdlTGFuZXMocXVldWVMYW5lcywgbGFuZSk7XG4gICAgc2hhcmVkUXVldWUubGFuZXMgPSBuZXdRdWV1ZUxhbmVzOyAvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG4gICAgLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbiAgICAvLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxuXG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbmV3UXVldWVMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY2FwdHVyZWRVcGRhdGUpIHtcbiAgLy8gQ2FwdHVyZWQgdXBkYXRlcyBhcmUgdXBkYXRlcyB0aGF0IGFyZSB0aHJvd24gYnkgYSBjaGlsZCBkdXJpbmcgdGhlIHJlbmRlclxuICAvLyBwaGFzZS4gVGhleSBzaG91bGQgYmUgZGlzY2FyZGVkIGlmIHRoZSByZW5kZXIgaXMgYWJvcnRlZC4gVGhlcmVmb3JlLFxuICAvLyB3ZSBzaG91bGQgb25seSBwdXQgdGhlbSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgbm90IHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIENoZWNrIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGEgY2xvbmUuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAgIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlblxuICAgICAgLy8gd2UgYmFpbCBvdXQgb24gYSBwYXJlbnQgZmliZXIgdGhhdCB0aGVuIGNhcHR1cmVzIGFuIGVycm9yIHRocm93biBieVxuICAgICAgLy8gYSBjaGlsZC4gU2luY2Ugd2Ugd2FudCB0byBhcHBlbmQgdGhlIHVwZGF0ZSBvbmx5IHRvIHRoZSB3b3JrLWluXG4gICAgICAvLyAtcHJvZ3Jlc3MgcXVldWUsIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHVwZGF0ZXMuIFdlIHVzdWFsbHkgY2xvbmUgZHVyaW5nXG4gICAgICAvLyBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCB0aGF0IGRpZG4ndCBoYXBwZW4gaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2VcbiAgICAgIC8vIHNraXBwZWQgb3ZlciB0aGUgcGFyZW50IHdoZW4gd2UgYmFpbGVkIG91dC5cbiAgICAgIHZhciBuZXdGaXJzdCA9IG51bGw7XG4gICAgICB2YXIgbmV3TGFzdCA9IG51bGw7XG4gICAgICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgdXBkYXRlcyBhbmQgY2xvbmUgdGhlbS5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGUuZXZlbnRUaW1lLFxuICAgICAgICAgICAgbGFuZTogdXBkYXRlLmxhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2xvbmU7XG4gICAgICAgICAgICBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vIEFwcGVuZCB0aGUgY2FwdHVyZWQgdXBkYXRlIHRoZSBlbmQgb2YgdGhlIGNsb25lZCBsaXN0LlxuXG5cbiAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgICBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBubyBiYXNlIHVwZGF0ZXMuXG4gICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG5ld0ZpcnN0LFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgICBlZmZlY3RzOiBjdXJyZW50UXVldWUuZWZmZWN0c1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cblxuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gIH1cblxuICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcblxuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gICAgICAgIHJldHVybiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmV2U3RhdGU7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgcHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQ7XG4gIH1cblxuICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTsgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gSWYgc28sIHRyYW5zZmVyIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgdmFyIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7IC8vIFRoZSBwZW5kaW5nIHF1ZXVlIGlzIGNpcmN1bGFyLiBEaXNjb25uZWN0IHRoZSBwb2ludGVyIGJldHdlZW4gZmlyc3RcbiAgICAvLyBhbmQgbGFzdCBzbyB0aGF0IGl0J3Mgbm9uLWNpcmN1bGFyLlxuXG4gICAgdmFyIGxhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHZhciBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgIGxhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsOyAvLyBBcHBlbmQgcGVuZGluZyB1cGRhdGVzIHRvIGJhc2UgcXVldWVcblxuICAgIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgIH1cblxuICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7IC8vIElmIHRoZXJlJ3MgYSBjdXJyZW50IHF1ZXVlLCBhbmQgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgYmFzZSBxdWV1ZSwgdGhlblxuICAgIC8vIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlIHVwZGF0ZXMgdG8gdGhhdCBxdWV1ZSwgdG9vLiBCZWNhdXNlIHRoZSBiYXNlXG4gICAgLy8gcXVldWUgaXMgYSBzaW5nbHktbGlua2VkIGxpc3Qgd2l0aCBubyBjeWNsZXMsIHdlIGNhbiBhcHBlbmQgdG8gYm90aFxuICAgIC8vIGxpc3RzIGFuZCB0YWtlIGFkdmFudGFnZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuXG4gICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnRcblxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgdmFyIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSAhPT0gbGFzdEJhc2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudExhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVGhlc2UgdmFsdWVzIG1heSBjaGFuZ2UgYXMgd2UgcHJvY2VzcyB0aGUgcXVldWUuXG5cblxuICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBsaXN0IG9mIHVwZGF0ZXMgdG8gY29tcHV0ZSB0aGUgcmVzdWx0LlxuICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTsgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmUgcmVuZGVyTGFuZXNcbiAgICAvLyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuICAgIHZhciBuZXdMYW5lcyA9IE5vTGFuZXM7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0xhc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSB1cGRhdGUubGFuZTtcbiAgICAgIHZhciB1cGRhdGVFdmVudFRpbWUgPSB1cGRhdGUuZXZlbnRUaW1lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGVFdmVudFRpbWUsXG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUgPSBjbG9uZTtcbiAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5cblxuICAgICAgICBuZXdMYW5lcyA9IG1lcmdlTGFuZXMobmV3TGFuZXMsIHVwZGF0ZUxhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZUV2ZW50VGltZSxcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4gICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBfY2xvbmU7XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIG5ld1N0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBuZXdTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuXG4gICAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCAmJiAvLyBJZiB0aGUgdXBkYXRlIHdhcyBhbHJlYWR5IGNvbW1pdHRlZCwgd2Ugc2hvdWxkIG5vdCBxdWV1ZSBpdHNcbiAgICAgICAgLy8gY2FsbGJhY2sgYWdhaW4uXG4gICAgICAgIHVwZGF0ZS5sYW5lICE9PSBOb0xhbmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDYWxsYmFjaztcbiAgICAgICAgICB2YXIgZWZmZWN0cyA9IHF1ZXVlLmVmZmVjdHM7XG5cbiAgICAgICAgICBpZiAoZWZmZWN0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUuZWZmZWN0cyA9IFt1cGRhdGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG5cbiAgICAgIGlmICh1cGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGEgcmVkdWNlci4gQWRkIHRoZSBuZXdcbiAgICAgICAgICAvLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxuICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2VcbiAgICAgICAgICAvLyB1bnJhdmVsIHRoZW0gd2hlbiB0cmFuc2ZlcnJpbmcgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICAgICAgICAgIHZhciBfZmlyc3RQZW5kaW5nVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZSA9IF9maXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBuZXdGaXJzdEJhc2VVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTsgLy8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuICAgIC8vIHByb2Nlc3MgdGhlbSBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCB3ZSBkbyBuZWVkIHRvIHRyYWNrIHdoaWNoIGxhbmVzXG4gICAgLy8gYXJlIHJlbWFpbmluZy5cblxuICAgIHZhciBsYXN0SW50ZXJsZWF2ZWQgPSBxdWV1ZS5zaGFyZWQuaW50ZXJsZWF2ZWQ7XG5cbiAgICBpZiAobGFzdEludGVybGVhdmVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJsZWF2ZWQgPSBsYXN0SW50ZXJsZWF2ZWQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgbmV3TGFuZXMgPSBtZXJnZUxhbmVzKG5ld0xhbmVzLCBpbnRlcmxlYXZlZC5sYW5lKTtcbiAgICAgICAgaW50ZXJsZWF2ZWQgPSBpbnRlcmxlYXZlZC5uZXh0O1xuICAgICAgfSB3aGlsZSAoaW50ZXJsZWF2ZWQgIT09IGxhc3RJbnRlcmxlYXZlZCk7XG4gICAgfSBlbHNlIGlmIChmaXJzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAgcXVldWUuc2hhcmVkLmxhbmVzID0gTm9MYW5lcztcbiAgICB9IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cblxuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbmV3TGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkICcgKyAoXCJyZWNlaXZlZDogXCIgKyBjYWxsYmFjaykpO1xuICB9XG5cbiAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKSB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5mdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIGZpbmlzaGVkUXVldWUsIGluc3RhbmNlKSB7XG4gIC8vIENvbW1pdCB0aGUgZWZmZWN0c1xuICB2YXIgZWZmZWN0cyA9IGZpbmlzaGVkUXVldWUuZWZmZWN0cztcbiAgZmluaXNoZWRRdWV1ZS5lZmZlY3RzID0gbnVsbDtcblxuICBpZiAoZWZmZWN0cyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVmZmVjdCA9IGVmZmVjdHNbaV07XG4gICAgICB2YXIgY2FsbGJhY2sgPSBlZmZlY3QuY2FsbGJhY2s7XG5cbiAgICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgICBlZmZlY3QuY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307IC8vIFJlYWN0LkNvbXBvbmVudCB1c2VzIGEgc2hhcmVkIGZyb3plbiBvYmplY3QgYnkgZGVmYXVsdC5cbi8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG5cbnZhciBlbXB0eVJlZnNPYmplY3QgPSBuZXcgUmVhY3QuQ29tcG9uZW50KCkucmVmcztcbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpO1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gY2FsbGVyTmFtZSArICdfJyArIGNhbGxiYWNrO1xuXG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcblxuICAgICAgZXJyb3IoJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xuXG4gIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgJyArICdtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgJyArICdhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyAnICsgXCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgXCIgKyAndG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggJyArICd0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLicpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5mcmVlemUoZmFrZUludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXh0UHJvcHMpIHtcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7IC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFF1ZXVlIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgY2xhc3Nlc1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cblxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBpc01vdW50ZWQsXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgdmFyIHJvb3QgPSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9LFxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHZhciByb290ID0gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgKyAnVGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSB1bmRlZmluZWQgJiYgaGFzTXV0YXRlZFByb3BzKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGVycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3RvcikpIHtcbiAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7XG5cbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiAnICsgJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGNvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0ID0gaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cbiAge1xuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICB2YXIgbmV3QXBpTmFtZSA9IHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/ICdnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKScgOiAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICBlcnJvcignVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cblxuXG4gIGlmIChpc0xlZ2FjeUNvbnRleHRDb25zdW1lcikge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgIHtcbiAgICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgIH1cblxuICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBmaWJlckZsYWdzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gVXBkYXRlO1xuXG4gICAgICB7XG4gICAgICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBfZmliZXJGbGFncyB8PSBMYXlvdXRTdGF0aWM7XG4gICAgICB9XG5cbiAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICBfZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gX2ZpYmVyRmxhZ3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9maWJlckZsYWdzMiA9IFVwZGF0ZTtcblxuICAgICAge1xuICAgICAgICBfZmliZXJGbGFnczIgfD0gTGF5b3V0U3RhdGljO1xuICAgICAgfVxuXG4gICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX2ZpYmVyRmxhZ3MyIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgICAgfVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBfZmliZXJGbGFnczI7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyB1bnJlc29sdmVkT2xkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSAmJiAhKGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gICApKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkgfHwgLy8gVE9ETzogSW4gc29tZSBjYXNlcywgd2UnbGwgZW5kIHVwIGNoZWNraW5nIGlmIGNvbnRleHQgaGFzIGNoYW5nZWQgdHdpY2UsXG4gIC8vIGJvdGggYmVmb3JlIGFuZCBhZnRlciBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBoYXMgYmVlbiBjYWxsZWQuIE5vdCBpZGVhbCxcbiAgLy8gYnV0IEknbSBsb2F0aCB0byByZWZhY3RvciB0aGlzIGZ1bmN0aW9uLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgbWVtb2l6ZWRcbiAgLy8gY29tcG9uZW50cyBzbyBpdCdzIG5vdCB0aGF0IGNvbW1vbi5cbiAgZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiAgIDtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbi8vIFRPRE86IFVzZSB0aGUgdW5pZmllZCBmaWJlciBzdGFjayBtb2R1bGUgaW5zdGVhZCBvZiB0aGlzIGxvY2FsIG9uZT9cbi8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGl0IHlldCB0byBkZXJpc2sgdGhlIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIGJlY2F1c2Vcbi8vIHRoZSB3YXkgd2UgcHVzaC9wb3AgdGhlc2UgdmFsdWVzIGlzIGEgYml0IHVudXN1YWwuIElmIHRoZXJlJ3MgYSBtaXN0YWtlLCBJJ2Rcbi8vIHJhdGhlciB0aGUgaWRzIGJlIHdyb25nIHRoYW4gY3Jhc2ggdGhlIHdob2xlIHJlY29uY2lsZXIuXG52YXIgZm9ya1N0YWNrID0gW107XG52YXIgZm9ya1N0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVGb3JrQ291bnQgPSAwO1xudmFyIGlkU3RhY2sgPSBbXTtcbnZhciBpZFN0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVDb250ZXh0SWQgPSAxO1xudmFyIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSAnJztcbmZ1bmN0aW9uIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JrZWQpICE9PSBOb0ZsYWdzO1xufVxuZnVuY3Rpb24gZ2V0Rm9ya3NBdExldmVsKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICByZXR1cm4gdHJlZUZvcmtDb3VudDtcbn1cbmZ1bmN0aW9uIGdldFRyZWVJZCgpIHtcbiAgdmFyIG92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgaWQgPSBpZFdpdGhMZWFkaW5nQml0ICYgfmdldExlYWRpbmdCaXQoaWRXaXRoTGVhZGluZ0JpdCk7XG4gIHJldHVybiBpZC50b1N0cmluZygzMikgKyBvdmVyZmxvdztcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbikge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciB3ZSByZWNvbmNpbGUgYW4gYXJyYXkgKG9yIGl0ZXJhdG9yKSBvZiBjaGlsZFxuICAvLyBmaWJlcnMsIGJlY2F1c2UgdGhhdCdzIHRoZSBvbmx5IHBsYWNlIHdoZXJlIHdlIGtub3cgaG93IG1hbnkgY2hpbGRyZW4gaW5cbiAgLy8gdGhlIHdob2xlIHNldCB3aXRob3V0IGRvaW5nIGV4dHJhIHdvcmsgbGF0ZXIsIG9yIHN0b3JpbmcgYWRkdGlvbmFsXG4gIC8vIGluZm9ybWF0aW9uIG9uIHRoZSBmaWJlci5cbiAgLy9cbiAgLy8gVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGlzIHNlcGFyYXRlIGZyb20gcHVzaFRyZWVJZCDigJQgaXQncyBjYWxsZWQgZHVyaW5nXG4gIC8vIHRoZSByZW5kZXIgcGhhc2Ugb2YgdGhlIGZvcmsgcGFyZW50LCBub3QgdGhlIGNoaWxkLCB3aGljaCBpcyB3aGVyZSB3ZSBwdXNoXG4gIC8vIHRoZSBvdGhlciBjb250ZXh0IHZhbHVlcy5cbiAgLy9cbiAgLy8gSW4gdGhlIEZpenogaW1wbGVtZW50YXRpb24gdGhpcyBpcyBtdWNoIHNpbXBsZXIgYmVjYXVzZSB0aGUgY2hpbGQgaXNcbiAgLy8gcmVuZGVyZWQgaW4gdGhlIHNhbWUgY2FsbHN0YWNrIGFzIHRoZSBwYXJlbnQuXG4gIC8vXG4gIC8vIEl0IG1pZ2h0IGJlIGJldHRlciB0byBqdXN0IGFkZCBhIGBmb3Jrc2AgZmllbGQgdG8gdGhlIEZpYmVyIHR5cGUuIEl0IHdvdWxkXG4gIC8vIG1ha2UgdGhpcyBtb2R1bGUgc2ltcGxlci5cbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrQ291bnQ7XG4gIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrUHJvdmlkZXI7XG4gIHRyZWVGb3JrUHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdHJlZUZvcmtDb3VudCA9IHRvdGFsQ2hpbGRyZW47XG59XG5mdW5jdGlvbiBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuLCBpbmRleCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgYmFzZUlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICB2YXIgYmFzZU92ZXJmbG93ID0gdHJlZUNvbnRleHRPdmVyZmxvdzsgLy8gVGhlIGxlZnRtb3N0IDEgbWFya3MgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG5vbi1pbmNsdXNpdmUuIEl0J3Mgbm90IHBhcnRcbiAgLy8gb2YgdGhlIGlkOyB3ZSB1c2UgaXQgdG8gYWNjb3VudCBmb3IgbGVhZGluZyAwcy5cblxuICB2YXIgYmFzZUxlbmd0aCA9IGdldEJpdExlbmd0aChiYXNlSWRXaXRoTGVhZGluZ0JpdCkgLSAxO1xuICB2YXIgYmFzZUlkID0gYmFzZUlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgYmFzZUxlbmd0aCk7XG4gIHZhciBzbG90ID0gaW5kZXggKyAxO1xuICB2YXIgbGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aDsgLy8gMzAgaXMgdGhlIG1heCBsZW5ndGggd2UgY2FuIHN0b3JlIHdpdGhvdXQgb3ZlcmZsb3dpbmcsIHRha2luZyBpbnRvXG4gIC8vIGNvbnNpZGVyYXRpb24gdGhlIGxlYWRpbmcgMSB3ZSB1c2UgdG8gbWFyayB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZS5cblxuICBpZiAobGVuZ3RoID4gMzApIHtcbiAgICAvLyBXZSBvdmVyZmxvd2VkIHRoZSBiaXR3aXNlLXNhZmUgcmFuZ2UuIEZhbGwgYmFjayB0byBzbG93ZXIgYWxnb3JpdGhtLlxuICAgIC8vIFRoaXMgYnJhbmNoIGFzc3VtZXMgdGhlIGxlbmd0aCBvZiB0aGUgYmFzZSBpZCBpcyBncmVhdGVyIHRoYW4gNTsgaXQgd29uJ3RcbiAgICAvLyB3b3JrIGZvciBzbWFsbGVyIGlkcywgYmVjYXVzZSB5b3UgbmVlZCA1IGJpdHMgcGVyIGNoYXJhY3Rlci5cbiAgICAvL1xuICAgIC8vIFdlIGVuY29kZSB0aGUgaWQgaW4gbXVsdGlwbGUgc3RlcHM6IGZpcnN0IHRoZSBiYXNlIGlkLCB0aGVuIHRoZVxuICAgIC8vIHJlbWFpbmluZyBkaWdpdHMuXG4gICAgLy9cbiAgICAvLyBFYWNoIDUgYml0IHNlcXVlbmNlIGNvcnJlc3BvbmRzIHRvIGEgc2luZ2xlIGJhc2UgMzIgY2hhcmFjdGVyLiBTbyBmb3JcbiAgICAvLyBleGFtcGxlLCBpZiB0aGUgY3VycmVudCBpZCBpcyAyMyBiaXRzIGxvbmcsIHdlIGNhbiBjb252ZXJ0IDIwIG9mIHRob3NlXG4gICAgLy8gYml0cyBpbnRvIGEgc3RyaW5nIG9mIDQgY2hhcmFjdGVycywgd2l0aCAzIGJpdHMgbGVmdCBvdmVyLlxuICAgIC8vXG4gICAgLy8gRmlyc3QgY2FsY3VsYXRlIGhvdyBtYW55IGJpdHMgaW4gdGhlIGJhc2UgaWQgcmVwcmVzZW50IGEgY29tcGxldGVcbiAgICAvLyBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzLlxuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSBiYXNlTGVuZ3RoICUgNTsgLy8gVGhlbiBjcmVhdGUgYSBiaXRtYXNrIHRoYXQgc2VsZWN0cyBvbmx5IHRob3NlIGJpdHMuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3dCaXRzID0gKDEgPDwgbnVtYmVyT2ZPdmVyZmxvd0JpdHMpIC0gMTsgLy8gU2VsZWN0IHRoZSBiaXRzLCBhbmQgY29udmVydCB0aGVtIHRvIGEgYmFzZSAzMiBzdHJpbmcuXG5cbiAgICB2YXIgbmV3T3ZlcmZsb3cgPSAoYmFzZUlkICYgbmV3T3ZlcmZsb3dCaXRzKS50b1N0cmluZygzMik7IC8vIE5vdyB3ZSBjYW4gcmVtb3ZlIHRob3NlIGJpdHMgZnJvbSB0aGUgYmFzZSBpZC5cblxuICAgIHZhciByZXN0T2ZCYXNlSWQgPSBiYXNlSWQgPj4gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgdmFyIHJlc3RPZkJhc2VMZW5ndGggPSBiYXNlTGVuZ3RoIC0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7IC8vIEZpbmFsbHksIGVuY29kZSB0aGUgcmVzdCBvZiB0aGUgYml0cyB1c2luZyB0aGUgbm9ybWFsIGFsZ29yaXRobS4gQmVjYXVzZVxuICAgIC8vIHdlIG1hZGUgbW9yZSByb29tLCB0aGlzIHRpbWUgaXQgd29uJ3Qgb3ZlcmZsb3cuXG5cbiAgICB2YXIgcmVzdE9mTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKHRvdGFsQ2hpbGRyZW4pICsgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgcmVzdE9mTmV3Qml0cyA9IHNsb3QgPDwgcmVzdE9mQmFzZUxlbmd0aDtcbiAgICB2YXIgaWQgPSByZXN0T2ZOZXdCaXRzIHwgcmVzdE9mQmFzZUlkO1xuICAgIHZhciBvdmVyZmxvdyA9IG5ld092ZXJmbG93ICsgYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IHJlc3RPZkxlbmd0aCB8IGlkO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgfSBlbHNlIHtcbiAgICAvLyBOb3JtYWwgcGF0aFxuICAgIHZhciBuZXdCaXRzID0gc2xvdCA8PCBiYXNlTGVuZ3RoO1xuXG4gICAgdmFyIF9pZCA9IG5ld0JpdHMgfCBiYXNlSWQ7XG5cbiAgICB2YXIgX292ZXJmbG93ID0gYmFzZU92ZXJmbG93O1xuICAgIHRyZWVDb250ZXh0SWQgPSAxIDw8IGxlbmd0aCB8IF9pZDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gX292ZXJmbG93O1xuICB9XG59XG5mdW5jdGlvbiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpOyAvLyBUaGlzIGNvbXBvbmVudCBtYXRlcmlhbGl6ZWQgYW4gaWQuIFRoaXMgd2lsbCBhZmZlY3QgYW55IGlkcyB0aGF0IGFwcGVhclxuICAvLyBpbiBpdHMgY2hpbGRyZW4uXG5cbiAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBudW1iZXJPZkZvcmtzID0gMTtcbiAgICB2YXIgc2xvdEluZGV4ID0gMDtcbiAgICBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MpO1xuICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MsIHNsb3RJbmRleCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Qml0TGVuZ3RoKG51bWJlcikge1xuICByZXR1cm4gMzIgLSBjbHozMihudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRMZWFkaW5nQml0KGlkKSB7XG4gIHJldHVybiAxIDw8IGdldEJpdExlbmd0aChpZCkgLSAxO1xufVxuXG5mdW5jdGlvbiBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyB2YWx1ZXMuXG4gIC8vIFRoaXMgaXMgYSBiaXQgbW9yZSBjb21wbGljYXRlZCB0aGFuIG90aGVyIGNvbnRleHQtbGlrZSBtb2R1bGVzIGluIEZpYmVyXG4gIC8vIGJlY2F1c2UgdGhlIHNhbWUgRmliZXIgbWF5IGFwcGVhciBvbiB0aGUgc3RhY2sgbXVsdGlwbGUgdGltZXMgYW5kIGZvclxuICAvLyBkaWZmZXJlbnQgcmVhc29ucy4gV2UgaGF2ZSB0byBrZWVwIHBvcHBpbmcgdW50aWwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaXNcbiAgLy8gbm8gbG9uZ2VyIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrLlxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVGb3JrUHJvdmlkZXIpIHtcbiAgICB0cmVlRm9ya1Byb3ZpZGVyID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO1xuICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVGb3JrQ291bnQgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG4gICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGw7XG4gIH1cblxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXIpIHtcbiAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlQ29udGV4dElkID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF07XG4gICAgaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuXG4gIGlmICh0cmVlQ29udGV4dFByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0cmVlQ29udGV4dElkLFxuICAgICAgb3ZlcmZsb3c6IHRyZWVDb250ZXh0T3ZlcmZsb3dcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbmRlZENvbnRleHQpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0SWQgPSBzdXNwZW5kZWRDb250ZXh0LmlkO1xuICB0cmVlQ29udGV4dE92ZXJmbG93ID0gc3VzcGVuZGVkQ29udGV4dC5vdmVyZmxvdztcbiAgdHJlZUNvbnRleHRQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZOb3RIeWRyYXRpbmcoKSB7XG4gIHtcbiAgICBpZiAoIWdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlICcgKyAnYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG52YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTsgLy8gVGhpcyBmbGFnIGFsbG93cyBmb3Igd2FybmluZyBzdXByZXNzaW9uIHdoZW4gd2UgZXhwZWN0IHRoZXJlIHRvIGJlIG1pc21hdGNoZXNcbi8vIGR1ZSB0byBlYXJsaWVyIG1pc21hdGNoZXMgb3IgYSBzdXNwZW5kZWQgZmliZXIuXG5cbnZhciBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlOyAvLyBIeWRyYXRpb24gZXJyb3JzIHRoYXQgd2VyZSB0aHJvd24gaW5zaWRlIHRoaXMgYm91bmRhcnlcblxudmFyIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG5cbmZ1bmN0aW9uIHdhcm5JZkh5ZHJhdGluZygpIHtcbiAge1xuICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgZXJyb3IoJ1dlIHNob3VsZCBub3QgYmUgaHlkcmF0aW5nIGhlcmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGEgYnVnLicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpIHtcbiAge1xuICAgIGRpZFN1c3BlbmRPckVycm9yREVWID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG5cbiAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihwYXJlbnRJbnN0YW5jZSk7XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcbiAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlZW50ZXJIeWRyYXRpb25TdGF0ZUZyb21EZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlciwgc3VzcGVuc2VJbnN0YW5jZSwgdHJlZUNvbnRleHQpIHtcblxuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7XG5cbiAgaWYgKHRyZWVDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgcmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0KGZpYmVyLCB0cmVlQ29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FyblVuaHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLCBpbnN0YW5jZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGlzQ29uY3VycmVudE1vZGUgPSAocmV0dXJuRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlLCAvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuICAgICAgICAgIGlzQ29uY3VycmVudE1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHJldHVybkZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgaWYgKHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkgZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHdhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKTtcbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV07XG4gICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgfSBlbHNlIHtcbiAgICBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAge1xuICAgIGlmIChkaWRTdXNwZW5kT3JFcnJvckRFVikge1xuICAgICAgLy8gSW5zaWRlIGEgYm91bmRhcnkgdGhhdCBhbHJlYWR5IHN1c3BlbmRlZC4gV2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB0aGVcbiAgICAgIC8vIHNpYmxpbmdzIG9mIGEgc3VzcGVuZGVkIG5vZGUuIFRoZSBtaXNtYXRjaCBtYXkgYmUgZHVlIHRvIHRoZSBtaXNzaW5nXG4gICAgICAvLyBkYXRhLCBzbyBpdCdzIHByb2JhYmx5IGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZVdpdGhpbkNvbnRhaW5lcihwYXJlbnRDb250YWluZXIsIHR5cGUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlV2l0aGluQ29udGFpbmVyKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ29uY3VycmVudE1vZGUgPSAocmV0dXJuRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzLCAvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuICAgICAgICAgICAgICAgIGlzQ29uY3VycmVudE1vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2lzQ29uY3VycmVudE1vZGUgPSAocmV0dXJuRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCwgLy8gVE9ETzogRGVsZXRlIHRoaXMgYXJndW1lbnQgd2hlbiB3ZSByZW1vdmUgdGhlIGxlZ2FjeSByb290IEFQSS5cbiAgICAgICAgICAgICAgICBfaXNDb25jdXJyZW50TW9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSByZXR1cm5GaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgICAgICAgaWYgKF9wYXJlbnRJbnN0YW5jZSAhPT0gbnVsbCkgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIF90eXBlMiA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHMyID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZShfcGFyZW50SW5zdGFuY2UsIF90eXBlMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgX3RleHQyID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpblN1c3BlbnNlSW5zdGFuY2UoX3BhcmVudEluc3RhbmNlLCBfdGV4dDIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcikge1xuICBmaWJlci5mbGFncyA9IGZpYmVyLmZsYWdzICYgfkh5ZHJhdGluZyB8IFBsYWNlbWVudDtcbiAgd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQoaW5zdGFuY2UpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG5cbiAgICAgICAgaWYgKHRleHRJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IHRleHRJbnN0YW5jZTtcbiAgICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyOyAvLyBUZXh0IEluc3RhbmNlcyBkb24ndCBoYXZlIGNoaWxkcmVuIHNvIHRoZXJlJ3Mgbm90aGluZyB0byBoeWRyYXRlLlxuXG4gICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSk7XG5cbiAgICAgICAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHtcbiAgICAgICAgICAgIGRlaHlkcmF0ZWQ6IHN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICAgICAgICB0cmVlQ29udGV4dDogZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSxcbiAgICAgICAgICAgIHJldHJ5TGFuZTogT2Zmc2NyZWVuTGFuZVxuICAgICAgICAgIH07XG4gICAgICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IHN1c3BlbnNlU3RhdGU7IC8vIFN0b3JlIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50IGFzIGEgY2hpbGQgZmliZXIuXG4gICAgICAgICAgLy8gVGhpcyBzaW1wbGlmaWVzIHRoZSBjb2RlIGZvciBnZXRIb3N0U2libGluZyBhbmQgZGVsZXRpbmcgbm9kZXMsXG4gICAgICAgICAgLy8gc2luY2UgaXQgZG9lc24ndCBoYXZlIHRvIGNvbnNpZGVyIGFsbCBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXkncmUgZGVoeWRyYXRlZCBvbmVzIG9yIG5vdC5cblxuICAgICAgICAgIHZhciBkZWh5ZHJhdGVkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgICAgZGVoeWRyYXRlZEZyYWdtZW50LnJldHVybiA9IGZpYmVyO1xuICAgICAgICAgIGZpYmVyLmNoaWxkID0gZGVoeWRyYXRlZEZyYWdtZW50O1xuICAgICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFdoaWxlIGEgU3VzcGVuc2UgSW5zdGFuY2UgZG9lcyBoYXZlIGNoaWxkcmVuLCB3ZSB3b24ndCBzdGVwIGludG9cbiAgICAgICAgICAvLyBpdCBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIEluc3RlYWQsIHdlJ2xsIHJlZW50ZXIgaXQgbGF0ZXIuXG5cbiAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikge1xuICByZXR1cm4gKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSAmJiAoZmliZXIuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncztcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKSB7XG4gIHRocm93IG5ldyBFcnJvcignSHlkcmF0aW9uIGZhaWxlZCBiZWNhdXNlIHRoZSBpbml0aWFsIFVJIGRvZXMgbm90IG1hdGNoIHdoYXQgd2FzICcgKyAncmVuZGVyZWQgb24gdGhlIHNlcnZlci4nKTtcbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgaWYgKHNob3VsZENsaWVudFJlbmRlck9uTWlzbWF0Y2goZmliZXIpKSB7XG4gICAgICB3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKCk7XG4gICAgfSAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuXG5cbiAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaXJzdEF0dGVtcHRlZEluc3RhbmNlID0gbmV4dEluc3RhbmNlO1xuXG4gIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgIGlmIChzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoKGZpYmVyKSkge1xuICAgICAgd2Fybk5vbmh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO1xuICAgIH0gLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgLy8gV2UgdXNlIHRoaXMgYXMgYSBoZXVyaXN0aWMuIEl0J3MgYmFzZWQgb24gaW50dWl0aW9uIGFuZCBub3QgZGF0YSBzbyBpdFxuICAgIC8vIG1pZ2h0IGJlIGZsYXdlZCBvciB1bm5lY2Vzc2FyeS5cblxuXG4gICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICAgIHZhciBwcmV2SHlkcmF0aW9uUGFyZW50RmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcblxuICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG5cbiAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocHJldkh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG5cbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZE9yRXJyb3JERVY7XG4gIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlciwgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYpOyAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cblxuICBmaWJlci51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cblxuICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZShmaWJlcikge1xuXG4gIHZhciB0ZXh0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgdmFyIGlzQ29uY3VycmVudE1vZGUgPSAocmV0dXJuRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIC8vIFRPRE86IERlbGV0ZSB0aGlzIGFyZ3VtZW50IHdoZW4gd2UgcmVtb3ZlIHRoZSBsZWdhY3kgcm9vdCBBUEkuXG4gICAgICAgICAgICBpc0NvbmN1cnJlbnRNb2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgdmFyIF9pc0NvbmN1cnJlbnRNb2RlMiA9IChyZXR1cm5GaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGU7XG5cbiAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCAvLyBUT0RPOiBEZWxldGUgdGhpcyBhcmd1bWVudCB3aGVuIHdlIHJlbW92ZSB0aGUgbGVnYWN5IHJvb3QgQVBJLlxuICAgICAgICAgICAgX2lzQ29uY3VycmVudE1vZGUyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBoYXZlIGEgaHlkcmF0ZWQgc3VzcGVuc2UgaW5zdGFuY2UuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcikge1xuXG4gIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlICE9PSBudWxsID8gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkIDogbnVsbDtcblxuICBpZiAoIXN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QgJiYgcGFyZW50LnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBwYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG5cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgLy8gc2lkZSBvZiB0aGVtLiBXZSBhbHNvIGRvbid0IGRlbGV0ZSBhbnl0aGluZyBpbnNpZGUgdGhlIHJvb3QgY29udGFpbmVyLlxuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QgJiYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICBpZiAobmV4dEluc3RhbmNlKSB7XG4gICAgICBpZiAoc2hvdWxkQ2xpZW50UmVuZGVyT25NaXNtYXRjaChmaWJlcikpIHtcbiAgICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcik7XG4gICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpO1xuICB9IGVsc2Uge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXNVbmh5ZHJhdGVkVGFpbE5vZGVzKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmcgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcikge1xuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgd2FyblVuaHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCkge1xuICBpZiAoaHlkcmF0aW9uRXJyb3JzICE9PSBudWxsKSB7XG4gICAgLy8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLiBUaGUgZXJyb3JzIHRoYXQgb2NjdXJyZWRcbiAgICAvLyBkdXJpbmcgdGhlIGh5ZHJhdGlvbiBhdHRlbXB0IGFyZSBub3cgcmVjb3ZlcmVkLiBXZSB3aWxsIGxvZyB0aGVtIGluXG4gICAgLy8gY29tbWl0IHBoYXNlLCBvbmNlIHRoZSBlbnRpcmUgdHJlZSBoYXMgZmluaXNoZWQuXG4gICAgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpO1xuICAgIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SXNIeWRyYXRpbmcoKSB7XG4gIHJldHVybiBpc0h5ZHJhdGluZztcbn1cblxuZnVuY3Rpb24gcXVldWVIeWRyYXRpb25FcnJvcihlcnJvcikge1xuICBpZiAoaHlkcmF0aW9uRXJyb3JzID09PSBudWxsKSB7XG4gICAgaHlkcmF0aW9uRXJyb3JzID0gW2Vycm9yXTtcbiAgfSBlbHNlIHtcbiAgICBoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dE1hcHM7XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycztcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZztcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmc7XG5cbnZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjaGlsZC5fc3RvcmUgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuXG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIC8vIFRPRE86IENsZWFuIHRoaXMgdXAgb25jZSB3ZSB0dXJuIG9uIHRoZSBzdHJpbmcgcmVmIHdhcm5pbmcgZm9yXG4gICAgICAvLyBldmVyeW9uZSwgYmVjYXVzZSB0aGUgc3RyaWN0IG1vZGUgY2FzZSB3aWxsIG5vIGxvbmdlciBiZSByZWxldmFudFxuICAgICAgaWYgKChyZXR1cm5GaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSB8fCB3YXJuQWJvdXRTdHJpbmdSZWZzKSAmJiAvLyBXZSB3YXJuIGluIFJlYWN0RWxlbWVudC5qcyBpZiBvd25lciBhbmQgc2VsZiBhcmUgZXF1YWwgZm9yIHN0cmluZyByZWZzXG4gICAgICAvLyBiZWNhdXNlIHRoZXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgLy8gdXNpbmcgYSBjb2RlbW9kLiBUaGVyZWZvcmUsIHdlIGRvbid0IGhhdmUgdG8gd2FybiBhYm91dCBzdHJpbmcgcmVmcyBhZ2Fpbi5cbiAgICAgICEoZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fc2VsZiAmJiBlbGVtZW50Ll9vd25lci5zdGF0ZU5vZGUgIT09IGVsZW1lbnQuX3NlbGYpKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3IoJ0Egc3RyaW5nIHJlZiwgXCIlc1wiLCBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgbWl4ZWRSZWYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0O1xuXG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcblxuICAgICAgICBpZiAob3duZXJGaWJlci50YWcgIT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHN0cmluZyByZWZzLiAnICsgJ1dlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiBcIiArIG1peGVkUmVmICsgXCIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIFwiICsgJ2J1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9IC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3Qgc28gRmxvdyBrbm93cyBpdCB3b24ndCBjaGFuZ2UgaW4gdGhlIGNsb3N1cmVcblxuXG4gICAgICB2YXIgcmVzb2x2ZWRJbnN0ID0gaW5zdDtcblxuICAgICAge1xuICAgICAgICBjaGVja1Byb3BTdHJpbmdDb2VyY2lvbihtaXhlZFJlZiwgJ3JlZicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjsgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIHR5cGVvZiBjdXJyZW50LnJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gcmVzb2x2ZWRJbnN0LnJlZnM7XG5cbiAgICAgICAgaWYgKHJlZnMgPT09IGVtcHR5UmVmc09iamVjdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXp5IHBvb2xlZCBmcm96ZW4gb2JqZWN0LCBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUuXG4gICAgICAgICAgcmVmcyA9IHJlc29sdmVkSW5zdC5yZWZzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgbWl4ZWRSZWYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGEgc3RyaW5nLCBhbiBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlUmVmKCksIG9yIG51bGwuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbWVudC5fb3duZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoXCIgKyBtaXhlZFJlZiArIFwiKSBidXQgbm8gb3duZXIgd2FzIHNldC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZlwiICsgJyB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGZ1bmN0aW9uIGNvbXBvbmVudFxcbicgKyBcIjIuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudCdzIHJlbmRlciBtZXRob2RcXG5cIiArICczLiBZb3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICB2YXIgY2hpbGRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZFN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlTGF6eShsYXp5VHlwZSkge1xuICB2YXIgcGF5bG9hZCA9IGxhenlUeXBlLl9wYXlsb2FkO1xuICB2YXIgaW5pdCA9IGxhenlUeXBlLl9pbml0O1xuICByZXR1cm4gaW5pdChwYXlsb2FkKTtcbn0gLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cblxuXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuXG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIC8vIGluc3RlYWQuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcblxuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIHVzZUlkIGFsZ29yaXRobSBuZWVkcyB0byBrbm93IHdoaWNoIGZpYmVycyBhcmVcbiAgICAgIC8vIHBhcnQgb2YgYSBsaXN0IG9mIGNoaWxkcmVuIChhcnJheXMsIGl0ZXJhdG9ycykuXG4gICAgICBuZXdGaWJlci5mbGFncyB8PSBGb3JrZWQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG5cbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIGVsZW1lbnQua2V5KTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG4gICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpICkgfHwgLy8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4gICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4gICAgICAvLyBiZWNhdXNlIGhvdCByZWxvYWRpbmcgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgdGhhbiBwcm9kIGJlY2F1c2VcbiAgICAgIC8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbiAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkge1xuICAgICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGVsZW1lbnQucHJvcHMpO1xuICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9XG4gICAgfSAvLyBJbnNlcnRcblxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBsYW5lcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywga2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCgnJyArIG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIGluaXQocGF5bG9hZCksIGxhbmVzKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBudWxsKTtcblxuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IG5ld0NoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSB0ZXh0IG5vZGVzLCB0aGV5IG1hdGNoLlxuICAgICAgdmFyIG1hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgbWF0Y2hlZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBpbml0KHBheWxvYWQpLCBsYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicsIGtleSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gY2hpbGQuX2luaXQ7XG4gICAgICAgICAgd2Fybk9uSW52YWxpZEtleShpbml0KHBheWxvYWQpLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBsYW5lcykge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGggZW5kcyBzaW5jZSB3ZVxuICAgIC8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4gICAgLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbiAgICAvLyBhZGQgaXQgbGF0ZXIuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuICAgIC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbiAgICAvLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBudW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIF9udW1iZXJPZkZvcmtzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfSAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cblxuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpOyAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKTtcblxuICAgICAgaWYgKF9uZXdGaWJlcjIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyMi5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXIyLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjIua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICB2YXIgX251bWJlck9mRm9ya3MyID0gbmV3SWR4O1xuICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3JrczIpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyByZWNvbmNpbGVDaGlsZHJlbkFycmF5KCksXG4gICAgLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gJyArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IHRvU3RyaW5nVGFnXG4gICAgICBuZXdDaGlsZHJlbkl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InKSB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuICAgICAgICAgIGVycm9yKCdVc2luZyBHZW5lcmF0b3JzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cyBiZWNhdXNlIGVudW1lcmF0aW5nIGEgZ2VuZXJhdG9yIG11dGF0ZXMgaXQuICcgKyAnWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlICcgKyAnYFsuLi5zcHJlYWRdYCBvcGVyYXRvciBiZWZvcmUgcmVuZGVyaW5nLiBLZWVwIGluIG1pbmQgJyArICd5b3UgbWlnaHQgbmVlZCB0byBwb2x5ZmlsbCB0aGVzZSBmZWF0dXJlcyBmb3Igb2xkZXIgYnJvd3NlcnMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICAgIH0gLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG5cblxuICAgICAgaWYgKG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICBlcnJvcignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgIH0gLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG5cblxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuXG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICBpZiAobmV3Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBudW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczMgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfSAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cblxuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpOyAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBsYW5lcyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgdmFyIF9udW1iZXJPZkZvcmtzNCA9IG5ld0lkeDtcbiAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3M0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGxhbmVzKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cblxuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGxhbmVzKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY2hpbGQsIGVsZW1lbnQpICkgfHwgLy8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuICAgICAgICAgIC8vIGJlY2F1c2UgaG90IHJlbG9hZGluZyBoYXMgZGlmZmVyZW50IHNlbWFudGljcyB0aGFuIHByb2QgYmVjYXVzZVxuICAgICAgICAgIC8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbiAgICAgICAgICB0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsICYmIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiYgcmVzb2x2ZUxhenkoZWxlbWVudFR5cGUpID09PSBjaGlsZC50eXBlKSB7XG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG5cbiAgICAgICAgICAgIHZhciBfZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcyk7XG5cbiAgICAgICAgICAgIF9leGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGNoaWxkLCBlbGVtZW50KTtcbiAgICAgICAgICAgIF9leGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICBfZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9leGlzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRGlkbid0IG1hdGNoLlxuXG5cbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ0ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgIF9jcmVhdGVkNC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9IC8vIFRoaXMgQVBJIHdpbGwgdGFnIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSBzaWRlLWVmZmVjdCBvZiB0aGUgcmVjb25jaWxpYXRpb25cbiAgLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuICAvLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuXG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfSAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDsgLy8gVE9ETzogVGhpcyBmdW5jdGlvbiBpcyBzdXBwb3NlZCB0byBiZSBub24tcmVjdXJzaXZlLlxuXG4gICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgaW5pdChwYXlsb2FkKSwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcyk7XG4gICAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn0gLy8gUmVzZXQgYSB3b3JrSW5Qcm9ncmVzcyBjaGlsZCBzZXQgdG8gcHJlcGFyZSBpdCBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyhjaGlsZCwgbGFuZXMpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xudmFyIGNvbnRleHRTdGFja0N1cnNvciQxID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xudmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG5mdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICBpZiAoYyA9PT0gTk9fQ09OVEVYVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7IC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgTk9fQ09OVEVYVCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUpOyAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cblxuICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5cblxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBuZXh0Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gIC8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZmliZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbnZhciBEZWZhdWx0U3VzcGVuc2VDb250ZXh0ID0gMDsgLy8gVGhlIFN1c3BlbnNlIENvbnRleHQgaXMgc3BsaXQgaW50byB0d28gcGFydHMuIFRoZSBsb3dlciBiaXRzIGlzXG4vLyBpbmhlcml0ZWQgZGVlcGx5IGRvd24gdGhlIHN1YnRyZWUuIFRoZSB1cHBlciBiaXRzIG9ubHkgYWZmZWN0XG4vLyB0aGlzIGltbWVkaWF0ZSBzdXNwZW5zZSBib3VuZGFyeSBhbmQgZ2V0cyByZXNldCBlYWNoIG5ld1xuLy8gYm91bmRhcnkgb3Igc3VzcGVuc2UgbGlzdC5cblxudmFyIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrID0gMTsgLy8gU3VidHJlZSBGbGFnczpcbi8vIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCBpbmRpY2F0ZXMgdGhhdCBvbmUgb2Ygb3VyIHBhcmVudCBTdXNwZW5zZVxuLy8gYm91bmRhcmllcyBpcyBub3QgY3VycmVudGx5IHNob3dpbmcgdmlzaWJsZSBtYWluIGNvbnRlbnQuXG4vLyBFaXRoZXIgYmVjYXVzZSBpdCBpcyBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBvciBpcyBub3QgbW91bnRlZCBhdCBhbGwuXG4vLyBXZSBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGRlc2lyYWJsZSB0byB0cmlnZ2VyIGEgZmFsbGJhY2sgYXRcbi8vIHRoZSBwYXJlbnQuIElmIG5vdCwgdGhlbiB3ZSBtaWdodCBuZWVkIHRvIHRyaWdnZXIgdW5kZXNpcmFibGUgYm91bmRhcmllc1xuLy8gYW5kL29yIHN1c3BlbmQgdGhlIGNvbW1pdCB0byBhdm9pZCBoaWRpbmcgdGhlIHBhcmVudCBjb250ZW50LlxuXG52YXIgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0ID0gMTsgLy8gU2hhbGxvdyBGbGFnczpcbi8vIEZvcmNlU3VzcGVuc2VGYWxsYmFjayBjYW4gYmUgdXNlZCBieSBTdXNwZW5zZUxpc3QgdG8gZm9yY2UgbmV3bHkgYWRkZWRcbi8vIGl0ZW1zIGludG8gdGhlaXIgZmFsbGJhY2sgc3RhdGUgZHVyaW5nIG9uZSBvZiB0aGUgcmVuZGVyIHBhc3Nlcy5cblxudmFyIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDI7XG52YXIgc3VzcGVuc2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihEZWZhdWx0U3VzcGVuc2VDb250ZXh0KTtcbmZ1bmN0aW9uIGhhc1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBmbGFnKSB7XG4gIHJldHVybiAocGFyZW50Q29udGV4dCAmIGZsYWcpICE9PSAwO1xufVxuZnVuY3Rpb24gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrO1xufVxuZnVuY3Rpb24gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBzaGFsbG93Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIHwgc2hhbGxvd0NvbnRleHQ7XG59XG5mdW5jdGlvbiBhZGRTdWJ0cmVlU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIHN1YnRyZWVDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0IHwgc3VidHJlZUNvbnRleHQ7XG59XG5mdW5jdGlvbiBwdXNoU3VzcGVuc2VDb250ZXh0KGZpYmVyLCBuZXdDb250ZXh0KSB7XG4gIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV3Q29udGV4dCwgZmliZXIpO1xufVxuZnVuY3Rpb24gcG9wU3VzcGVuc2VDb250ZXh0KGZpYmVyKSB7XG4gIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHNob3VsZENhcHR1cmVTdXNwZW5zZSh3b3JrSW5Qcm9ncmVzcywgaGFzSW52aXNpYmxlUGFyZW50KSB7XG4gIC8vIElmIGl0IHdhcyB0aGUgcHJpbWFyeSBjaGlsZHJlbiB0aGF0IGp1c3Qgc3VzcGVuZGVkLCBjYXB0dXJlIGFuZCByZW5kZXIgdGhlXG4gIC8vIGZhbGxiYWNrLiBPdGhlcndpc2UsIGRvbid0IGNhcHR1cmUgYW5kIGJ1YmJsZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5leHRTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0U3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgLy8gQSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGFsd2F5cyBjYXB0dXJlcy5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7IC8vIFJlZ3VsYXIgYm91bmRhcmllcyBhbHdheXMgY2FwdHVyZS5cblxuICB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgaXQncyBhIGJvdW5kYXJ5IHdlIHNob3VsZCBhdm9pZCwgdGhlbiB3ZSBwcmVmZXIgdG8gYnViYmxlIHVwIHRvIHRoZVxufVxuZnVuY3Rpb24gZmluZEZpcnN0U3VzcGVuZGVkKHJvdykge1xuICB2YXIgbm9kZSA9IHJvdztcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZWh5ZHJhdGVkID0gc3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoZGVoeWRyYXRlZCA9PT0gbnVsbCB8fCBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKGRlaHlkcmF0ZWQpIHx8IGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGRlaHlkcmF0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQgJiYgLy8gcmV2ZWFsT3JkZXIgdW5kZWZpbmVkIGNhbid0IGJlIHRydXN0ZWQgYmVjYXVzZSBpdCBkb24ndFxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBpdCBzdXNwZW5kZWQgb3Igbm90LlxuICAgIG5vZGUubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZGlkU3VzcGVuZCA9IChub2RlLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICAgIGlmIChkaWRTdXNwZW5kKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gcm93KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvdykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBOb0ZsYWdzJDEgPVxuLyogICAqL1xuMDsgLy8gUmVwcmVzZW50cyB3aGV0aGVyIGVmZmVjdCBzaG91bGQgZmlyZS5cblxudmFyIEhhc0VmZmVjdCA9XG4vKiAqL1xuMTsgLy8gUmVwcmVzZW50cyB0aGUgcGhhc2UgaW4gd2hpY2ggdGhlIGVmZmVjdCAobm90IHRoZSBjbGVhbi11cCkgZmlyZXMuXG5cbnZhciBJbnNlcnRpb24gPVxuLyogICovXG4yO1xudmFyIExheW91dCA9XG4vKiAgICAqL1xuNDtcbnZhciBQYXNzaXZlJDEgPVxuLyogICAqL1xuODtcblxuLy8gYW5kIHNob3VsZCBiZSByZXNldCBiZWZvcmUgc3RhcnRpbmcgYSBuZXcgcmVuZGVyLlxuLy8gVGhpcyB0cmFja3Mgd2hpY2ggbXV0YWJsZSBzb3VyY2VzIG5lZWQgdG8gYmUgcmVzZXQgYWZ0ZXIgYSByZW5kZXIuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMgPSBbXTtcbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IHdvcmtJblByb2dyZXNzU291cmNlc1tpXTtcblxuICAgIHtcbiAgICAgIG11dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnkgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGggPSAwO1xufVxuLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHZlcnNpb24gdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZyBtYXRjaGVzIHRoZSBvbmVcbi8vIHRoYXQgaXMgZXZlbnR1YWxseSByZWFkIGR1cmluZyBoeWRyYXRpb24uXG4vLyBJZiB0aGV5IGRvbid0IG1hdGNoIHRoZXJlJ3MgYSBwb3RlbnRpYWwgdGVhciBhbmQgYSBmdWxsIGRlb3B0IHJlbmRlciBpcyByZXF1aXJlZC5cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpIHtcbiAgdmFyIGdldFZlcnNpb24gPSBtdXRhYmxlU291cmNlLl9nZXRWZXJzaW9uO1xuICB2YXIgdmVyc2lvbiA9IGdldFZlcnNpb24obXV0YWJsZVNvdXJjZS5fc291cmNlKTsgLy8gVE9ETyBDbGVhciB0aGlzIGRhdGEgb25jZSBhbGwgcGVuZGluZyBoeWRyYXRpb24gd29yayBpcyBmaW5pc2hlZC5cbiAgLy8gUmV0YWluaW5nIGl0IGZvcmV2ZXIgbWF5IGludGVyZmVyZSB3aXRoIEdDLlxuXG4gIGlmIChyb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPT0gbnVsbCkge1xuICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IFttdXRhYmxlU291cmNlLCB2ZXJzaW9uXTtcbiAgfSBlbHNlIHtcbiAgICByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEucHVzaChtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7XG52YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90O1xuXG57XG4gIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuLy8gVGhlc2UgYXJlIHNldCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgY29tcG9uZW50LlxudmFyIHJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIEkndmUgbmFtZWQgaXQgZGlmZmVyZW50bHkgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuLy8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsOyAvLyBIb29rcyBhcmUgc3RvcmVkIGFzIGEgbGlua2VkIGxpc3Qgb24gdGhlIGZpYmVyJ3MgbWVtb2l6ZWRTdGF0ZSBmaWVsZC4gVGhlXG4vLyBjdXJyZW50IGhvb2sgbGlzdCBpcyB0aGUgbGlzdCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnQgZmliZXIuIFRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBob29rIGxpc3QgaXMgYSBuZXcgbGlzdCB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuXG52YXIgY3VycmVudEhvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgYXQgYW55IHBvaW50IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzXG4vLyBkb2VzIG5vdCBnZXQgcmVzZXQgaWYgd2UgZG8gYW5vdGhlciByZW5kZXIgcGFzczsgb25seSB3aGVuIHdlJ3JlIGNvbXBsZXRlbHlcbi8vIGZpbmlzaGVkIGV2YWx1YXRpbmcgdGhpcyBjb21wb25lbnQuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHdlIGtub3dcbi8vIHdoZXRoZXIgd2UgbmVlZCB0byBjbGVhciByZW5kZXIgcGhhc2UgdXBkYXRlcyBhZnRlciBhIHRocm93LlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBXaGVyZSBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbmx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcy4gVGhpc1xuLy8gZ2V0cyByZXNldCBhZnRlciBlYWNoIGF0dGVtcHQuXG4vLyBUT0RPOiBNYXliZSB0aGVyZSdzIHNvbWUgd2F5IHRvIGNvbnNvbGlkYXRlIHRoaXMgd2l0aFxuLy8gYGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVgLiBPciB3aXRoIGBudW1iZXJPZlJlUmVuZGVyc2AuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTsgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlSWQgaG9va3MgaW4gdGhpcyBjb21wb25lbnQuXG5cbnZhciBsb2NhbElkQ291bnRlciA9IDA7IC8vIFVzZWQgZm9yIGlkcyB0aGF0IGFyZSBnZW5lcmF0ZWQgY29tcGxldGVseSBjbGllbnQtc2lkZSAoaS5lLiBub3QgZHVyaW5nXG4vLyBoeWRyYXRpb24pLiBUaGlzIGNvdW50ZXIgaXMgZ2xvYmFsLCBzbyBjbGllbnQgaWRzIGFyZSBub3Qgc3RhYmxlIGFjcm9zc1xuLy8gcmVuZGVyIGF0dGVtcHRzLlxuXG52YXIgZ2xvYmFsQ2xpZW50SWRDb3VudGVyID0gMDtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7IC8vIEluIERFViwgdGhpcyBsaXN0IGVuc3VyZXMgdGhhdCBob29rcyBhcmUgY2FsbGVkIGluIHRoZSBzYW1lIG9yZGVyIGJldHdlZW4gcmVuZGVycy5cbi8vIFRoZSBsaXN0IHN0b3JlcyB0aGUgb3JkZXIgb2YgaG9va3MgdXNlZCBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIChtb3VudCkuXG4vLyBTdWJzZXF1ZW50IHJlbmRlcnMgKHVwZGF0ZXMpIHJlZmVyZW5jZSB0aGlzIGxpc3QuXG5cbnZhciBob29rVHlwZXNEZXYgPSBudWxsO1xudmFyIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIEluIERFViwgdGhpcyB0cmFja3Mgd2hldGhlciBjdXJyZW50bHkgcmVuZGVyaW5nIGNvbXBvbmVudCBuZWVkcyB0byBpZ25vcmVcbi8vIHRoZSBkZXBlbmRlbmNpZXMgZm9yIEhvb2tzIHRoYXQgbmVlZCB0aGVtIChlLmcuIHVzZUVmZmVjdCBvciB1c2VNZW1vKS5cbi8vIFdoZW4gdHJ1ZSwgc3VjaCBIb29rcyB3aWxsIGFsd2F5cyBiZSBcInJlbW91bnRlZFwiLiBPbmx5IHVzZWQgZHVyaW5nIGhvdCByZWxvYWQuXG5cbnZhciBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBtb3VudEhvb2tUeXBlc0RldigpIHtcbiAge1xuICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG4gICAgaWYgKGhvb2tUeXBlc0RldiA9PT0gbnVsbCkge1xuICAgICAgaG9va1R5cGVzRGV2ID0gW2hvb2tOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2Kys7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdICE9PSBob29rTmFtZSkge1xuICAgICAgICB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihob29rTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpIHtcbiAge1xuICAgIGlmIChkZXBzICE9PSB1bmRlZmluZWQgJiYgZGVwcyAhPT0gbnVsbCAmJiAhaXNBcnJheShkZXBzKSkge1xuICAgICAgLy8gVmVyaWZ5IGRlcHMsIGJ1dCBvbmx5IG9uIG1vdW50IHRvIGF2b2lkIGV4dHJhIGNoZWNrcy5cbiAgICAgIC8vIEl0J3MgdW5saWtlbHkgdGhlaXIgdHlwZSB3b3VsZCBjaGFuZ2UgYXMgdXN1YWxseSB5b3UgZGVmaW5lIHRoZW0gaW5saW5lLlxuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgdGhhdCBpcyBub3QgYW4gYXJyYXkgKGluc3RlYWQsIHJlY2VpdmVkIGAlc2ApLiBXaGVuICcgKyAnc3BlY2lmaWVkLCB0aGUgZmluYWwgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nLCBjdXJyZW50SG9va05hbWVJbkRldiwgdHlwZW9mIGRlcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihjdXJyZW50SG9va05hbWUpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcblxuICAgIGlmICghZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGFibGUgPSAnJztcbiAgICAgICAgdmFyIHNlY29uZENvbHVtblN0YXJ0ID0gMzA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXTtcbiAgICAgICAgICB2YXIgbmV3SG9va05hbWUgPSBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGN1cnJlbnRIb29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIHZhciByb3cgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lOyAvLyBFeHRyYSBzcGFjZSBzbyBzZWNvbmQgY29sdW1uIGxpbmVzIHVwXG4gICAgICAgICAgLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxuXG4gICAgICAgICAgd2hpbGUgKHJvdy5sZW5ndGggPCBzZWNvbmRDb2x1bW5TdGFydCkge1xuICAgICAgICAgICAgcm93ICs9ICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgKz0gbmV3SG9va05hbWUgKyAnXFxuJztcbiAgICAgICAgICB0YWJsZSArPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuICcgKyAnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbicgKyAnICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4nICsgJyAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicgKyAnJXMnICsgJyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcbicsIGNvbXBvbmVudE5hbWUsIHRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICB7XG4gICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSB7XG4gICAgICAvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnLCBuZXh0UmVuZGVyTGFuZXMpIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lczsgLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gY3VycmVudEhvb2sgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgLy8gVE9ETyBXYXJuIGlmIG5vIGhvb2tzIGFyZSB1c2VkIGF0IGFsbCBkdXJpbmcgbW91bnQsIHRoZW4gc29tZSBhcmUgdXNlZCBkdXJpbmcgdXBkYXRlLlxuICAvLyBDdXJyZW50bHkgd2Ugd2lsbCBpZGVudGlmeSB0aGUgdXBkYXRlIHJlbmRlciBhcyBhIG1vdW50IGJlY2F1c2UgbWVtb2l6ZWRTdGF0ZSA9PT0gbnVsbC5cbiAgLy8gVGhpcyBpcyB0cmlja3kgYmVjYXVzZSBpdCdzIHZhbGlkIGZvciBjZXJ0YWluIHR5cGVzIG9mIGNvbXBvbmVudHMgKGUuZy4gUmVhY3QubGF6eSlcbiAgLy8gVXNpbmcgbWVtb2l6ZWRTdGF0ZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbW91bnQvdXBkYXRlIG9ubHkgd29ya3MgaWYgYXQgbGVhc3Qgb25lIHN0YXRlZnVsIGhvb2sgaXMgdXNlZC5cbiAgLy8gTm9uLXN0YXRlZnVsIGhvb2tzIChlLmcuIGNvbnRleHQpIGRvbid0IGdldCBhZGRlZCB0byBtZW1vaXplZFN0YXRlLFxuICAvLyBzbyBtZW1vaXplZFN0YXRlIHdvdWxkIGJlIG51bGwgZHVyaW5nIHVwZGF0ZXMgYW5kIG1vdW50cy5cblxuICB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgfSBlbHNlIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBoYW5kbGVzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNvbXBvbmVudCBpcyB1cGRhdGluZyxcbiAgICAgIC8vIGJ1dCBubyBzdGF0ZWZ1bCBob29rcyBoYXZlIGJlZW4gdXNlZC5cbiAgICAgIC8vIFdlIHdhbnQgdG8gbWF0Y2ggdGhlIHByb2R1Y3Rpb24gY29kZSBiZWhhdmlvciAod2hpY2ggd2lsbCB1c2UgSG9va3NEaXNwYXRjaGVyT25Nb3VudCksXG4gICAgICAvLyBidXQgd2l0aCB0aGUgZXh0cmEgREVWIHZhbGlkYXRpb24gdG8gZW5zdXJlIGhvb2tzIG9yZGVyaW5nIGhhc24ndCBjaGFuZ2VkLlxuICAgICAgLy8gVGhpcyBkaXNwYXRjaGVyIGRvZXMgdGhhdC5cbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVjtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpOyAvLyBDaGVjayBpZiB0aGVyZSB3YXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlXG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcykge1xuICAgIC8vIEtlZXAgcmVuZGVyaW5nIGluIGEgbG9vcCBmb3IgYXMgbG9uZyBhcyByZW5kZXIgcGhhc2UgdXBkYXRlcyBjb250aW51ZSB0b1xuICAgIC8vIGJlIHNjaGVkdWxlZC4gVXNlIGEgY291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuICAgIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG5cbiAgICBkbyB7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMDtcblxuICAgICAgaWYgKG51bWJlck9mUmVSZW5kZXJzID49IFJFX1JFTkRFUl9MSU1JVCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCAnICsgJ2FuIGluZmluaXRlIGxvb3AuJyk7XG4gICAgICB9XG5cbiAgICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gRXZlbiB3aGVuIGhvdCByZWxvYWRpbmcsIGFsbG93IGRlcGVuZGVuY2llcyB0byBzdGFiaWxpemVcbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgcmVuZGVyIHRvIHByZXZlbnQgaW5maW5pdGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuXG4gICAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gZmFsc2U7XG4gICAgICB9IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cblxuICAgICAgY3VycmVudEhvb2sgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAge1xuICAgICAgICAvLyBBbHNvIHZhbGlkYXRlIGhvb2sgb3JkZXIgZm9yIGNhc2NhZGluZyB1cGRhdGVzLlxuICAgICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgfVxuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9ICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgO1xuICAgICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgfSB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKTtcbiAgfSAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jZS5cblxuXG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gIH0gLy8gVGhpcyBjaGVjayB1c2VzIGN1cnJlbnRIb29rIHNvIHRoYXQgaXQgd29ya3MgdGhlIHNhbWUgaW4gREVWIGFuZCBwcm9kIGJ1bmRsZXMuXG4gIC8vIGhvb2tUeXBlc0RldiBjb3VsZCBjYXRjaCBtb3JlIGNhc2VzIChlLmcuIGNvbnRleHQpIGJ1dCBvbmx5IGluIERFViBidW5kbGVzLlxuXG5cbiAgdmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzID0gY3VycmVudEhvb2sgIT09IG51bGwgJiYgY3VycmVudEhvb2submV4dCAhPT0gbnVsbDtcbiAgcmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgY3VycmVudEhvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBDb25maXJtIHRoYXQgYSBzdGF0aWMgZmxhZyB3YXMgbm90IGFkZGVkIG9yIHJlbW92ZWQgc2luY2UgdGhlIGxhc3RcbiAgICAvLyByZW5kZXIuIElmIHRoaXMgZmlyZXMsIGl0IHN1Z2dlc3RzIHRoYXQgd2UgaW5jb3JyZWN0bHkgcmVzZXQgdGhlIHN0YXRpY1xuICAgIC8vIGZsYWdzIGluIHNvbWUgb3RoZXIgcGFydCBvZiB0aGUgY29kZWJhc2UuIFRoaXMgaGFzIGhhcHBlbmVkIGJlZm9yZSwgZm9yXG4gICAgLy8gZXhhbXBsZSwgaW4gdGhlIFN1c3BlbnNlTGlzdCBpbXBsZW1lbnRhdGlvbi5cblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgU3RhdGljTWFzaykgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIFN0YXRpY01hc2spICYmIC8vIERpc2FibGUgdGhpcyB3YXJuaW5nIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGxlZ2FjeSBTdXNwZW5zZSBpcyB3ZWlyZFxuICAgIC8vIGFuZCBjcmVhdGVzIGZhbHNlIHBvc2l0aXZlcy4gVG8gbWFrZSB0aGlzIHdvcmsgaW4gbGVnYWN5IG1vZGUsIHdlJ2RcbiAgICAvLyBuZWVkIHRvIG1hcmsgZmliZXJzIHRoYXQgY29tbWl0IGluIGFuIGluY29tcGxldGUgc3RhdGUsIHNvbWVob3cuIEZvclxuICAgIC8vIG5vdyBJJ2xsIGRpc2FibGUgdGhlIHdhcm5pbmcgdGhhdCBtb3N0IG9mIHRoZSBidWdzIHRoYXQgd291bGQgdHJpZ2dlclxuICAgIC8vIGl0IGFyZSBlaXRoZXIgZXhjbHVzaXZlIHRvIGNvbmN1cnJlbnQgbW9kZSBvciBleGlzdCBpbiBib3RoLlxuICAgIChjdXJyZW50Lm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IGVycm9yOiBFeHBlY3RlZCBzdGF0aWMgZmxhZyB3YXMgbWlzc2luZy4gUGxlYXNlICcgKyAnbm90aWZ5IHRoZSBSZWFjdCB0ZWFtLicpO1xuICAgIH1cbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gVGhpcyBpcyByZXNldCBieSBjaGVja0RpZFJlbmRlcklkSG9va1xuICAvLyBsb2NhbElkQ291bnRlciA9IDA7XG5cbiAgaWYgKGRpZFJlbmRlclRvb0Zld0hvb2tzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBmZXdlciBob29rcyB0aGFuIGV4cGVjdGVkLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCAnICsgJ2Vhcmx5IHJldHVybiBzdGF0ZW1lbnQuJyk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBjaGVja0RpZFJlbmRlcklkSG9vaygpIHtcbiAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIGV2ZXJ5IHJlbmRlcldpdGhIb29rcyBjYWxsLlxuICAvLyBDb25jZXB0dWFsbHksIGl0J3MgcGFydCBvZiB0aGUgcmV0dXJuIHZhbHVlIG9mIHJlbmRlcldpdGhIb29rczsgaXQncyBvbmx5IGFcbiAgLy8gc2VwYXJhdGUgZnVuY3Rpb24gdG8gYXZvaWQgdXNpbmcgYW4gYXJyYXkgdHVwbGUuXG4gIHZhciBkaWRSZW5kZXJJZEhvb2sgPSBsb2NhbElkQ291bnRlciAhPT0gMDtcbiAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICByZXR1cm4gZGlkUmVuZGVySWRIb29rO1xufVxuZnVuY3Rpb24gYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIFRPRE86IERvbid0IG5lZWQgdG8gcmVzZXQgdGhlIGZsYWdzIGhlcmUsIGJlY2F1c2UgdGhleSdyZSByZXNldCBpbiB0aGVcbiAgLy8gY29tcGxldGUgcGhhc2UgKGJ1YmJsZVByb3BlcnRpZXMpLlxuXG4gIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH4oTW91bnRQYXNzaXZlRGV2IHwgTW91bnRMYXlvdXREZXYgfCBQYXNzaXZlIHwgVXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KFBhc3NpdmUgfCBVcGRhdGUpO1xuICB9XG5cbiAgY3VycmVudC5sYW5lcyA9IHJlbW92ZUxhbmVzKGN1cnJlbnQubGFuZXMsIGxhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0SG9va3NBZnRlclRocm93KCkge1xuICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jZS5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBUaGVyZSB3ZXJlIHJlbmRlciBwaGFzZSB1cGRhdGVzLiBUaGVzZSBhcmUgb25seSB2YWxpZCBmb3IgdGhpcyByZW5kZXJcbiAgICAvLyBwaGFzZSwgd2hpY2ggd2UgYXJlIG5vdyBhYm9ydGluZy4gUmVtb3ZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlcyBzb1xuICAgIC8vIHRoZXkgZG8gbm90IHBlcnNpc3QgdG8gdGhlIG5leHQgcmVuZGVyLiBEbyBub3QgcmVtb3ZlIHVwZGF0ZXMgZnJvbSBob29rc1xuICAgIC8vIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQuXG4gICAgLy9cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlIGlmIGl0IGhhcyBhIGNsb25lLiBJZiBpdCBkb2VzXG4gICAgLy8gbm90IGhhdmUgYSBjbG9uZSwgdGhhdCBtZWFucyBpdCB3YXNuJ3QgcHJvY2Vzc2VkLCBhbmQgdGhlIHVwZGF0ZXMgd2VyZVxuICAgIC8vIHNjaGVkdWxlZCBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHZhciBob29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuXG4gICAgd2hpbGUgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaG9vayA9IGhvb2submV4dDtcbiAgICB9XG5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICByZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbn1cblxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIHZhciBob29rID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgYmFzZVN0YXRlOiBudWxsLFxuICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rO1xuICB9IGVsc2Uge1xuICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYm90aCBmb3IgdXBkYXRlcyBhbmQgZm9yIHJlLXJlbmRlcnMgdHJpZ2dlcmVkIGJ5IGFcbiAgLy8gcmVuZGVyIHBoYXNlIHVwZGF0ZS4gSXQgYXNzdW1lcyB0aGVyZSBpcyBlaXRoZXIgYSBjdXJyZW50IGhvb2sgd2UgY2FuXG4gIC8vIGNsb25lLCBvciBhIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBmcm9tIGEgcHJldmlvdXMgcmVuZGVyIHBhc3MgdGhhdCB3ZSBjYW5cbiAgLy8gdXNlIGFzIGEgYmFzZS4gV2hlbiB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSBiYXNlIGxpc3QsIHdlIG11c3Qgc3dpdGNoIHRvXG4gIC8vIHRoZSBkaXNwYXRjaGVyIHVzZWQgZm9yIG1vdW50cy5cbiAgdmFyIG5leHRDdXJyZW50SG9vaztcblxuICBpZiAoY3VycmVudEhvb2sgPT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEN1cnJlbnRIb29rID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgfVxuXG4gIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuICB9IGVsc2Uge1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgfVxuXG4gIGlmIChuZXh0V29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbmV4dFdvcmtJblByb2dyZXNzSG9vaztcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2xvbmUgZnJvbSB0aGUgY3VycmVudCBob29rLlxuICAgIGlmIChuZXh0Q3VycmVudEhvb2sgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIHZhciBuZXdIb29rID0ge1xuICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgYmFzZVF1ZXVlOiBjdXJyZW50SG9vay5iYXNlUXVldWUsXG4gICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3QuXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXdIb29rO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV3SG9vaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkge1xuICByZXR1cm4ge1xuICAgIGxhc3RFZmZlY3Q6IG51bGwsXG4gICAgc3RvcmVzOiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLy8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXQoaW5pdGlhbEFyZyk7XG4gIH0gZWxzZSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbEFyZztcbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgcXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBpbnRlcmxlYXZlZDogbnVsbCxcbiAgICBsYW5lczogTm9MYW5lcyxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoUmVkdWNlckFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnQgPSBjdXJyZW50SG9vazsgLy8gVGhlIGxhc3QgcmViYXNlIHVwZGF0ZSB0aGF0IGlzIE5PVCBwYXJ0IG9mIHRoZSBiYXNlIHN0YXRlLlxuXG4gIHZhciBiYXNlUXVldWUgPSBjdXJyZW50LmJhc2VRdWV1ZTsgLy8gVGhlIGxhc3QgcGVuZGluZyB1cGRhdGUgdGhhdCBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuXG4gIHZhciBwZW5kaW5nUXVldWUgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIG5ldyB1cGRhdGVzIHRoYXQgaGF2ZW4ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG4gICAgLy8gV2UnbGwgYWRkIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG4gICAgaWYgKGJhc2VRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gTWVyZ2UgdGhlIHBlbmRpbmcgcXVldWUgYW5kIHRoZSBiYXNlIHF1ZXVlLlxuICAgICAgdmFyIGJhc2VGaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgdmFyIHBlbmRpbmdGaXJzdCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgYmFzZVF1ZXVlLm5leHQgPSBwZW5kaW5nRmlyc3Q7XG4gICAgICBwZW5kaW5nUXVldWUubmV4dCA9IGJhc2VGaXJzdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoY3VycmVudC5iYXNlUXVldWUgIT09IGJhc2VRdWV1ZSkge1xuICAgICAgICAvLyBJbnRlcm5hbCBpbnZhcmlhbnQgdGhhdCBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgZmVhc2libHkgY291bGQgaW5cbiAgICAgICAgLy8gdGhlIGZ1dHVyZSBpZiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcsIG9yIHNvbWUgZm9ybSBvZiB0aGF0LlxuICAgICAgICBlcnJvcignSW50ZXJuYWwgZXJyb3I6IEV4cGVjdGVkIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgdG8gYmUgYSBjbG9uZS4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnQuYmFzZVF1ZXVlID0gYmFzZVF1ZXVlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGJhc2VRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFdlIGhhdmUgYSBxdWV1ZSB0byBwcm9jZXNzLlxuICAgIHZhciBmaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgIHZhciBuZXdTdGF0ZSA9IGN1cnJlbnQuYmFzZVN0YXRlO1xuICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IG51bGw7XG4gICAgdmFyIG5ld0Jhc2VRdWV1ZUxhc3QgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdDtcblxuICAgIGRvIHtcbiAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmU7XG5cbiAgICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSBjbG9uZTtcbiAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gY2xvbmU7XG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuICAgICAgICAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZVxuICAgICAgICAvLyByZW5kZXJMYW5lcyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIHVwZGF0ZUxhbmUpO1xuICAgICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHVwZGF0ZUxhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbG9uZSA9IHtcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4gICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgaWYgKHVwZGF0ZS5oYXNFYWdlclN0YXRlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB1cGRhdGUgaXMgYSBzdGF0ZSB1cGRhdGUgKG5vdCBhIHJlZHVjZXIpIGFuZCB3YXMgcHJvY2Vzc2VkIGVhZ2VybHksXG4gICAgICAgICAgLy8gd2UgY2FuIHVzZSB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZVxuICAgICAgICAgIG5ld1N0YXRlID0gdXBkYXRlLmVhZ2VyU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCAmJiB1cGRhdGUgIT09IGZpcnN0KTtcblxuICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gbmV3QmFzZVF1ZXVlRmlyc3Q7XG4gICAgfSAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuICAgIGlmICghb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgaG9vay5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgaG9vay5iYXNlUXVldWUgPSBuZXdCYXNlUXVldWVMYXN0O1xuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gSW50ZXJsZWF2ZWQgdXBkYXRlcyBhcmUgc3RvcmVkIG9uIGEgc2VwYXJhdGUgcXVldWUuIFdlIGFyZW4ndCBnb2luZyB0b1xuICAvLyBwcm9jZXNzIHRoZW0gZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgd2UgZG8gbmVlZCB0byB0cmFjayB3aGljaCBsYW5lc1xuICAvLyBhcmUgcmVtYWluaW5nLlxuXG5cbiAgdmFyIGxhc3RJbnRlcmxlYXZlZCA9IHF1ZXVlLmludGVybGVhdmVkO1xuXG4gIGlmIChsYXN0SW50ZXJsZWF2ZWQgIT09IG51bGwpIHtcbiAgICB2YXIgaW50ZXJsZWF2ZWQgPSBsYXN0SW50ZXJsZWF2ZWQ7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgaW50ZXJsZWF2ZWRMYW5lID0gaW50ZXJsZWF2ZWQubGFuZTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIGludGVybGVhdmVkTGFuZSk7XG4gICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGludGVybGVhdmVkTGFuZSk7XG4gICAgICBpbnRlcmxlYXZlZCA9IGludGVybGVhdmVkLm5leHQ7XG4gICAgfSB3aGlsZSAoaW50ZXJsZWF2ZWQgIT09IGxhc3RJbnRlcmxlYXZlZCk7XG4gIH0gZWxzZSBpZiAoYmFzZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gYHF1ZXVlLmxhbmVzYCBpcyB1c2VkIGZvciBlbnRhbmdsaW5nIHRyYW5zaXRpb25zLiBXZSBjYW4gc2V0IGl0IGJhY2sgdG9cbiAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgIHF1ZXVlLmxhbmVzID0gTm9MYW5lcztcbiAgfVxuXG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7IC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gIHZhciBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobGFzdFJlbmRlclBoYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGRvZXNuJ3QgcGVyc2lzdCBwYXN0IHRoaXMgcmVuZGVyIHBhc3MuXG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTsgLy8gRG9uJ3QgcGVyc2lzdCB0aGUgc3RhdGUgYWNjdW11bGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cbiAgICAvLyB0aGUgYmFzZSBzdGF0ZSB1bmxlc3MgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgIC8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGRlc2lyZWQgc2VtYW50aWNzLCBidXQgaXQncyB3aGF0IHdlXG4gICAgLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cblxuICAgIGlmIChob29rLmJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiBtb3VudE11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dFNuYXBzaG90O1xuICB2YXIgaXNIeWRyYXRpbmcgPSBnZXRJc0h5ZHJhdGluZygpO1xuXG4gIGlmIChpc0h5ZHJhdGluZykge1xuICAgIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnICsgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgIH1cblxuICAgIG5leHRTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICAgIGlmIChuZXh0U25hcHNob3QgIT09IGdldFNlcnZlclNuYXBzaG90KCkpIHtcbiAgICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTZXJ2ZXJTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXh0U25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICB2YXIgY2FjaGVkU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAgICAgIGlmICghb2JqZWN0SXMobmV4dFNuYXBzaG90LCBjYWNoZWRTbmFwc2hvdCkpIHtcbiAgICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gVW5sZXNzIHdlJ3JlIHJlbmRlcmluZyBhIGJsb2NraW5nIGxhbmUsIHNjaGVkdWxlIGEgY29uc2lzdGVuY3kgY2hlY2suXG4gICAgLy8gUmlnaHQgYmVmb3JlIGNvbW1pdHRpbmcsIHdlIHdpbGwgd2FsayB0aGUgdHJlZSBhbmQgY2hlY2sgaWYgYW55IG9mIHRoZVxuICAgIC8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQuXG4gICAgLy9cbiAgICAvLyBXZSB3b24ndCBkbyB0aGlzIGlmIHdlJ3JlIGh5ZHJhdGluZyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCwgYmVjYXVzZSBpZlxuICAgIC8vIHRoZSBjb250ZW50IGlzIHN0YWxlLCBpdCdzIGFscmVhZHkgdmlzaWJsZSBhbnl3YXkuIEluc3RlYWQgd2UnbGwgcGF0Y2hcbiAgICAvLyBpdCB1cCBpbiBhIHBhc3NpdmUgZWZmZWN0LlxuXG5cbiAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIGlmICghaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIFRoaXMgYnJlYWtzIHRoZVxuICAvLyBub3JtYWwgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGJlY2F1c2Ugc3RvcmUgdXBkYXRlcyBhcmVcbiAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICB2YXIgaW5zdCA9IHtcbiAgICB2YWx1ZTogbmV4dFNuYXBzaG90LFxuICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdFxuICB9O1xuICBob29rLnF1ZXVlID0gaW5zdDsgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIHN1YnNjcmliZSB0byB0aGUgc3RvcmUuXG5cbiAgbW91bnRFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbc3Vic2NyaWJlXSk7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byB1cGRhdGUgdGhlIG11dGFibGUgaW5zdGFuY2UgZmllbGRzLiBXZSB3aWxsIHVwZGF0ZVxuICAvLyB0aGlzIHdoZW5ldmVyIHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIG9yIHZhbHVlIGNoYW5nZXMuIEJlY2F1c2UgdGhlcmUncyBub1xuICAvLyBjbGVhbi11cCBmdW5jdGlvbiwgYW5kIHdlIHRyYWNrIHRoZSBkZXBzIGNvcnJlY3RseSwgd2UgY2FuIGNhbGwgcHVzaEVmZmVjdFxuICAvLyBkaXJlY3RseSwgd2l0aG91dCBzdG9yaW5nIGFueSBhZGRpdGlvbmFsIHN0YXRlLiBGb3IgdGhlIHNhbWUgcmVhc29uLCB3ZVxuICAvLyBkb24ndCBuZWVkIHRvIHNldCBhIHN0YXRpYyBmbGFnLCBlaXRoZXIuXG4gIC8vIFRPRE86IFdlIGNhbiBtb3ZlIHRoaXMgdG8gdGhlIHBhc3NpdmUgcGhhc2Ugb25jZSB3ZSBhZGQgYSBwcmUtY29tbWl0XG4gIC8vIGNvbnNpc3RlbmN5IGNoZWNrLiBTZWUgdGhlIG5leHQgY29tbWVudC5cblxuICBmaWJlci5mbGFncyB8PSBQYXNzaXZlO1xuICBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IFBhc3NpdmUkMSwgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSwgdW5kZWZpbmVkLCBudWxsKTtcbiAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTsgLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIFRoaXMgYnJlYWtzIHRoZVxuICAvLyBub3JtYWwgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGJlY2F1c2Ugc3RvcmUgdXBkYXRlcyBhcmVcbiAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG4gIHZhciBuZXh0U25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gIHtcbiAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICB2YXIgY2FjaGVkU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAgICBpZiAoIW9iamVjdElzKG5leHRTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpKSB7XG4gICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG4gICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcHJldlNuYXBzaG90ID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICB2YXIgc25hcHNob3RDaGFuZ2VkID0gIW9iamVjdElzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcblxuICBpZiAoc25hcHNob3RDaGFuZ2VkKSB7XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gIH1cblxuICB2YXIgaW5zdCA9IGhvb2sucXVldWU7XG4gIHVwZGF0ZUVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIHN1YnNjcmliZSksIFtzdWJzY3JpYmVdKTsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuICAvLyB0aGlzIGNhbiBoYXBwZW4gYWxsIHRoZSB0aW1lLCBidXQgZXZlbiBpbiBzeW5jaHJvbm91cyBtb2RlLCBhbiBlYXJsaWVyXG4gIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICBpZiAoaW5zdC5nZXRTbmFwc2hvdCAhPT0gZ2V0U25hcHNob3QgfHwgc25hcHNob3RDaGFuZ2VkIHx8IC8vIENoZWNrIGlmIHRoZSBzdXNiY3JpYmUgZnVuY3Rpb24gY2hhbmdlZC4gV2UgY2FuIHNhdmUgc29tZSBtZW1vcnkgYnlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB3ZSBzY2hlZHVsZWQgYSBzdWJzY3JpcHRpb24gZWZmZWN0IGFib3ZlLlxuICB3b3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnICYgSGFzRWZmZWN0KSB7XG4gICAgZmliZXIuZmxhZ3MgfD0gUGFzc2l2ZTtcbiAgICBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IFBhc3NpdmUkMSwgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSwgdW5kZWZpbmVkLCBudWxsKTsgLy8gVW5sZXNzIHdlJ3JlIHJlbmRlcmluZyBhIGJsb2NraW5nIGxhbmUsIHNjaGVkdWxlIGEgY29uc2lzdGVuY3kgY2hlY2suXG4gICAgLy8gUmlnaHQgYmVmb3JlIGNvbW1pdHRpbmcsIHdlIHdpbGwgd2FsayB0aGUgdHJlZSBhbmQgY2hlY2sgaWYgYW55IG9mIHRoZVxuICAgIC8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQuXG5cbiAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIGlmICghaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFNuYXBzaG90O1xufVxuXG5mdW5jdGlvbiBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgcmVuZGVyZWRTbmFwc2hvdCkge1xuICBmaWJlci5mbGFncyB8PSBTdG9yZUNvbnNpc3RlbmN5O1xuICB2YXIgY2hlY2sgPSB7XG4gICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LFxuICAgIHZhbHVlOiByZW5kZXJlZFNuYXBzaG90XG4gIH07XG4gIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3JlcyA9IFtjaGVja107XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0b3JlcyA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3JlcztcblxuICAgIGlmIChzdG9yZXMgPT09IG51bGwpIHtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLnN0b3JlcyA9IFtjaGVja107XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3Jlcy5wdXNoKGNoZWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RvcmVJbnN0YW5jZShmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCkge1xuICAvLyBUaGVzZSBhcmUgdXBkYXRlZCBpbiB0aGUgcGFzc2l2ZSBwaGFzZVxuICBpbnN0LnZhbHVlID0gbmV4dFNuYXBzaG90O1xuICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7IC8vIFNvbWV0aGluZyBtYXkgaGF2ZSBiZWVuIG11dGF0ZWQgaW4gYmV0d2VlbiByZW5kZXIgYW5kIGNvbW1pdC4gVGhpcyBjb3VsZFxuICAvLyBoYXZlIGJlZW4gaW4gYW4gZXZlbnQgdGhhdCBmaXJlZCBiZWZvcmUgdGhlIHBhc3NpdmUgZWZmZWN0cywgb3IgaXQgY291bGRcbiAgLy8gaGF2ZSBiZWVuIGluIGEgbGF5b3V0IGVmZmVjdC4gSW4gdGhhdCBjYXNlLCB3ZSB3b3VsZCBoYXZlIHVzZWQgdGhlIG9sZFxuICAvLyBzbmFwc2hvIGFuZCBnZXRTbmFwc2hvdCB2YWx1ZXMgdG8gYmFpbCBvdXQuIFdlIG5lZWQgdG8gY2hlY2sgb25lIG1vcmUgdGltZS5cblxuICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Vic2NyaWJlVG9TdG9yZShmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSB7XG4gIHZhciBoYW5kbGVTdG9yZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGUgc3RvcmUgY2hhbmdlZC4gQ2hlY2sgaWYgdGhlIHNuYXBzaG90IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZVxuICAgIC8vIHJlYWQgZnJvbSB0aGUgc3RvcmUuXG4gICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuICAgICAgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgICB9XG4gIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgcmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkge1xuICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSBpbnN0LmdldFNuYXBzaG90O1xuICB2YXIgcHJldlZhbHVlID0gaW5zdC52YWx1ZTtcblxuICB0cnkge1xuICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgIHJldHVybiAhb2JqZWN0SXMocHJldlZhbHVlLCBuZXh0VmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcikge1xuICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlKCk7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgaW50ZXJsZWF2ZWQ6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGRlc3Ryb3ksIGRlcHMpIHtcbiAgdmFyIGVmZmVjdCA9IHtcbiAgICB0YWc6IHRhZyxcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgIGRlcHM6IGRlcHMsXG4gICAgLy8gQ2lyY3VsYXJcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdEVmZmVjdCA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICBsYXN0RWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgICBlZmZlY3QubmV4dCA9IGZpcnN0RWZmZWN0O1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWZmZWN0O1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIHtcbiAgICB2YXIgX3JlZjIgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IF9yZWYyO1xuICAgIHJldHVybiBfcmVmMjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIHVuZGVmaW5lZCwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICBpZiAoY3VycmVudEhvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkVmZmVjdCA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgZGVzdHJveSA9IHByZXZFZmZlY3QuZGVzdHJveTtcblxuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldkVmZmVjdC5kZXBzO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICBpZiAoIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIHJldHVybiBtb3VudEVmZmVjdEltcGwoTW91bnRQYXNzaXZlRGV2IHwgUGFzc2l2ZSB8IFBhc3NpdmVTdGF0aWMsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFBhc3NpdmUgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChQYXNzaXZlLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGZpYmVyRmxhZ3MgPSBVcGRhdGU7XG5cbiAge1xuICAgIGZpYmVyRmxhZ3MgfD0gTGF5b3V0U3RhdGljO1xuICB9XG5cbiAgaWYgKCAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICBmaWJlckZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICB9XG5cbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVmQ2FsbGJhY2sgPSByZWY7XG5cbiAgICB2YXIgX2luc3QgPSBjcmVhdGUoKTtcblxuICAgIHJlZkNhbGxiYWNrKF9pbnN0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmQ2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChyZWYgIT09IG51bGwgJiYgcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVmT2JqZWN0ID0gcmVmO1xuXG4gICAge1xuICAgICAgaWYgKCFyZWZPYmplY3QuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIGZpcnN0IGFyZ3VtZW50IHRvIGVpdGhlciBiZSBhICcgKyAncmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgJ2FuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhyZWZPYmplY3QpLmpvaW4oJywgJykgKyAnfScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfaW5zdDIgPSBjcmVhdGUoKTtcblxuICAgIHJlZk9iamVjdC5jdXJyZW50ID0gX2luc3QyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZWZPYmplY3QuY3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZTtcblxuICB7XG4gICAgZmliZXJGbGFncyB8PSBMYXlvdXRTdGF0aWM7XG4gIH1cblxuICBpZiAoIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIGZpYmVyRmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gIH1cblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cbiAgLy8gVGhlIHJlYWN0LWRlYnVnLWhvb2tzIHBhY2thZ2UgaW5qZWN0cyBpdHMgb3duIGltcGxlbWVudGF0aW9uXG4gIC8vIHNvIHRoYXQgZS5nLiBEZXZUb29scyBjYW4gZGlzcGxheSBjdXN0b20gaG9vayB2YWx1ZXMuXG59XG5cbnZhciB1cGRhdGVEZWJ1Z1ZhbHVlID0gbW91bnREZWJ1Z1ZhbHVlO1xuXG5mdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEFzc3VtZSB0aGVzZSBhcmUgZGVmaW5lZC4gSWYgdGhleSdyZSBub3QsIGFyZUhvb2tJbnB1dHNFcXVhbCB3aWxsIHdhcm4uXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVzb2x2ZWRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rO1xuICB2YXIgcHJldlZhbHVlID0gcmVzb2x2ZWRDdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmIChjdXJyZW50SG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSByZXJlbmRlciBkdXJpbmcgYSBtb3VudC5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlcmVuZGVyIGR1cmluZyBhbiB1cGRhdGUuXG4gICAgdmFyIHByZXZWYWx1ZSA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUpIHtcbiAgdmFyIHNob3VsZERlZmVyVmFsdWUgPSAhaW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMocmVuZGVyTGFuZXMpO1xuXG4gIGlmIChzaG91bGREZWZlclZhbHVlKSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cmdlbnQgdXBkYXRlLiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGtlZXAgdXNpbmcgdGhlXG4gICAgLy8gcHJldmlvdXMgdmFsdWUgYW5kIHNwYXduIGEgZGVmZXJyZWQgcmVuZGVyIHRvIHVwZGF0ZSBpdCBsYXRlci5cbiAgICBpZiAoIW9iamVjdElzKHZhbHVlLCBwcmV2VmFsdWUpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIGRlZmVycmVkIHJlbmRlclxuICAgICAgdmFyIGRlZmVycmVkTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCBkZWZlcnJlZExhbmUpO1xuICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhkZWZlcnJlZExhbmUpOyAvLyBTZXQgdGhpcyB0byB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIHJlbmRlcmVkIHZhbHVlIGlzIGluY29uc2lzdGVudFxuICAgICAgLy8gZnJvbSB0aGUgbGF0ZXN0IHZhbHVlLiBUaGUgbmFtZSBcImJhc2VTdGF0ZVwiIGRvZXNuJ3QgcmVhbGx5IG1hdGNoIGhvdyB3ZVxuICAgICAgLy8gdXNlIGl0IGJlY2F1c2Ugd2UncmUgcmV1c2luZyBhIHN0YXRlIGhvb2sgZmllbGQgaW5zdGVhZCBvZiBjcmVhdGluZyBhXG4gICAgICAvLyBuZXcgb25lLlxuXG4gICAgICBob29rLmJhc2VTdGF0ZSA9IHRydWU7XG4gICAgfSAvLyBSZXVzZSB0aGUgcHJldmlvdXMgdmFsdWVcblxuXG4gICAgcmV0dXJuIHByZXZWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBhbiB1cmdlbnQgdXBkYXRlLCBzbyB3ZSBjYW4gdXNlIHRoZSBsYXRlc3QgdmFsdWUgcmVnYXJkbGVzc1xuICAgIC8vIG9mIHdoYXQgaXQgaXMuIE5vIG5lZWQgdG8gZGVmZXIgaXQuXG4gICAgLy8gSG93ZXZlciwgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIHNwYXduZWQgcmVuZGVyLCB0aGVuIHdlIG5lZWQgdG8gbWFya1xuICAgIC8vIHRoaXMgYXMgYW4gdXBkYXRlIHRvIHByZXZlbnQgdGhlIGZpYmVyIGZyb20gYmFpbGluZyBvdXQuXG4gICAgLy9cbiAgICAvLyBgYmFzZVN0YXRlYCBpcyB0cnVlIHdoZW4gdGhlIGN1cnJlbnQgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIHJlbmRlcmVkXG4gICAgLy8gdmFsdWUuIFRoZSBuYW1lIGRvZXNuJ3QgcmVhbGx5IG1hdGNoIGhvdyB3ZSB1c2UgaXQgYmVjYXVzZSB3ZSdyZSByZXVzaW5nXG4gICAgLy8gYSBzdGF0ZSBob29rIGZpZWxkIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lLlxuICAgIGlmIChob29rLmJhc2VTdGF0ZSkge1xuICAgICAgLy8gRmxpcCB0aGlzIGJhY2sgdG8gZmFsc2UuXG4gICAgICBob29rLmJhc2VTdGF0ZSA9IGZhbHNlO1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNldFBlbmRpbmcsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShoaWdoZXJFdmVudFByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5KSk7XG4gIHNldFBlbmRpbmcodHJ1ZSk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uID0ge307XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDIudHJhbnNpdGlvbjtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMi50cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcblxuICAgIHtcbiAgICAgIGlmIChwcmV2VHJhbnNpdGlvbiA9PT0gbnVsbCAmJiBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycykge1xuICAgICAgICB2YXIgdXBkYXRlZEZpYmVyc0NvdW50ID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcblxuICAgICAgICBpZiAodXBkYXRlZEZpYmVyc0NvdW50ID4gMTApIHtcbiAgICAgICAgICB3YXJuKCdEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uICcgKyAnSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gJyArICdPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFRyYW5zaXRpb24oKSB7XG4gIHZhciBfbW91bnRTdGF0ZSA9IG1vdW50U3RhdGUoZmFsc2UpLFxuICAgICAgaXNQZW5kaW5nID0gX21vdW50U3RhdGVbMF0sXG4gICAgICBzZXRQZW5kaW5nID0gX21vdW50U3RhdGVbMV07IC8vIFRoZSBgc3RhcnRgIG1ldGhvZCBuZXZlciBjaGFuZ2VzLlxuXG5cbiAgdmFyIHN0YXJ0ID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQobnVsbCwgc2V0UGVuZGluZyk7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gc3RhcnQ7XG4gIHJldHVybiBbaXNQZW5kaW5nLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gIHZhciBfdXBkYXRlU3RhdGUgPSB1cGRhdGVTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3VwZGF0ZVN0YXRlWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUgPSByZXJlbmRlclN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfcmVyZW5kZXJTdGF0ZVswXTtcblxuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgc3RhcnQgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHJldHVybiBbaXNQZW5kaW5nLCBzdGFydF07XG59XG5cbnZhciBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRJc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlSW5ERVYoKSB7XG4gIHtcbiAgICByZXR1cm4gaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudElkKCkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7IC8vIFRPRE86IEluIEZpenosIGlkIGdlbmVyYXRpb24gaXMgc3BlY2lmaWMgdG8gZWFjaCBzZXJ2ZXIgY29uZmlnLiBNYXliZSB3ZVxuICAvLyBzaG91bGQgZG8gdGhpcyBpbiBGaWJlciwgdG9vPyBEZWZlcnJpbmcgdGhpcyBkZWNpc2lvbiBmb3Igbm93IGJlY2F1c2VcbiAgLy8gdGhlcmUncyBubyBvdGhlciBwbGFjZSB0byBzdG9yZSB0aGUgcHJlZml4IGV4Y2VwdCBmb3IgYW4gaW50ZXJuYWwgZmllbGQgb25cbiAgLy8gdGhlIHB1YmxpYyBjcmVhdGVSb290IG9iamVjdCwgd2hpY2ggdGhlIGZpYmVyIHRyZWUgZG9lcyBub3QgY3VycmVudGx5IGhhdmVcbiAgLy8gYSByZWZlcmVuY2UgdG8uXG5cbiAgdmFyIGlkZW50aWZpZXJQcmVmaXggPSByb290LmlkZW50aWZpZXJQcmVmaXg7XG4gIHZhciBpZDtcblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIHZhciB0cmVlSWQgPSBnZXRUcmVlSWQoKTsgLy8gVXNlIGEgY2FwdGlhbCBSIHByZWZpeCBmb3Igc2VydmVyLWdlbmVyYXRlZCBpZHMuXG5cbiAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAnUicgKyB0cmVlSWQ7IC8vIFVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCBpZCBhdCB0aGlzIGxldmVsLCBhcHBlbmQgYSBudW1iZXIgYXQgdGhlIGVuZFxuICAgIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VJZCBob29rIGFtb25nIGFsbCB0aGUgdXNlSWRcbiAgICAvLyBob29rcyBmb3IgdGhpcyBmaWJlci5cblxuICAgIHZhciBsb2NhbElkID0gbG9jYWxJZENvdW50ZXIrKztcblxuICAgIGlmIChsb2NhbElkID4gMCkge1xuICAgICAgaWQgKz0gJ0gnICsgbG9jYWxJZC50b1N0cmluZygzMik7XG4gICAgfVxuXG4gICAgaWQgKz0gJzonO1xuICB9IGVsc2Uge1xuICAgIC8vIFVzZSBhIGxvd2VyY2FzZSByIHByZWZpeCBmb3IgY2xpZW50LWdlbmVyYXRlZCBpZHMuXG4gICAgdmFyIGdsb2JhbENsaWVudElkID0gZ2xvYmFsQ2xpZW50SWRDb3VudGVyKys7XG4gICAgaWQgPSAnOicgKyBpZGVudGlmaWVyUHJlZml4ICsgJ3InICsgZ2xvYmFsQ2xpZW50SWQudG9TdHJpbmcoMzIpICsgJzonO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaWQ7XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSWQoKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBpZCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgaGFzRWFnZXJTdGF0ZTogZmFsc2UsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgcm9vdCA9IHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlKTtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGZpYmVyLmxhbmVzID09PSBOb0xhbmVzICYmIChhbHRlcm5hdGUgPT09IG51bGwgfHwgYWx0ZXJuYXRlLmxhbmVzID09PSBOb0xhbmVzKSkge1xuICAgICAgLy8gVGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBlbXB0eSwgd2hpY2ggbWVhbnMgd2UgY2FuIGVhZ2VybHkgY29tcHV0ZSB0aGVcbiAgICAgIC8vIG5leHQgc3RhdGUgYmVmb3JlIGVudGVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIElmIHRoZSBuZXcgc3RhdGUgaXMgdGhlXG4gICAgICAvLyBzYW1lIGFzIHRoZSBjdXJyZW50IHN0YXRlLCB3ZSBtYXkgYmUgYWJsZSB0byBiYWlsIG91dCBlbnRpcmVseS5cbiAgICAgIHZhciBsYXN0UmVuZGVyZWRSZWR1Y2VyID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlcjtcblxuICAgICAgaWYgKGxhc3RSZW5kZXJlZFJlZHVjZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgZWFnZXJTdGF0ZSA9IGxhc3RSZW5kZXJlZFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pOyAvLyBTdGFzaCB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZSwgYW5kIHRoZSByZWR1Y2VyIHVzZWQgdG8gY29tcHV0ZVxuICAgICAgICAgIC8vIGl0LCBvbiB0aGUgdXBkYXRlIG9iamVjdC4gSWYgdGhlIHJlZHVjZXIgaGFzbid0IGNoYW5nZWQgYnkgdGhlXG4gICAgICAgICAgLy8gdGltZSB3ZSBlbnRlciB0aGUgcmVuZGVyIHBoYXNlLCB0aGVuIHRoZSBlYWdlciBzdGF0ZSBjYW4gYmUgdXNlZFxuICAgICAgICAgIC8vIHdpdGhvdXQgY2FsbGluZyB0aGUgcmVkdWNlciBhZ2Fpbi5cblxuICAgICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG5cbiAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSkge1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbiAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgdmFyIHJvb3QgPSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKTtcbiAgICB9XG4gIH1cblxuICBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSk7XG59XG5cbmZ1bmN0aW9uIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgcmV0dXJuIGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICBpZiAoaXNJbnRlcmxlYXZlZFVwZGF0ZShmaWJlcikpIHtcbiAgICB2YXIgaW50ZXJsZWF2ZWQgPSBxdWV1ZS5pbnRlcmxlYXZlZDtcblxuICAgIGlmIChpbnRlcmxlYXZlZCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7IC8vIEF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgcmVuZGVyLCB0aGlzIHF1ZXVlJ3MgaW50ZXJsZWF2ZWQgdXBkYXRlcyB3aWxsXG4gICAgICAvLyBiZSB0cmFuc2ZlcnJlZCB0byB0aGUgcGVuZGluZyBxdWV1ZS5cblxuICAgICAgcHVzaEludGVybGVhdmVkUXVldWUocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGUubmV4dCA9IGludGVybGVhdmVkLm5leHQ7XG4gICAgICBpbnRlcmxlYXZlZC5uZXh0ID0gdXBkYXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmludGVybGVhdmVkID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcblxuICAgIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpIHtcbiAgaWYgKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpIHtcbiAgICB2YXIgcXVldWVMYW5lcyA9IHF1ZXVlLmxhbmVzOyAvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5XG4gICAgLy8gbXVzdCBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaFxuICAgIC8vIHJlcHJlc2VudHMgYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZVxuICAgIC8vIG1heSBlbnRhbmdsZSBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmXG4gICAgLy8gd2UgKmRvbid0KiBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cblxuICAgIHF1ZXVlTGFuZXMgPSBpbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLCByb290LnBlbmRpbmdMYW5lcyk7IC8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG5cbiAgICB2YXIgbmV3UXVldWVMYW5lcyA9IG1lcmdlTGFuZXMocXVldWVMYW5lcywgbGFuZSk7XG4gICAgcXVldWUubGFuZXMgPSBuZXdRdWV1ZUxhbmVzOyAvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG4gICAgLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbiAgICAvLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxuXG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbmV3UXVldWVMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUsIGFjdGlvbikge1xuXG4gIHtcbiAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICB9XG59XG5cbnZhciBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlQ2FsbGJhY2s6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlQ29udGV4dDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU1lbW86IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVkdWNlcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVidWdWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVRyYW5zaXRpb246IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTXV0YWJsZVNvdXJjZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJZDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbn07XG5cbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xuXG57XG4gIHZhciB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICB9O1xuXG4gIHZhciB3YXJuSW52YWxpZEhvb2tBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2UoKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZSgpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUlkKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcblxuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xufVxuXG52YXIgbm93JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xudmFyIGNvbW1pdFRpbWUgPSAwO1xudmFyIGxheW91dEVmZmVjdFN0YXJ0VGltZSA9IC0xO1xudmFyIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG52YXIgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IC0xO1xuLyoqXG4gKiBUcmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkL2Nhc2NhZGluZyB1cGRhdGUgKHNjaGVkdWxlZCBmcm9tIGEgbGF5b3V0IGVmZmVjdCkuXG4gKlxuICogVGhlIG92ZXJhbGwgc2VxdWVuY2UgaXM6XG4gKiAgIDEuIHJlbmRlclxuICogICAyLiBjb21taXQgKGFuZCBjYWxsIGBvblJlbmRlcmAsIGBvbkNvbW1pdGApXG4gKiAgIDMuIGNoZWNrIGZvciBuZXN0ZWQgdXBkYXRlc1xuICogICA0LiBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgKGFuZCBjYWxsIGBvblBvc3RDb21taXRgKVxuICpcbiAqIE5lc3RlZCB1cGRhdGVzIGFyZSBpZGVudGlmaWVkIGluIHN0ZXAgMyBhYm92ZSxcbiAqIGJ1dCBzdGVwIDQgc3RpbGwgYXBwbGllcyB0byB0aGUgd29yayB0aGF0IHdhcyBqdXN0IGNvbW1pdHRlZC5cbiAqIFdlIHVzZSB0d28gZmxhZ3MgdG8gdHJhY2sgbmVzdGVkIHVwZGF0ZXMgdGhlbjpcbiAqIG9uZSB0cmFja3Mgd2hldGhlciB0aGUgdXBjb21pbmcgdXBkYXRlIGlzIGEgbmVzdGVkIHVwZGF0ZSxcbiAqIGFuZCB0aGUgb3RoZXIgdHJhY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXBkYXRlIHdhcyBhIG5lc3RlZCB1cGRhdGUuXG4gKiBUaGUgZmlyc3QgdmFsdWUgZ2V0cyBzeW5jZWQgdG8gdGhlIHNlY29uZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHJlbmRlciBwaGFzZS5cbiAqL1xuXG52YXIgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gZmFsc2U7XG52YXIgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVJc05lc3RlZDtcbn1cblxuZnVuY3Rpb24gbWFya05lc3RlZFVwZGF0ZVNjaGVkdWxlZCgpIHtcbiAge1xuICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXROZXN0ZWRVcGRhdGVGbGFnKCkge1xuICB7XG4gICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gZmFsc2U7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY05lc3RlZFVwZGF0ZUZsYWcoKSB7XG4gIHtcbiAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQ7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpIHtcbiAgcmV0dXJuIGNvbW1pdFRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlY29yZENvbW1pdFRpbWUoKSB7XG5cbiAgY29tbWl0VGltZSA9IG5vdyQxKCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93JDEoKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdyQxKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoZmliZXIpIHtcblxuICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLCBvdmVycmlkZUJhc2VUaW1lKSB7XG5cbiAgaWYgKHByb2ZpbGVyU3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3ckMSgpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG5cbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cblxuICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmliZXIpIHtcblxuICBpZiAobGF5b3V0RWZmZWN0U3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3ckMSgpIC0gbGF5b3V0RWZmZWN0U3RhcnRUaW1lO1xuICAgIGxheW91dEVmZmVjdFN0YXJ0VGltZSA9IC0xOyAvLyBTdG9yZSBkdXJhdGlvbiBvbiB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yXG4gICAgLy8gT3IgdGhlIHJvb3QgKGZvciB0aGUgRGV2VG9vbHMgUHJvZmlsZXIgdG8gcmVhZClcblxuICAgIHZhciBwYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcblxuICAgIHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgcGFyZW50U3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3ckMSgpIC0gcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZTtcbiAgICBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gLTE7IC8vIFN0b3JlIGR1cmF0aW9uIG9uIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3JcbiAgICAvLyBPciB0aGUgcm9vdCAoZm9yIHRoZSBEZXZUb29scyBQcm9maWxlciB0byByZWFkKVxuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuXG4gICAgd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAocGFyZW50U3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXRhY2hlZCBmaWJlcnMgaGF2ZSB0aGVpciBzdGF0ZSBub2RlIGNsZWFyZWQgb3V0LlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgcmV0dXJuIHBvaW50ZXIgaXMgYWxzbyBjbGVhcmVkIG91dCxcbiAgICAgICAgICAgIC8vIHNvIHdlIHdvbid0IGJlIGFibGUgdG8gcmVwb3J0IHRoZSB0aW1lIHNwZW50IGluIHRoaXMgUHJvZmlsZXIncyBzdWJ0cmVlLlxuICAgICAgICAgICAgcGFyZW50U3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydExheW91dEVmZmVjdFRpbWVyKCkge1xuXG4gIGxheW91dEVmZmVjdFN0YXJ0VGltZSA9IG5vdyQxKCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCkge1xuXG4gIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSBub3ckMSgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKSB7XG4gIC8vIFRyYW5zZmVyIHRpbWUgc3BlbnQgcmVuZGVyaW5nIHRoZXNlIGNoaWxkcmVuIHNvIHdlIGRvbid0IGxvc2UgaXRcbiAgLy8gYWZ0ZXIgd2UgcmVyZW5kZXIuIFRoaXMgaXMgdXNlZCBhcyBhIGhlbHBlciBpbiBzcGVjaWFsIGNhc2VzXG4gIC8vIHdoZXJlIHdlIHNob3VsZCBjb3VudCB0aGUgd29yayBvZiBtdWx0aXBsZSBwYXNzZXMuXG4gIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2UpIHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gIH07XG59XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGZvcmtlZCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLlxuLy8gQnkgZGVmYXVsdCwgcmV0dXJuIGB0cnVlYCB0byBsb2cgZXJyb3JzIHRvIHRoZSBjb25zb2xlLlxuLy8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuZnVuY3Rpb24gc2hvd0Vycm9yRGlhbG9nKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoYm91bmRhcnksIGVycm9ySW5mbykge1xuICB0cnkge1xuICAgIHZhciBsb2dFcnJvciA9IHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKTsgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG5cbiAgICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgaWYgKHRydWUpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnOyAvLyBCcm93c2VycyBzdXBwb3J0IHNpbGVuY2luZyB1bmNhdWdodCBlcnJvcnMgYnkgY2FsbGluZ1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGluIHdpbmRvdyBgZXJyb3JgIGhhbmRsZXIuXG4gICAgICAvLyBXZSByZWNvcmQgdGhpcyBpbmZvcm1hdGlvbiBhcyBhbiBleHBhbmRvIG9uIHRoZSBlcnJvci5cblxuICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgZXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICBpZiAoYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIC8vIFRoZSBlcnJvciBpcyByZWNvdmVyYWJsZSBhbmQgd2FzIHNpbGVuY2VkLlxuICAgICAgICAgIC8vIElnbm9yZSBpdCBhbmQgZG9uJ3QgcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuICAgICAgICAgIC8vIFRoaXMgaXMgaGFuZHkgZm9yIHRlc3RpbmcgZXJyb3IgYm91bmRhcmllcyB3aXRob3V0IG5vaXNlLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBUaGUgZXJyb3IgaXMgZmF0YWwuIFNpbmNlIHRoZSBzaWxlbmNpbmcgbWlnaHQgaGF2ZVxuICAgICAgICAvLyBiZWVuIGFjY2lkZW50YWwsIHdlJ2xsIHN1cmZhY2UgaXQgYW55d2F5LlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYnJvd3NlciB3b3VsZCBoYXZlIHNpbGVuY2VkIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAvLyBzbyB3ZSdsbCBwcmludCBpdCBmaXJzdCwgYW5kIHRoZW4gcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuXG5cbiAgICAgICAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgICAgICAvLyBGb3IgYSBtb3JlIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoaXMgYmxvY2ssIHNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBzb3VyY2UgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHNvdXJjZSkgOiBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudDpcIiA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlO1xuXG4gICAgICBpZiAoYm91bmRhcnkudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihib3VuZGFyeSkgfHwgJ0Fub255bW91cyc7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCBcIiArIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgZXJyb3JCb3VuZGFyeU5hbWUgKyBcIi5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSBjb21wb25lbnROYW1lTWVzc2FnZSArIFwiXFxuXCIgKyBjb21wb25lbnRTdGFjayArIFwiXFxuXFxuXCIgKyAoXCJcIiArIGVycm9yQm91bmRhcnlNZXNzYWdlKTsgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG5cbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oY29tYmluZWRNZXNzYWdlKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHdlIHByaW50IHRoZSBlcnJvciBkaXJlY3RseS5cbiAgICAgIC8vIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBtZXNzYWdlLCB0aGUgSlMgc3RhY2ssIGFuZCBhbnl0aGluZyB0aGUgYnJvd3NlciB3YW50cyB0byBzaG93LlxuICAgICAgLy8gV2UgcGFzcyB0aGUgZXJyb3Igb2JqZWN0IGluc3RlYWQgb2YgY3VzdG9tIG1lc3NhZ2Ugc28gdGhhdCB0aGUgYnJvd3NlciBkaXNwbGF5cyB0aGUgZXJyb3IgbmF0aXZlbHkuXG4gICAgICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbXVzdCBub3QgdGhyb3csIG9yIFJlYWN0IGludGVybmFsIHN0YXRlIHdpbGwgZ2V0IG1lc3NlZCB1cC5cbiAgICAvLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbiAgICAvLyB3ZSB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yIG91dHNpZGUgb2YgdGhlIG5vcm1hbCBzdGFjayBhcyBhIGxhc3QgcmVzb3J0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMxODhcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIFBvc3NpYmx5V2Vha01hcCQxID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuXG5mdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgbGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTsgLy8gVW5tb3VudCB0aGUgcm9vdCBieSByZW5kZXJpbmcgbnVsbC5cblxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdXBkYXRlLnBheWxvYWQgPSB7XG4gICAgZWxlbWVudDogbnVsbFxuICB9O1xuICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvciQxKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAge1xuICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICB9XG5cbiAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gIGlmIChpbnN0ICE9PSBudWxsICYmIHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcblxuICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9yJDEsIHtcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJ1xuICAgICAgfSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZCxcbiAgICAgICAgICAvLyB0aGVuIGl0IG5lZWRzIHRvIGNhbGwgc2V0U3RhdGUgdG8gcmVjb3ZlciBmcm9tIGVycm9ycy5cbiAgICAgICAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgaXMgc2NoZWR1bGVkIHRoZW4gdGhlIGJvdW5kYXJ5IHdpbGwgc3dhbGxvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKGZpYmVyLmxhbmVzLCBTeW5jTGFuZSkpIHtcbiAgICAgICAgICAgIGVycm9yKCclczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiAnICsgJ0luIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgLy8gQXR0YWNoIGEgcGluZyBsaXN0ZW5lclxuICAvL1xuICAvLyBUaGUgZGF0YSBtaWdodCByZXNvbHZlIGJlZm9yZSB3ZSBoYXZlIGEgY2hhbmNlIHRvIGNvbW1pdCB0aGUgZmFsbGJhY2suIE9yLFxuICAvLyBpbiB0aGUgY2FzZSBvZiBhIHJlZnJlc2gsIHdlJ2xsIG5ldmVyIGNvbW1pdCBhIGZhbGxiYWNrLiBTbyB3ZSBuZWVkIHRvXG4gIC8vIGF0dGFjaCBhIGxpc3RlbmVyIG5vdy4gV2hlbiBpdCByZXNvbHZlcyAoXCJwaW5nc1wiKSwgd2UgY2FuIGRlY2lkZSB3aGV0aGVyIHRvXG4gIC8vIHRyeSByZW5kZXJpbmcgdGhlIHRyZWUgYWdhaW4uXG4gIC8vXG4gIC8vIE9ubHkgYXR0YWNoIGEgbGlzdGVuZXIgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoZSBsYW5lc1xuICAvLyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaCBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICAvL1xuICAvLyBXZSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpbiBjb25jdXJyZW50IG1vZGUuIExlZ2FjeSBTdXNwZW5zZSBhbHdheXNcbiAgLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHM7XG5cbiAgaWYgKHBpbmdDYWNoZSA9PT0gbnVsbCkge1xuICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG4gICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSk7XG5cbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aHJlYWRJRHMuaGFzKGxhbmVzKSkge1xuICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIHRocmVhZCBJRCB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG4gICAgdmFyIHBpbmcgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcyk7XG5cbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzXG4gICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdha2VhYmxlLnRoZW4ocGluZywgcGluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0YWNoUmV0cnlMaXN0ZW5lcihzdXNwZW5zZUJvdW5kYXJ5LCByb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgLy8gUmV0cnkgbGlzdGVuZXJcbiAgLy9cbiAgLy8gSWYgdGhlIGZhbGxiYWNrIGRvZXMgY29tbWl0LCB3ZSBuZWVkIHRvIGF0dGFjaCBhIGRpZmZlcmVudCB0eXBlIG9mXG4gIC8vIGxpc3RlbmVyLiBUaGlzIG9uZSBzY2hlZHVsZXMgYW4gdXBkYXRlIG9uIHRoZSBTdXNwZW5zZSBib3VuZGFyeSB0byB0dXJuXG4gIC8vIHRoZSBmYWxsYmFjayBzdGF0ZSBvZmYuXG4gIC8vXG4gIC8vIFN0YXNoIHRoZSB3YWtlYWJsZSBvbiB0aGUgYm91bmRhcnkgZmliZXIgc28gd2UgY2FuIGFjY2VzcyBpdCBpbiB0aGVcbiAgLy8gY29tbWl0IHBoYXNlLlxuICAvL1xuICAvLyBXaGVuIHRoZSB3YWtlYWJsZSByZXNvbHZlcywgd2UnbGwgYXR0ZW1wdCB0byByZW5kZXIgdGhlIGJvdW5kYXJ5XG4gIC8vIGFnYWluIChcInJldHJ5XCIpLlxuICB2YXIgd2FrZWFibGVzID0gc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzID09PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gbmV3IFNldCgpO1xuICAgIHVwZGF0ZVF1ZXVlLmFkZCh3YWtlYWJsZSk7XG4gICAgc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlO1xuICB9IGVsc2Uge1xuICAgIHdha2VhYmxlcy5hZGQod2FrZWFibGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3VzcGVuZGVkQ29tcG9uZW50KHNvdXJjZUZpYmVyLCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gQSBsZWdhY3kgbW9kZSBTdXNwZW5zZSBxdWlyaywgb25seSByZWxldmFudCB0byBob29rIGNvbXBvbmVudHMuXG5cblxuICB2YXIgdGFnID0gc291cmNlRmliZXIudGFnO1xuXG4gIGlmICgoc291cmNlRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlICYmICh0YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50IHx8IHRhZyA9PT0gRm9yd2FyZFJlZiB8fCB0YWcgPT09IFNpbXBsZU1lbW9Db21wb25lbnQpKSB7XG4gICAgdmFyIGN1cnJlbnRTb3VyY2UgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudFNvdXJjZSkge1xuICAgICAgc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBjdXJyZW50U291cmNlLnVwZGF0ZVF1ZXVlO1xuICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnRTb3VyY2UubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gY3VycmVudFNvdXJjZS5sYW5lcztcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJlc3RTdXNwZW5zZUJvdW5kYXJ5VG9DYXB0dXJlKHJldHVybkZpYmVyKSB7XG4gIHZhciBub2RlID0gcmV0dXJuRmliZXI7XG5cbiAgZG8ge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IC8vIFRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZSBuZXh0XG4gICAgLy8gYm91bmRhcnkuXG5cblxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIG1hcmtzIGEgU3VzcGVuc2UgYm91bmRhcnkgc28gdGhhdCB3aGVuIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2ssXG4gIC8vIGl0IGNhcHR1cmVzIHRoZSBzdXNwZW5kZWQgXCJleGNlcHRpb25cIiBhbmQgZG9lcyBhIHNlY29uZCAoZmFsbGJhY2spIHBhc3MuXG4gIGlmICgoc3VzcGVuc2VCb3VuZGFyeS5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAvLyBMZWdhY3kgTW9kZSBTdXNwZW5zZVxuICAgIC8vXG4gICAgLy8gSWYgdGhlIGJvdW5kYXJ5IGlzIGluIGxlZ2FjeSBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbiAgICAvLyBzdXNwZW5kIHRoZSBjb21taXQuIFByZXRlbmQgYXMgaWYgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcmVuZGVyZWRcbiAgICAvLyBudWxsIGFuZCBrZWVwIHJlbmRlcmluZy4gV2hlbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgY29tcGxldGVzLFxuICAgIC8vIHdlJ2xsIGRvIGEgc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay5cbiAgICBpZiAoc3VzcGVuc2VCb3VuZGFyeSA9PT0gcmV0dXJuRmliZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBzdXNwZW5kZWQgd2hpbGUgcmVjb25jaWxpbmcgdGhlIGNoaWxkcmVuIG9mXG4gICAgICAvLyBhIFN1c3BlbnNlIGJvdW5kYXJ5J3MgaW5uZXIgT2Zmc2NyZWVuIHdyYXBwZXIgZmliZXIuIFRoaXMgaGFwcGVuc1xuICAgICAgLy8gd2hlbiBhIFJlYWN0LmxhenkgY29tcG9uZW50IGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbiAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LlxuICAgICAgLy9cbiAgICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIGltcGxlbWVudGVkIGFzIG11bHRpcGxlIGZpYmVycywgYnV0IHRoZXlcbiAgICAgIC8vIGFyZSBhIHNpbmdsZSBjb25jZXB0dWFsIHVuaXQuIFRoZSBsZWdhY3kgbW9kZSBiZWhhdmlvciB3aGVyZSB3ZVxuICAgICAgLy8gcHJldGVuZCB0aGUgc3VzcGVuZGVkIGZpYmVyIGNvbW1pdHRlZCBhcyBgbnVsbGAgd29uJ3Qgd29yayxcbiAgICAgIC8vIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHRoZSBcInN1c3BlbmRlZFwiIGZpYmVyIGlzIHRoZSBpbm5lclxuICAgICAgLy8gT2Zmc2NyZWVuIHdyYXBwZXIuXG4gICAgICAvL1xuICAgICAgLy8gQmVjYXVzZSB0aGUgY29udGVudHMgb2YgdGhlIGJvdW5kYXJ5IGhhdmVuJ3Qgc3RhcnRlZCByZW5kZXJpbmdcbiAgICAgIC8vIHlldCAoaS5lLiBub3RoaW5nIGluIHRoZSB0cmVlIGhhcyBwYXJ0aWFsbHkgcmVuZGVyZWQpIHdlIGNhblxuICAgICAgLy8gc3dpdGNoIHRvIHRoZSByZWd1bGFyLCBjb25jdXJyZW50IG1vZGUgYmVoYXZpb3I6IG1hcmsgdGhlXG4gICAgICAvLyBib3VuZGFyeSB3aXRoIFNob3VsZENhcHR1cmUgYW5kIGVudGVyIHRoZSB1bndpbmQgcGhhc2UuXG4gICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2U7IC8vIFdlJ3JlIGdvaW5nIHRvIGNvbW1pdCB0aGlzIGZpYmVyIGV2ZW4gdGhvdWdoIGl0IGRpZG4ndCBjb21wbGV0ZS5cbiAgICAgIC8vIEJ1dCB3ZSBzaG91bGRuJ3QgY2FsbCBhbnkgbGlmZWN5Y2xlIG1ldGhvZHMgb3IgY2FsbGJhY2tzLiBSZW1vdmVcbiAgICAgIC8vIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG5cbiAgICAgIHNvdXJjZUZpYmVyLmZsYWdzICY9IH4oTGlmZWN5Y2xlRWZmZWN0TWFzayB8IEluY29tcGxldGUpO1xuXG4gICAgICBpZiAoc291cmNlRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgY3VycmVudFNvdXJjZUZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChjdXJyZW50U291cmNlRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IG1vdW50LiBDaGFuZ2UgdGhlIHRhZyBzbyBpdCdzIG5vdCBtaXN0YWtlbiBmb3IgYVxuICAgICAgICAgIC8vIGNvbXBsZXRlZCBjbGFzcyBjb21wb25lbnQuIEZvciBleGFtcGxlLCB3ZSBzaG91bGQgbm90IGNhbGxcbiAgICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBpZiBpdCBpcyBkZWxldGVkLlxuICAgICAgICAgIHNvdXJjZUZpYmVyLnRhZyA9IEluY29tcGxldGVDbGFzc0NvbXBvbmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIHRyeSByZW5kZXJpbmcgYWdhaW4sIHdlIHNob3VsZCBub3QgcmV1c2UgdGhlIGN1cnJlbnQgZmliZXIsXG4gICAgICAgICAgLy8gc2luY2UgaXQncyBrbm93biB0byBiZSBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFVzZSBhIGZvcmNlIHVwZGF0ZSB0b1xuICAgICAgICAgIC8vIHByZXZlbnQgYSBiYWlsIG91dC5cbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBTeW5jTGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgIGVucXVldWVVcGRhdGUoc291cmNlRmliZXIsIHVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLiBNYXJrIGl0IHdpdGggU3luYyBwcmlvcml0eSB0b1xuICAgICAgLy8gaW5kaWNhdGUgdGhhdCBpdCBzdGlsbCBoYXMgcGVuZGluZyB3b3JrLlxuXG5cbiAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgU3luY0xhbmUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdXNwZW5zZUJvdW5kYXJ5O1xuICB9IC8vIENvbmZpcm1lZCB0aGF0IHRoZSBib3VuZGFyeSBpcyBpbiBhIGNvbmN1cnJlbnQgbW9kZSB0cmVlLiBDb250aW51ZVxuICAvLyB3aXRoIHRoZSBub3JtYWwgc3VzcGVuZCBwYXRoLlxuICAvL1xuICAvLyBBZnRlciB0aGlzIHdlJ2xsIHVzZSBhIHNldCBvZiBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGV0aGVyIHRoaXNcbiAgLy8gcmVuZGVyIHBhc3Mgd2lsbCBydW4gdG8gY29tcGxldGlvbiBvciByZXN0YXJ0IG9yIFwic3VzcGVuZFwiIHRoZSBjb21taXQuXG4gIC8vIFRoZSBhY3R1YWwgbG9naWMgZm9yIHRoaXMgaXMgc3ByZWFkIG91dCBpbiBkaWZmZXJlbnQgcGxhY2VzLlxuICAvL1xuICAvLyBUaGlzIGZpcnN0IHByaW5jaXBsZSBpcyB0aGF0IGlmIHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2hlbiB3ZSBjb21wbGV0ZVxuICAvLyBhIHJvb3QsIHRoZW4gd2Ugc2hvdWxkIGFsc28gcmVzdGFydCBpZiB3ZSBnZXQgYW4gdXBkYXRlIG9yIHBpbmcgdGhhdFxuICAvLyBtaWdodCB1bnN1c3BlbmQgaXQsIGFuZCB2aWNlIHZlcnNhLiBUaGUgb25seSByZWFzb24gdG8gc3VzcGVuZCBpc1xuICAvLyBiZWNhdXNlIHlvdSB0aGluayB5b3UgbWlnaHQgd2FudCB0byByZXN0YXJ0IGJlZm9yZSBjb21taXR0aW5nLiBIb3dldmVyLFxuICAvLyBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gcmVzdGFydCBvbmx5IHdoaWxlIGluIHRoZSBwZXJpb2Qgd2UncmUgc3VzcGVuZGVkLlxuICAvL1xuICAvLyBSZXN0YXJ0aW5nIHRvbyBhZ2dyZXNzaXZlbHkgaXMgYWxzbyBub3QgZ29vZCBiZWNhdXNlIGl0IHN0YXJ2ZXMgb3V0IGFueVxuICAvLyBpbnRlcm1lZGlhdGUgbG9hZGluZyBzdGF0ZS4gU28gd2UgdXNlIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZW4uXG4gIC8vIFN1c3BlbnNlIEhldXJpc3RpY3NcbiAgLy9cbiAgLy8gSWYgbm90aGluZyB0aHJldyBhIFByb21pc2Ugb3IgYWxsIHRoZSBzYW1lIGZhbGxiYWNrcyBhcmUgYWxyZWFkeSBzaG93aW5nLFxuICAvLyB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC5cbiAgLy9cbiAgLy8gSWYgdGhpcyBpcyBhbiBpbml0aWFsIHJlbmRlciBvZiBhIG5ldyB0cmVlIG9mIFN1c3BlbnNlIGJvdW5kYXJpZXMgYW5kXG4gIC8vIHRob3NlIHRyaWdnZXIgYSBmYWxsYmFjaywgdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgY2FuIHNob3cgdGhlIGluaXRpYWwgbG9hZGluZyBzdGF0ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuICAvL1xuICAvLyBJZiB3ZSBoaXQgYSBcIkRlbGF5ZWRcIiBjYXNlLCBzdWNoIGFzIHdoZW4gd2UnZCBzd2l0Y2ggZnJvbSBjb250ZW50IGJhY2sgaW50b1xuICAvLyBhIGZhbGxiYWNrLCB0aGVuIHdlIHNob3VsZCBhbHdheXMgc3VzcGVuZC9yZXN0YXJ0LiBUcmFuc2l0aW9ucyBhcHBseVxuICAvLyB0byB0aGlzIGNhc2UuIElmIG5vbmUgaXMgZGVmaW5lZCwgSk5EIGlzIHVzZWQgaW5zdGVhZC5cbiAgLy9cbiAgLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgYW5kIGl0IGdldHMgXCJyZXRyaWVkXCIsIGFsbG93aW5nIHVzIHRvIHNob3dcbiAgLy8gYW5vdGhlciBsZXZlbCwgYnV0IHRoZXJlJ3Mgc3RpbGwgYW4gaW5uZXIgYm91bmRhcnkgdGhhdCB3b3VsZCBzaG93IGEgZmFsbGJhY2ssXG4gIC8vIHRoZW4gd2Ugc3VzcGVuZC9yZXN0YXJ0IGZvciA1MDBtcyBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIHNob3dlZCBhIGZhbGxiYWNrXG4gIC8vIGFueXdoZXJlIGluIHRoZSB0cmVlLiBUaGlzIGVmZmVjdGl2ZWx5IHRocm90dGxlcyBwcm9ncmVzc2l2ZSBsb2FkaW5nIGludG8gYVxuICAvLyBjb25zaXN0ZW50IHRyYWluIG9mIGNvbW1pdHMuIFRoaXMgYWxzbyBnaXZlcyB1cyBhbiBvcHBvcnR1bml0eSB0byByZXN0YXJ0IHRvXG4gIC8vIGdldCB0byB0aGUgY29tcGxldGVkIHN0YXRlIHNsaWdodGx5IGVhcmxpZXIuXG4gIC8vXG4gIC8vIElmIHRoZXJlJ3MgYW1iaWd1aXR5IGR1ZSB0byBiYXRjaGluZyBpdCdzIHJlc29sdmVkIGluIHByZWZlcmVuY2Ugb2Y6XG4gIC8vIDEpIFwiZGVsYXllZFwiLCAyKSBcImluaXRpYWwgcmVuZGVyXCIsIDMpIFwicmV0cnlcIi5cbiAgLy9cbiAgLy8gV2Ugd2FudCB0byBlbnN1cmUgdGhhdCBhIFwiYnVzeVwiIHN0YXRlIGRvZXNuJ3QgZ2V0IGZvcmNlIGNvbW1pdHRlZC4gV2Ugd2FudCB0b1xuICAvLyBlbnN1cmUgdGhhdCBuZXcgaW5pdGlhbCBsb2FkaW5nIHN0YXRlcyBjYW4gY29tbWl0IGFzIHNvb24gYXMgcG9zc2libGUuXG5cblxuICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNob3VsZENhcHR1cmU7IC8vIFRPRE86IEkgdGhpbmsgd2UgY2FuIHJlbW92ZSB0aGlzLCBzaW5jZSB3ZSBub3cgdXNlIGBEaWRDYXB0dXJlYCBpblxuICAvLyB0aGUgYmVnaW4gcGhhc2UgdG8gcHJldmVudCBhbiBlYXJseSBiYWlsb3V0LlxuXG4gIHN1c3BlbnNlQm91bmRhcnkubGFuZXMgPSByb290UmVuZGVyTGFuZXM7XG4gIHJldHVybiBzdXNwZW5zZUJvdW5kYXJ5O1xufVxuXG5mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuXG4gIHtcbiAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCByZXN0b3JlIHRoZSBvcmlnaW5hbCB1cGRhdGVyc1xuICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCByb290UmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVGhpcyBpcyBhIHdha2VhYmxlLiBUaGUgY29tcG9uZW50IHN1c3BlbmRlZC5cbiAgICB2YXIgd2FrZWFibGUgPSB2YWx1ZTtcbiAgICByZXNldFN1c3BlbmRlZENvbXBvbmVudChzb3VyY2VGaWJlcik7XG5cbiAgICB7XG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBzb3VyY2VGaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcbiAgICAgICAgbWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIHZhciBzdXNwZW5zZUJvdW5kYXJ5ID0gZ2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUocmV0dXJuRmliZXIpO1xuXG4gICAgaWYgKHN1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgJj0gfkZvcmNlQ2xpZW50UmVuZGVyO1xuICAgICAgbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKTsgLy8gV2Ugb25seSBhdHRhY2ggcGluZyBsaXN0ZW5lcnMgaW4gY29uY3VycmVudCBtb2RlLiBMZWdhY3kgU3VzcGVuc2UgYWx3YXlzXG4gICAgICAvLyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmUgbm8gcGluZ3MuXG5cbiAgICAgIGlmIChzdXNwZW5zZUJvdW5kYXJ5Lm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIGF0dGFjaFJldHJ5TGlzdGVuZXIoc3VzcGVuc2VCb3VuZGFyeSwgcm9vdCwgd2FrZWFibGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBib3VuZGFyeSB3YXMgZm91bmQuIFVubGVzcyB0aGlzIGlzIGEgc3luYyB1cGRhdGUsIHRoaXMgaXMgT0suXG4gICAgICAvLyBXZSBjYW4gc3VzcGVuZCBhbmQgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cbiAgICAgIGlmICghaW5jbHVkZXNTeW5jTGFuZShyb290UmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgbm90IGEgc3luYyB1cGRhdGUuIFN1c3BlbmQuIFNpbmNlIHdlJ3JlIG5vdCBhY3RpdmF0aW5nIGFcbiAgICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcnksIHRoaXMgd2lsbCB1bndpbmQgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3Qgd2l0aG91dFxuICAgICAgICAvLyBwZXJmb3JtaW5nIGEgc2Vjb25kIHBhc3MgdG8gcmVuZGVyIGEgZmFsbGJhY2suIChUaGlzIGlzIGFyZ3VhYmx5IGhvd1xuICAgICAgICAvLyByZWZyZXNoIHRyYW5zaXRpb25zIHNob3VsZCB3b3JrLCB0b28sIHNpbmNlIHdlJ3JlIG5vdCBnb2luZyB0byBjb21taXRcbiAgICAgICAgLy8gdGhlIGZhbGxiYWNrcyBhbnl3YXkuKVxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGlzIGNhc2UgYWxzbyBhcHBsaWVzIHRvIGluaXRpYWwgaHlkcmF0aW9uLlxuICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGlzIGlzIGEgc3luYy9kaXNjcmV0ZSB1cGRhdGUuIFdlIHRyZWF0IHRoaXMgY2FzZSBsaWtlIGFuIGVycm9yXG4gICAgICAvLyBiZWNhdXNlIGRpc2NyZXRlIHJlbmRlcnMgYXJlIGV4cGVjdGVkIHRvIHByb2R1Y2UgYSBjb21wbGV0ZSB0cmVlXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IHRvIG1haW50YWluIGNvbnNpc3RlbmN5IHdpdGggZXh0ZXJuYWwgc3RhdGUuXG5cblxuICAgICAgdmFyIHVuY2F1Z2h0U3VzcGVuc2VFcnJvciA9IG5ldyBFcnJvcignQSBjb21wb25lbnQgc3VzcGVuZGVkIHdoaWxlIHJlc3BvbmRpbmcgdG8gc3luY2hyb25vdXMgaW5wdXQuIFRoaXMgJyArICd3aWxsIGNhdXNlIHRoZSBVSSB0byBiZSByZXBsYWNlZCB3aXRoIGEgbG9hZGluZyBpbmRpY2F0b3IuIFRvICcgKyAnZml4LCB1cGRhdGVzIHRoYXQgc3VzcGVuZCBzaG91bGQgYmUgd3JhcHBlZCAnICsgJ3dpdGggc3RhcnRUcmFuc2l0aW9uLicpOyAvLyBJZiB3ZSdyZSBvdXRzaWRlIGEgdHJhbnNpdGlvbiwgZmFsbCB0aHJvdWdoIHRvIHRoZSByZWd1bGFyIGVycm9yIHBhdGguXG4gICAgICAvLyBUaGUgZXJyb3Igd2lsbCBiZSBjYXVnaHQgYnkgdGhlIG5lYXJlc3Qgc3VzcGVuc2UgYm91bmRhcnkuXG5cbiAgICAgIHZhbHVlID0gdW5jYXVnaHRTdXNwZW5zZUVycm9yO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVndWxhciBlcnJvciwgbm90IGEgU3VzcGVuc2Ugd2FrZWFibGUuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgc291cmNlRmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICBtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO1xuXG4gICAgICB2YXIgX3N1c3BlbnNlQm91bmRhcnkgPSBnZXROZWFyZXN0U3VzcGVuc2VCb3VuZGFyeVRvQ2FwdHVyZShyZXR1cm5GaWJlcik7IC8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGR1cmluZyBoeWRyYXRpb24sIHdlIG1heSBiZSBhYmxlIHRvIHJlY292ZXIgYnlcbiAgICAgIC8vIGRpc2NhcmRpbmcgdGhlIGRlaHlkcmF0ZWQgY29udGVudCBhbmQgc3dpdGNoaW5nIHRvIGEgY2xpZW50IHJlbmRlci5cbiAgICAgIC8vIEluc3RlYWQgb2Ygc3VyZmFjaW5nIHRoZSBlcnJvciwgZmluZCB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeVxuICAgICAgLy8gYW5kIHJlbmRlciBpdCBhZ2FpbiB3aXRob3V0IGh5ZHJhdGlvbi5cblxuXG4gICAgICBpZiAoX3N1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKChfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmIFNob3VsZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgLy8gU2V0IGEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHdlIHNob3VsZCB0cnkgcmVuZGVyaW5nIHRoZSBub3JtYWxcbiAgICAgICAgICAvLyBjaGlsZHJlbiBhZ2Fpbiwgbm90IHRoZSBmYWxsYmFjay5cbiAgICAgICAgICBfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShfc3VzcGVuc2VCb3VuZGFyeSwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByb290LCByb290UmVuZGVyTGFuZXMpOyAvLyBFdmVuIHRob3VnaCB0aGUgdXNlciBtYXkgbm90IGJlIGFmZmVjdGVkIGJ5IHRoaXMgZXJyb3IsIHdlIHNob3VsZFxuICAgICAgICAvLyBzdGlsbCBsb2cgaXQgc28gaXQgY2FuIGJlIGZpeGVkLlxuXG4gICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IodmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG5cbiAgcmVuZGVyRGlkRXJyb3IodmFsdWUpO1xuICB2YWx1ZSA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG5cbiAgZG8ge1xuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9lcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF9lcnJvckluZm8sIGxhbmUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cbiAgICAgICAgICB2YXIgX2xhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBfbGFuZSk7IC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuXG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgc3VzcGVuZHMuIEl0IHJldHVybnMgdGhlXG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICAvLyBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmU3RhdGljO1xuICB9XG59XG5cbnZhciBhcHBlbmRBbGxDaGlsZHJlbjtcbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQ7XG52YXIgdXBkYXRlSG9zdFRleHQ7XG5cbntcbiAgLy8gTXV0YXRpb24gbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykgey8vIE5vb3BcbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgLy8gSWYgd2UncmUgaHlkcmF0aW5nLCB3ZSBzaG91bGQgY29uc3VtZSBhcyBtYW55IGl0ZW1zIGFzIHdlIGNhblxuICAgIC8vIHNvIHdlIGRvbid0IGxlYXZlIGFueSBiZWhpbmQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAodGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsYXN0VGFpbE5vZGUgPSB0YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAobGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbGxhcHNlZCc6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgX3RhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChfdGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoX3RhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2xhc3RUYWlsTm9kZSA9IF90YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGFpbE5vZGUgPSBfdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChfbGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICBpZiAoIWhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayAmJiByZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBzdXNwZW5kZWQgZHVyaW5nIHRoZSBoZWFkLiBXZSB3YW50IHRvIHNob3cgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgICAvLyByb3cgYXQgdGhlIHRhaWwuIFNvIHdlJ2xsIGtlZXAgb24gYW5kIGN1dCBvZmYgdGhlIHJlc3QuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgX2xhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICB2YXIgZGlkQmFpbG91dCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuXG4gIGlmICghZGlkQmFpbG91dCkge1xuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoY2hpbGQubGFuZXMsIGNoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IGNoaWxkLmZsYWdzOyAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4gICAgICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgICAgIC8vIFdoZW4gd29yayBpcyBkb25lLCBpdCBzaG91bGQgYnViYmxlIHRvIHRoZSBwYXJlbnQncyBhY3R1YWxEdXJhdGlvbi4gSWZcbiAgICAgICAgLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuICAgICAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSW4gdGhhdCBjYXNlIGl0IHNob3VsZCBub3QgYnViYmxlLiBXZSBkZXRlcm1pbmUgd2hldGhlciBpdCB3YXNcbiAgICAgICAgLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cblxuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLCBfY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZC5mbGFnczsgLy8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuICAgICAgICAvLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbiAgICAgICAgLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5cbiAgICAgICAgX2NoaWxkLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgfSBlbHNlIHtcbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHZhciBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZDIgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQyLmxhbmVzLCBfY2hpbGQyLmNoaWxkTGFuZXMpKTsgLy8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGVtLlxuXG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gKz0gX2NoaWxkMi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gX2NoaWxkMi5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jaGlsZDMgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkMyAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZDMubGFuZXMsIF9jaGlsZDMuY2hpbGRMYW5lcykpOyAvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbiAgICAgICAgLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaWdub3JlIHRoZW0uXG5cbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDMuZmxhZ3MgJiBTdGF0aWNNYXNrOyAvLyBVcGRhdGUgdGhlIHJldHVybiBwb2ludGVyIHNvIHRoZSB0cmVlIGlzIGNvbnNpc3RlbnQuIFRoaXMgaXMgYSBjb2RlXG4gICAgICAgIC8vIHNtZWxsIGJlY2F1c2UgaXQgYXNzdW1lcyB0aGUgY29tbWl0IHBoYXNlIGlzIG5ldmVyIGNvbmN1cnJlbnQgd2l0aFxuICAgICAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLiBXaWxsIGFkZHJlc3MgZHVyaW5nIHJlZmFjdG9yIHRvIGFsdGVybmF0ZSBtb2RlbC5cblxuICAgICAgICBfY2hpbGQzLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZDMgPSBfY2hpbGQzLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICB9XG5cbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgcmV0dXJuIGRpZEJhaWxvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cblxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuXG4gICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjb21taXQgc2lkZS1lZmZlY3RzIG9uIHRoZSByb290LlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKCAvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2xpZW50IHJvb3RcbiAgICAgICAgICAgICAgIXByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQgfHwgLy8gQ2hlY2sgaWYgd2UgcmV2ZXJ0ZWQgdG8gY2xpZW50IHJlbmRlcmluZyAoZS5nLiBkdWUgdG8gYW4gZXJyb3IpXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dCBjb21taXQuIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSBvZiBSZWFjdCByZW5kZXJpbmcgaW50byBhXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmVyIHdpdGggcHJldmlvdXMgY2hpbGRyZW4uIEl0J3MgYWxzbyBzYWZlIHRvIGRvIGZvclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZXMgdG9vLCBiZWNhdXNlIGN1cnJlbnQuY2hpbGQgd291bGQgb25seSBiZSBudWxsIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIHJlbmRlciB3YXMgbnVsbCAoc28gdGhlIGNvbnRhaW5lciB3b3VsZCBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gYmUgZW1wdHkpLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90OyAvLyBJZiB0aGlzIHdhcyBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLCB0aGVyZSBtYXkgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgLy8gcmVjb3ZlcmFibGUgZXJyb3JzIGR1cmluZyBmaXJzdCBoeWRyYXRpb24gYXR0ZW1wdC4gSWYgc28sIGFkZFxuICAgICAgICAgICAgICAgIC8vIHRoZW0gdG8gYSBxdWV1ZSBzbyB3ZSBjYW4gbG9nIHRoZW0gaW4gdGhlIGNvbW1pdCBwaGFzZS5cblxuICAgICAgICAgICAgICAgIHVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBhZGQgdGhlbSB0b3AtPmRvd24gb3JcbiAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWQgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcblxuICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudC5tZW1vaXplZFByb3BzOyAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG5cbiAgICAgICAgICB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcgKyAnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH0gLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcblxuICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcblxuICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQyID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZDIpIHtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKGhhc1VuaHlkcmF0ZWRUYWlsTm9kZXMoKSAmJiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgd2FybklmVW5oeWRyYXRlZFRhaWxOb2Rlcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IEZvcmNlQ2xpZW50UmVuZGVyIHwgSW5jb21wbGV0ZSB8IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRTdGF0ZSAhPT0gbnVsbCAmJiBuZXh0U3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIGluc2lkZSBhIGh5ZHJhdGlvbiBzdGF0ZSB0aGUgZmlyc3QgdGltZSB3ZSdyZSBwaWNraW5nIHVwIHRoaXNcbiAgICAgICAgICAvLyBTdXNwZW5zZSBib3VuZGFyeSwgYW5kIGFsc28gYWZ0ZXIgd2UndmUgcmVlbnRlcmVkIGl0IGZvciBmdXJ0aGVyIGh5ZHJhdGlvbi5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkMyA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIV93YXNIeWRyYXRlZDMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuICcgKyAnVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBtaWdodCBoYXZlIHJlZW50ZXJlZCB0aGlzIGJvdW5kYXJ5IHRvIGh5ZHJhdGUgaXQuIElmIHNvLCB3ZSBuZWVkIHRvIHJlc2V0IHRoZSBoeWRyYXRpb25cbiAgICAgICAgICAgIC8vIHN0YXRlIHNpbmNlIHdlJ3JlIG5vdyBleGl0aW5nIG91dCBvZiBpdC4gcG9wSHlkcmF0aW9uU3RhdGUgZG9lc24ndCBkbyB0aGF0IGZvciB1cy5cbiAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcblxuICAgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgYm91bmRhcnkgZGlkIG5vdCBzdXNwZW5kIHNvIGl0J3Mgbm93IGh5ZHJhdGVkIGFuZCB1bnN1c3BlbmRlZC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBtYXJrIHRoaXMgYm91bmRhcnlcbiAgICAgICAgICAgIC8vIGFzIGhhdmluZyBoeWRyYXRlZCBzbyBldmVudHMga25vdyB0aGF0IHRoZXkncmUgZnJlZSB0byBiZSBpbnZva2VkLlxuICAgICAgICAgICAgLy8gSXQncyBhbHNvIGEgc2lnbmFsIHRvIHJlcGxheSBldmVudHMgYW5kIHRoZSBzdXNwZW5zZSBjYWxsYmFjay5cbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggcmV0cnkgbGlzdGVuZXJzLlxuICAgICAgICAgICAgLy8gU28gd2UgbWlnaHQgYXMgd2VsbCBhbHdheXMgbWFyayB0aGlzLlxuXG5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2lzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChfcHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBfcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgdGhpcyB0cmVlLiBJZiB0aGlzIHdhcyBhIGZvcmNlZCBjbGllbnQgcmVuZGVyLFxuICAgICAgICAvLyB0aGVyZSBtYXkgaGF2ZSBiZWVuIHJlY292ZXJhYmxlIGVycm9ycyBkdXJpbmcgZmlyc3QgaHlkcmF0aW9uXG4gICAgICAgIC8vIGF0dGVtcHQuIElmIHNvLCBhZGQgdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGVcbiAgICAgICAgLy8gY29tbWl0IHBoYXNlLlxuXG5cbiAgICAgICAgdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLiBSZS1yZW5kZXIgd2l0aCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lczsgLy8gRG8gbm90IHJlc2V0IHRoZSBlZmZlY3QgbGlzdC5cblxuICAgICAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcHJldkRpZFRpbWVvdXQgPSBfcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgcGFzc2l2ZSBlZmZlY3QsIHdoaWNoIGlzIHdoZW4gd2UgcHJvY2VzcyB0aGUgdHJhbnNpdGlvbnNcblxuXG4gICAgICAgIGlmIChuZXh0RGlkVGltZW91dCAhPT0gcHJldkRpZFRpbWVvdXQpIHtcbiAgICAgICAgICAvLyBhbiBlZmZlY3QgdG8gdG9nZ2xlIHRoZSBzdWJ0cmVlJ3MgdmlzaWJpbGl0eS4gV2hlbiB3ZSBzd2l0Y2ggZnJvbVxuICAgICAgICAgIC8vIGZhbGxiYWNrIC0+IHByaW1hcnksIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgc2NoZWR1bGVzIHRoaXMgZWZmZWN0XG4gICAgICAgICAgLy8gYXMgcGFydCBvZiBpdHMgbm9ybWFsIGNvbXBsZXRlIHBoYXNlLiBCdXQgd2hlbiB3ZSBzd2l0Y2ggZnJvbVxuICAgICAgICAgIC8vIHByaW1hcnkgLT4gZmFsbGJhY2ssIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgZG9lcyBub3QgaGF2ZSBhIGNvbXBsZXRlXG4gICAgICAgICAgLy8gcGhhc2UuIFNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgaXRzIGVmZmVjdCBoZXJlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gV2UgYWxzbyB1c2UgdGhpcyBmbGFnIHRvIGNvbm5lY3QvZGlzY29ubmVjdCB0aGUgZWZmZWN0cywgYnV0IHRoZSBzYW1lXG4gICAgICAgICAgLy8gbG9naWMgYXBwbGllczogd2hlbiByZS1jb25uZWN0aW5nLCB0aGUgT2Zmc2NyZWVuIGZpYmVyJ3MgY29tcGxldGVcbiAgICAgICAgICAvLyBwaGFzZSB3aWxsIGhhbmRsZSBzY2hlZHVsaW5nIHRoZSBlZmZlY3QuIEl0J3Mgb25seSB3aGVuIHRoZSBmYWxsYmFja1xuICAgICAgICAgIC8vIGlzIGFjdGl2ZSB0aGF0IHdlIGhhdmUgdG8gZG8gYW55dGhpbmcgc3BlY2lhbC5cblxuXG4gICAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgICAgICB2YXIgX29mZnNjcmVlbkZpYmVyMiA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgX29mZnNjcmVlbkZpYmVyMi5mbGFncyB8PSBWaXNpYmlsaXR5OyAvLyBUT0RPOiBUaGlzIHdpbGwgc3RpbGwgc3VzcGVuZCBhIHN5bmNocm9ub3VzIHRyZWUgaWYgYW55dGhpbmdcbiAgICAgICAgICAgIC8vIGluIHRoZSBjb25jdXJyZW50IHRyZWUgYWxyZWFkeSBzdXNwZW5kZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGtub3duIGJ1Zy5cblxuICAgICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGJhY2sgdG8gdGhyb3dFeGNlcHRpb24gYmVjYXVzZSB0aGlzIGlzIHRvbyBsYXRlXG4gICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2VcbiAgICAgICAgICAgICAgLy8gZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgcmVzdGFydCBhIHJlbmRlciBvciBub3QgdW50aWwgd2UgZ2V0XG4gICAgICAgICAgICAgIC8vIHRoaXMgbWFya2VyLCBhbmQgdGhpcyBpcyB0b28gbGF0ZS5cbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuICAgICAgICAgICAgICAvLyBhbmQgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSBrbm93IHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2VcbiAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFibGUgdG8gaW1tZWRpYXRlbHkgcmVzdGFydCBmcm9tIHdpdGhpbiB0aHJvd0V4Y2VwdGlvbi5cbiAgICAgICAgICAgICAgdmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCA9IGN1cnJlbnQgPT09IG51bGwgJiYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUgfHwgIWVuYWJsZVN1c3BlbnNlQXZvaWRUaGlzRmFsbGJhY2spO1xuXG4gICAgICAgICAgICAgIGlmIChoYXNJbnZpc2libGVDaGlsZENvbnRleHQgfHwgaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGluIGFuIGludmlzaWJsZSB0cmVlIG9yIGEgbmV3IHJlbmRlciwgdGhlbiBzaG93aW5nXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBpcyBvay5cbiAgICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIGhpZGUgY29udGVudCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBzdXNwZW5kIGZvciBsb25nZXIgaWYgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdha2VhYmxlcyA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh3YWtlYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gYXR0YWNoIGEgcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuXG4gICAgICAgICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgaWYgKF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBzdXBwb3J0IHR5cGUgY2FzdGluZyBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSAtPSBvcGVyYXRvclxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gU2FtZSBhcyBjbGFzcyBjb21wb25lbnQgY2FzZS4gSSBwdXQgaXQgZG93biBoZXJlIHNvIHRoYXQgdGhlIHRhZ3MgYXJlXG4gICAgICAgIC8vIHNlcXVlbnRpYWwgdG8gZW5zdXJlIHRoaXMgc3dpdGNoIGlzIGNvbXBpbGVkIHRvIGEganVtcCB0YWJsZS5cbiAgICAgICAgdmFyIF9Db21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihfQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiB0aGUgZGVmYXVsdCwgXCJpbmRlcGVuZGVudFwiIG1vZGUuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZFN1c3BlbmRBbHJlYWR5ID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG4gICAgICAgIHZhciByZW5kZXJlZFRhaWwgPSByZW5kZXJTdGF0ZS5yZW5kZXJpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4gICAgICAgICAgICAvLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3JcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbiAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbm5vdEJlU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBJZiB0aGlzIGlzIGEgbmV3bHkgc3VzcGVuZGVkIHRyZWUsIGl0IG1pZ2h0IG5vdCBnZXQgY29tbWl0dGVkIGFzXG4gICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGl0cyB0aGVuYWJsZXMuIEluc3RlYWQsIHdlJ2xsIHRyYW5zZmVyIGl0cyB0aGVuYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VGhlbmFibGVzID0gc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3VGhlbmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbmV3VGhlbmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJlZm9yZSBkb2luZyB0aGUgc2Vjb25kIHBhc3Mgc2luY2UgdGhhdCdzIG5vdyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTsgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcm93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwgJiYgbm93KCkgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGJ1dCB3ZSBzdGlsbCBoYXZlIHJvd3NcbiAgICAgICAgICAgICAgLy8gbGVmdCBpbiB0aGUgdGFpbC4gV2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXIgYXR0ZW1wdHMgdG8gcmVuZGVyXG4gICAgICAgICAgICAgIC8vIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGUgdGFpbC5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHZhciBfc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJlbmRlcmVkVGFpbCk7XG5cbiAgICAgICAgICAgIGlmIChfc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTsgLy8gRW5zdXJlIHdlIHRyYW5zZmVyIHRoZSB1cGRhdGUgcXVldWUgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxuXG4gICAgICAgICAgICAgIHZhciBfbmV3VGhlbmFibGVzID0gX3N1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICBpZiAoX25ld1RoZW5hYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gX25ld1RoZW5hYmxlcztcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIHRydWUpOyAvLyBUaGlzIG1pZ2h0IGhhdmUgYmVlbiBtb2RpZmllZC5cblxuICAgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCA9PT0gbnVsbCAmJiByZW5kZXJTdGF0ZS50YWlsTW9kZSA9PT0gJ2hpZGRlbicgJiYgIXJlbmRlcmVkVGFpbC5hbHRlcm5hdGUgJiYgIWdldElzSHlkcmF0aW5nKCkgLy8gV2UgZG9uJ3QgY3V0IGl0IGlmIHdlJ3JlIGh5ZHJhdGluZy5cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSdyZSBkb25lLlxuICAgICAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCAvLyBUaGUgdGltZSBpdCB0b29rIHRvIHJlbmRlciBsYXN0IHJvdyBpcyBncmVhdGVyIHRoYW4gdGhlIHJlbWFpbmluZ1xuICAgICAgICAgICAgLy8gdGltZSB3ZSBoYXZlIHRvIHJlbmRlci4gU28gcmVuZGVyaW5nIG9uZSBtb3JlIHJvdyB3b3VsZCBsaWtlbHlcbiAgICAgICAgICAgIC8vIGV4Y2VlZCBpdC5cbiAgICAgICAgICAgIG5vdygpICogMiAtIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSAmJiByZW5kZXJMYW5lcyAhPT0gT2Zmc2NyZWVuTGFuZSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIG5vdyBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBhbmQgd2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXJcbiAgICAgICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gcmVuZGVyIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgICAgLy8gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCB0aGlzIGlzIHVzdWFsbHkgZmFzdGVyLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcykge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdCBsaXN0IG9mIHRoZSBiYWNrd2FyZHMgdGFpbCB3aWxsIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGVuZC4gVGhpcyBicmVha3MgdGhlIGd1YXJhbnRlZSB0aGF0IGxpZmUtY3ljbGVzIGZpcmUgaW5cbiAgICAgICAgICAgIC8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuICAgICAgICAgICAgLy8gRXNwZWNpYWxseSBzaW5jZSB0aGVzZSBtaWdodCBhbHNvIGp1c3QgcG9wIGluIGR1cmluZyBmdXR1cmUgY29tbWl0cy5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAgICAgICAgcmVuZGVyZWRUYWlsLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gcmVuZGVyU3RhdGUubGFzdDtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcuc2libGluZyA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0ID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSB0YWlsIHJvd3MgdG8gcmVuZGVyLlxuICAgICAgICAgIC8vIFBvcCBhIHJvdy5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbmV4dDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbmV4dC5zaWJsaW5nO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIG5leHRJc0hpZGRlbiA9IF9uZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX3ByZXZTdGF0ZTIgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUyICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuICYmICggLy8gTGVnYWN5SGlkZGVuIGRvZXNuJ3QgZG8gYW55IGhpZGluZyDigJQgaXQgb25seSBwcmUtcmVuZGVycy5cbiAgICAgICAgICAhZW5hYmxlTGVnYWN5SGlkZGVuICkpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXh0SXNIaWRkZW4gfHwgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGZvciBoaWRkZW4gY2hpbGRyZW4gdW5sZXNzIHdlJ3JlIHJlbmRlcmluZ1xuICAgICAgICAgIC8vIGF0IG9mZnNjcmVlbiBwcmlvcml0eS5cbiAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSB3YXMgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZSBpbiB0aGUgaGlkZGVuIHN1YnRyZWUuXG4gICAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBuZWVkIHRvIGhpZGUgdGhvc2Ugbm9kZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSwgc29cbiAgICAgICAgICAgICAgLy8gc2NoZWR1bGUgYSB2aXNpYmlsaXR5IGVmZmVjdC5cbiAgICAgICAgICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgJiAoUGxhY2VtZW50IHwgVXBkYXRlKSkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHZhciBoYXNJZDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhDb21wb25lbnQudHlwZSwgbnVsbCwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MubW9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIGNoaWxkLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBjaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNoaWxkO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHtcbiAgICB2YXIgX3R5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICB2YXIgX2lubmVyUHJvcFR5cGVzID0gX3R5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKF9pbm5lclByb3BUeXBlcykge1xuICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICBjaGVja1Byb3BUeXBlcyhfaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBvdXRlck1lbW9UeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG5cbiAgICAgIGlmIChvdXRlck1lbW9UeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgLy8gV2Ugd2FybiB3aGVuIHlvdSBkZWZpbmUgcHJvcFR5cGVzIG9uIGxhenkoKVxuICAgICAgICAvLyBzbyBsZXQncyBqdXN0IHNraXAgb3ZlciBpdCB0byBmaW5kIG1lbW8oKSBvdXRlciB3cmFwcGVyLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBmb3IgbWVtbyBhcmUgdmFsaWRhdGVkIGxhdGVyLlxuICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IG91dGVyTWVtb1R5cGU7XG4gICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IGluaXQocGF5bG9hZCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gbnVsbDtcbiAgICAgICAgfSAvLyBJbm5lciBwcm9wVHlwZXMgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBwYXRoLlxuXG5cbiAgICAgICAgdmFyIG91dGVyUHJvcFR5cGVzID0gb3V0ZXJNZW1vVHlwZSAmJiBvdXRlck1lbW9UeXBlLnByb3BUeXBlcztcblxuICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCAoU2ltcGxlTWVtb0NvbXBvbmVudCBoYXMgbm8gZGVmYXVsdFByb3BzKVxuICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7IC8vIFRoZSBwcm9wcyBhcmUgc2hhbGxvd2x5IGVxdWFsLiBSZXVzZSB0aGUgcHJldmlvdXMgcHJvcHMgb2JqZWN0LCBsaWtlIHdlXG4gICAgICAvLyB3b3VsZCBkdXJpbmcgYSBub3JtYWwgZmliZXIgYmFpbG91dC5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIHN0cm9uZyBndWFyYW50ZWVzIHRoYXQgdGhlIHByb3BzIG9iamVjdCBpcyByZWZlcmVudGlhbGx5XG4gICAgICAvLyBlcXVhbCBkdXJpbmcgdXBkYXRlcyB3aGVyZSB3ZSBjYW4ndCBiYWlsIG91dCBhbnl3YXkg4oCUIGxpa2UgaWYgdGhlIHByb3BzXG4gICAgICAvLyBhcmUgc2hhbGxvd2x5IGVxdWFsLCBidXQgdGhlcmUncyBhIGxvY2FsIHN0YXRlIG9yIGNvbnRleHQgdXBkYXRlIGluIHRoZVxuICAgICAgLy8gc2FtZSBiYXRjaC5cbiAgICAgIC8vXG4gICAgICAvLyBIb3dldmVyLCBhcyBhIHByaW5jaXBsZSwgd2Ugc2hvdWxkIGFpbSB0byBtYWtlIHRoZSBiZWhhdmlvciBjb25zaXN0ZW50XG4gICAgICAvLyBhY3Jvc3MgZGlmZmVyZW50IHdheXMgb2YgbWVtb2l6aW5nIGEgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgUmVhY3QubWVtb1xuICAgICAgLy8gaGFzIGEgZGlmZmVyZW50IGludGVybmFsIEZpYmVyIGxheW91dCBpZiB5b3UgcGFzcyBhIG5vcm1hbCBmdW5jdGlvblxuICAgICAgLy8gY29tcG9uZW50IChTaW1wbGVNZW1vQ29tcG9uZW50KSB2ZXJzdXMgaWYgeW91IHBhc3MgYSBkaWZmZXJlbnQgdHlwZVxuICAgICAgLy8gbGlrZSBmb3J3YXJkUmVmIChNZW1vQ29tcG9uZW50KS4gQnV0IHRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuICAgICAgLy8gV3JhcHBpbmcgYSBjb21wb25lbnQgaW4gZm9yd2FyZFJlZiAob3IgUmVhY3QubGF6eSwgZXRjKSBzaG91bGRuJ3RcbiAgICAgIC8vIGFmZmVjdCB3aGV0aGVyIHRoZSBwcm9wcyBvYmplY3QgaXMgcmV1c2VkIGR1cmluZyBhIGJhaWxvdXQuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG5leHRQcm9wcyA9IHByZXZQcm9wcztcblxuICAgICAgaWYgKCFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgLy8gVGhlIHBlbmRpbmcgbGFuZXMgd2VyZSBjbGVhcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYmVnaW5Xb3JrLiBXZSdyZVxuICAgICAgICAvLyBhYm91dCB0byBiYWlsIG91dCwgYnV0IHRoZXJlIG1pZ2h0IGJlIG90aGVyIGxhbmVzIHRoYXQgd2VyZW4ndFxuICAgICAgICAvLyBpbmNsdWRlZCBpbiB0aGUgY3VycmVudCByZW5kZXIuIFVzdWFsbHksIHRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGVcbiAgICAgICAgLy8gcmVtYWluaW5nIHVwZGF0ZXMgaXMgYWNjdW11bGF0ZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgKGkuZS4gd2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUpLiBCdXQgc2luY2Ugc2luY2VcbiAgICAgICAgLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuICAgICAgICAvLyB0byBhY2NvdW50IGZvciBpdCBoZXJlLCB0b28uIFJlc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBmaWJlci5cbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IGFwcGxpZXMgdG8gU2ltcGxlTWVtb0NvbXBvbmVudCwgbm90IE1lbW9Db21wb25lbnQsXG4gICAgICAgIC8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuICAgICAgICAvLyByYXRoZXIsIGl0IHdyYXBzIGFyb3VuZCBhbiBpbm5lciBjb21wb25lbnQsIHdoaWNoIG1heSBvciBtYXkgbm90XG4gICAgICAgIC8vIGNvbnRhaW5zIGhvb2tzLlxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICBpZiAobmV4dFByb3BzLm1vZGUgPT09ICdoaWRkZW4nIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiApIHtcbiAgICAvLyBSZW5kZXJpbmcgYSBoaWRkZW4gdHJlZS5cbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gbGVnYWN5IHN5bmMgbW9kZSwgZG9uJ3QgZGVmZXIgdGhlIHN1YnRyZWUuIFJlbmRlciBpdCBub3cuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBob3cgT2Zmc2NyZWVuIHNob3VsZCB3b3JrIHdpdGggdHJhbnNpdGlvbnMgaW4gdGhlIGZ1dHVyZVxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IG51bGwsXG4gICAgICAgIHRyYW5zaXRpb25zOiBudWxsXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcblxuICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkpIHtcbiAgICAgIHZhciBzcGF3bmVkQ2FjaGVQb29sID0gbnVsbDsgLy8gV2UncmUgaGlkZGVuLCBhbmQgd2UncmUgbm90IHJlbmRlcmluZyBhdCBPZmZzY3JlZW4uIFdlIHdpbGwgYmFpbCBvdXRcbiAgICAgIC8vIGFuZCByZXN1bWUgdGhpcyB0cmVlIGxhdGVyLlxuXG4gICAgICB2YXIgbmV4dEJhc2VMYW5lcztcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkJhc2VMYW5lcyA9IHByZXZTdGF0ZS5iYXNlTGFuZXM7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSBtZXJnZUxhbmVzKHByZXZCYXNlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICAgIH0gLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB2YXIgX25leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBuZXh0QmFzZUxhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IHNwYXduZWRDYWNoZVBvb2wsXG4gICAgICAgIHRyYW5zaXRpb25zOiBudWxsXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAvLyB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cblxuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIG5leHRCYXNlTGFuZXMpO1xuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgc2Vjb25kIHJlbmRlci4gVGhlIHN1cnJvdW5kaW5nIHZpc2libGUgY29udGVudCBoYXMgYWxyZWFkeVxuICAgICAgLy8gY29tbWl0dGVkLiBOb3cgd2UgcmVzdW1lIHJlbmRlcmluZyB0aGUgaGlkZGVuIHRyZWUuXG4gICAgICAvLyBSZW5kZXJpbmcgYXQgb2Zmc2NyZWVuLCBzbyB3ZSBjYW4gY2xlYXIgdGhlIGJhc2UgbGFuZXMuXG4gICAgICB2YXIgX25leHRTdGF0ZTIgPSB7XG4gICAgICAgIGJhc2VMYW5lczogTm9MYW5lcyxcbiAgICAgICAgY2FjaGVQb29sOiBudWxsLFxuICAgICAgICB0cmFuc2l0aW9uczogbnVsbFxuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlMjsgLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG4gICAgICB2YXIgc3VidHJlZVJlbmRlckxhbmVzID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmJhc2VMYW5lcyA6IHJlbmRlckxhbmVzO1xuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlcmluZyBhIHZpc2libGUgdHJlZS5cbiAgICB2YXIgX3N1YnRyZWVSZW5kZXJMYW5lcztcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlbid0IHByZXZpb3VzbHkgaGlkZGVuLCBhbmQgd2Ugc3RpbGwgYXJlbid0LCBzbyB0aGVyZSdzIG5vdGhpbmdcbiAgICAgIC8vIHNwZWNpYWwgdG8gZG8uIE5lZWQgdG8gcHVzaCB0byB0aGUgc3RhY2sgcmVnYXJkbGVzcywgdGhvdWdoLCB0byBhdm9pZFxuICAgICAgLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgfVxuXG4gICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBfc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuXG4gICAge1xuICAgICAgLy8gUmVzZXQgZWZmZWN0IGR1cmF0aW9ucyBmb3IgdGhlIG5leHQgZXZlbnR1YWwgZWZmZWN0IHBoYXNlLlxuICAgICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbiAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsICYmIHJlZiAhPT0gbnVsbCB8fCBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSByZWYpIHtcbiAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWY7XG5cbiAgICB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWZTdGF0aWM7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dDtcblxuICB7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlKTtcbiAgICBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHZhciBoYXNJZDtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuICAgIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBlcnJvci5cbiAgICBzd2l0Y2ggKHNob3VsZEVycm9yKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlOyAvLyBUT0RPIFRoaXMgd2F5IG9mIHJlc2V0dGluZyB0aGUgZXJyb3IgYm91bmRhcnkgc3RhdGUgaXMgYSBoYWNrLlxuICAgICAgICAgIC8vIElzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzP1xuXG4gICAgICAgICAgdmFyIHRlbXBJbnN0YW5jZSA9IG5ldyBjdG9yKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsIF9pbnN0YW5jZS5jb250ZXh0KTtcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0ZW1wSW5zdGFuY2Uuc3RhdGU7XG5cbiAgICAgICAgICBfaW5zdGFuY2UudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUoX2luc3RhbmNlLCBzdGF0ZSwgbnVsbCk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG5cbiAgICAgICAgICB2YXIgZXJyb3IkMSA9IG5ldyBFcnJvcignU2ltdWxhdGVkIGVycm9yIGNvbWluZyBmcm9tIERldlRvb2xzJyk7XG4gICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcyk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBsYW5lKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciQxLCB3b3JrSW5Qcm9ncmVzcyksIGxhbmUpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cblxuICB2YXIgaGFzQ29udGV4dDtcblxuICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIHNob3VsZFVwZGF0ZTtcblxuICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gQSBjbGFzcyBjb21wb25lbnQgd2l0aG91dCBhbiBpbnN0YW5jZSBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWRcbiAgICAgIC8vIGluc2lkZSBhIG5vbi1jb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0b1xuICAgICAgLy8gdHJlYXQgaXQgbGlrZSBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5XG4gICAgICAvLyBjb21taXR0ZWQuIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICAgIH0gLy8gSW4gdGhlIGluaXRpYWwgcGFzcyB3ZSBtaWdodCBuZWVkIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2UuXG5cblxuICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzKTtcbiAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIHNob3VsZFVwZGF0ZSA9IHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgbmV4dFVuaXRPZldvcmsgPSBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgdmFyIGluc3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlICYmIGluc3QucHJvcHMgIT09IG5leHRQcm9wcykge1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgIGVycm9yKCdJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gJyArICdUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdhIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFVuaXRPZldvcms7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgbWFya1JlZiQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGRpZENhcHR1cmVFcnJvciA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmICghc2hvdWxkVXBkYXRlICYmICFkaWRDYXB0dXJlRXJyb3IpIHtcbiAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsgLy8gUmVyZW5kZXJcblxuICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdmFyIG5leHRDaGlsZHJlbjtcblxuICBpZiAoZGlkQ2FwdHVyZUVycm9yICYmIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXMgbm90IGRlZmluZWQsXG4gICAgLy8gdW5tb3VudCBhbGwgdGhlIGNoaWxkcmVuLiBjb21wb25lbnREaWRDYXRjaCB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB0b1xuICAgIC8vIHJlLXJlbmRlciBhIGZhbGxiYWNrLiBUaGlzIGlzIHRlbXBvcmFyeSB1bnRpbCB3ZSBtaWdyYXRlIGV2ZXJ5b25lIHRvXG4gICAgLy8gdGhlIG5ldyBBUEkuXG4gICAgLy8gVE9ETzogV2FybiBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG5cbiAgICB7XG4gICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZygpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcblxuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBkaWRDYXB0dXJlRXJyb3IpIHtcbiAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB3aXRob3V0IHJldXNpbmcgYW55IG9mXG4gICAgLy8gdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBDb25jZXB0dWFsbHksIHRoZSBub3JtYWwgY2hpbGRyZW4gYW5kIHRoZSBjaGlsZHJlblxuICAgIC8vIHRoYXQgYXJlIHNob3duIG9uIGVycm9yIGFyZSB0d28gZGlmZmVyZW50IHNldHMsIHNvIHdlIHNob3VsZG4ndCByZXVzZVxuICAgIC8vIG5vcm1hbCBjaGlsZHJlbiBldmVuIGlmIHRoZWlyIGlkZW50aXRpZXMgbWF0Y2guXG4gICAgZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IC8vIE1lbW9pemUgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cblxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTsgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG5cbiAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG5cbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGhhdmUgYSBjdXJyZW50IGZpYmVyLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwcmV2Q2hpbGRyZW4gPSBwcmV2U3RhdGUuZWxlbWVudDtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRTdGF0ZS5lbGVtZW50O1xuXG4gIGlmICggcHJldlN0YXRlLmlzRGVoeWRyYXRlZCkge1xuICAgIC8vIFRoaXMgaXMgYSBoeWRyYXRpb24gcm9vdCB3aG9zZSBzaGVsbCBoYXMgbm90IHlldCBoeWRyYXRlZC4gV2Ugc2hvdWxkXG4gICAgLy8gYXR0ZW1wdCB0byBoeWRyYXRlLlxuICAgIC8vIEZsaXAgaXNEZWh5ZHJhdGVkIHRvIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2hlbiB0aGlzIHJlbmRlclxuICAgIC8vIGZpbmlzaGVzLCB0aGUgcm9vdCB3aWxsIG5vIGxvbmdlciBiZSBkZWh5ZHJhdGVkLlxuICAgIHZhciBvdmVycmlkZVN0YXRlID0ge1xuICAgICAgZWxlbWVudDogbmV4dENoaWxkcmVuLFxuICAgICAgaXNEZWh5ZHJhdGVkOiBmYWxzZSxcbiAgICAgIGNhY2hlOiBuZXh0U3RhdGUuY2FjaGUsXG4gICAgICBwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzOiBuZXh0U3RhdGUucGVuZGluZ1N1c3BlbnNlQm91bmRhcmllcyxcbiAgICAgIHRyYW5zaXRpb25zOiBuZXh0U3RhdGUudHJhbnNpdGlvbnNcbiAgICB9O1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOyAvLyBgYmFzZVN0YXRlYCBjYW4gYWx3YXlzIGJlIHRoZSBsYXN0IHN0YXRlIGJlY2F1c2UgdGhlIHJvb3QgZG9lc24ndFxuICAgIC8vIGhhdmUgcmVkdWNlciBmdW5jdGlvbnMgc28gaXQgZG9lc24ndCBuZWVkIHJlYmFzaW5nLlxuXG4gICAgdXBkYXRlUXVldWUuYmFzZVN0YXRlID0gb3ZlcnJpZGVTdGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gb3ZlcnJpZGVTdGF0ZTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSB7XG4gICAgICAvLyBTb21ldGhpbmcgZXJyb3JlZCBkdXJpbmcgYSBwcmV2aW91cyBhdHRlbXB0IHRvIGh5ZHJhdGUgdGhlIHNoZWxsLCBzbyB3ZVxuICAgICAgLy8gZm9yY2VkIGEgY2xpZW50IHJlbmRlci5cbiAgICAgIHZhciByZWNvdmVyYWJsZUVycm9yID0gbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nLiBCZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5lZCBvdXRzaWRlICcgKyAnb2YgYSBTdXNwZW5zZSBib3VuZGFyeSwgdGhlIGVudGlyZSByb290IHdpbGwgc3dpdGNoIHRvICcgKyAnY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICAgIHJldHVybiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcywgcmVjb3ZlcmFibGVFcnJvcik7XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gIT09IHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIF9yZWNvdmVyYWJsZUVycm9yID0gbmV3IEVycm9yKCdUaGlzIHJvb3QgcmVjZWl2ZWQgYW4gZWFybHkgdXBkYXRlLCBiZWZvcmUgYW55dGhpbmcgd2FzIGFibGUgJyArICdoeWRyYXRlLiBTd2l0Y2hlZCB0aGUgZW50aXJlIHJvb3QgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcblxuICAgICAgcmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzLCBfcmVjb3ZlcmFibGVFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBvdXRlcm1vc3Qgc2hlbGwgaGFzIG5vdCBoeWRyYXRlZCB5ZXQuIFN0YXJ0IGh5ZHJhdGluZy5cbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICB2YXIgY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgICB2YXIgbm9kZSA9IGNoaWxkO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAvLyBNYXJrIGVhY2ggY2hpbGQgYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgICAgIC8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbiAgICAgICAgLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4gICAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgICAgICAvLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbiAgICAgICAgLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzICYgflBsYWNlbWVudCB8IEh5ZHJhdGluZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUm9vdCBpcyBub3QgZGVoeWRyYXRlZC4gRWl0aGVyIHRoaXMgaXMgYSBjbGllbnQtb25seSByb290LCBvciBpdFxuICAgIC8vIGFscmVhZHkgaHlkcmF0ZWQuXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuXG4gICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMsIHJlY292ZXJhYmxlRXJyb3IpIHtcbiAgLy8gUmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXG4gIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgcXVldWVIeWRyYXRpb25FcnJvcihyZWNvdmVyYWJsZUVycm9yKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXI7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXMgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMgIT09IG51bGwgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDb250ZW50UmVzZXQ7XG4gIH1cblxuICBtYXJrUmVmJDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXp5Q29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEEgbGF6eSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbGF6eUNvbXBvbmVudCA9IGVsZW1lbnRUeXBlO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7IC8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG4gIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgdmFyIGNoaWxkO1xuXG4gIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGb3J3YXJkUmVmKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIHJlc29sdmVkUHJvcHMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlTWVtb0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudC50eXBlLCByZXNvbHZlZFByb3BzKSwgLy8gVGhlIGlubmVyIHR5cGUgY2FuIGhhdmUgZGVmYXVsdHMgdG9vXG4gICAgICAgIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIGhpbnQgPSAnJztcblxuICB7XG4gICAgaWYgKENvbXBvbmVudCAhPT0gbnVsbCAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgaGludCA9ICcgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT8nO1xuICAgIH1cbiAgfSAvLyBUaGlzIG1lc3NhZ2UgaW50ZW50aW9uYWxseSBkb2Vzbid0IG1lbnRpb24gRm9yd2FyZFJlZiBvciBNZW1vQ29tcG9uZW50XG4gIC8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbC5cblxuXG4gIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgKyBDb21wb25lbnQgKyBcIi4gXCIgKyAoXCJMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArIGhpbnQpKTtcbn1cblxuZnVuY3Rpb24gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQW4gaW5jb21wbGV0ZSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9IC8vIFByb21vdGUgdGhlIGZpYmVyIHRvIGEgY2xhc3MgYW5kIHRyeSByZW5kZXJpbmcgYWdhaW4uXG5cblxuICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDsgLy8gVGhlIHJlc3Qgb2YgdGhpcyBmdW5jdGlvbiBpcyBhIGZvcmsgb2YgYHVwZGF0ZUNsYXNzQ29tcG9uZW50YFxuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuICB2YXIgaGFzQ29udGV4dDtcblxuICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzKTtcbiAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIGNvbnRleHQ7XG5cbiAge1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgaGFzSWQ7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIHtcbiAgICAvLyBTdXBwb3J0IGZvciBtb2R1bGUgY29tcG9uZW50cyBpcyBkZXByZWNhdGVkIGFuZCBpcyByZW1vdmVkIGJlaGluZCBhIGZsYWcuXG4gICAgLy8gV2hldGhlciBvciBub3QgaXQgd291bGQgY3Jhc2ggbGF0ZXIsIHdlIHdhbnQgdG8gc2hvdyBhIGdvb2QgbWVzc2FnZSBpbiBERVYgZmlyc3QuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuICAvLyBFdmVudHVhbGx5IHdlJ2xsIGRlbGV0ZSB0aGlzIGJyYW5jaCBhbHRvZ2V0aGVyLlxuICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDsgLy8gVGhyb3cgb3V0IGFueSBob29rcyB0aGF0IHdlcmUgdXNlZC5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDsgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBmYWxzZTtcblxuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHZhbHVlLnN0YXRlICE9PSBudWxsICYmIHZhbHVlLnN0YXRlICE9PSB1bmRlZmluZWQgPyB2YWx1ZS5zdGF0ZSA6IG51bGw7XG4gICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25Db21wb25lbnQ7XG5cbiAgICB7XG5cbiAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuICAgICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4obnVsbCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlLCByZW5kZXJMYW5lcyk7XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcblxuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG5cbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8ICcnO1xuICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuXG4gICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiAnICsgJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJywgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicsIF9jb21wb25lbnROYW1lMyk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LmNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWU0ID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTRdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS4nLCBfY29tcG9uZW50TmFtZTQpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFNVU1BFTkRFRF9NQVJLRVIgPSB7XG4gIGRlaHlkcmF0ZWQ6IG51bGwsXG4gIHRyZWVDb250ZXh0OiBudWxsLFxuICByZXRyeUxhbmU6IE5vTGFuZVxufTtcblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiByZW5kZXJMYW5lcyxcbiAgICBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKCksXG4gICAgdHJhbnNpdGlvbnM6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjYWNoZVBvb2wgPSBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiBtZXJnZUxhbmVzKHByZXZPZmZzY3JlZW5TdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKSxcbiAgICBjYWNoZVBvb2w6IGNhY2hlUG9vbCxcbiAgICB0cmFuc2l0aW9uczogcHJldk9mZnNjcmVlblN0YXRlLnRyYW5zaXRpb25zXG4gIH07XG59IC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCBpbmxpbmUgdGhpcyBiYWNrXG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG9cbiAgLy8gcmVtYWluIG9uIHRoYXQgZmFsbGJhY2sgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb250ZW50IGhhcyByZXNvbHZlZC5cbiAgLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgcmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxuICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuICAgICAgLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbiAgICAgIC8vIEF2b2lkZWQgYm91bmRhcmllcyBhcmUgbm90IGNvbnNpZGVyZWQgc2luY2UgdGhleSBjYW5ub3QgaGFuZGxlIHByZWZlcnJlZCBmYWxsYmFjayBzdGF0ZXMuXG4gICAgICB7XG4gICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IGFkZFN1YnRyZWVTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7IC8vIE9LLCB0aGUgbmV4dCBwYXJ0IGlzIGNvbmZ1c2luZy4gV2UncmUgYWJvdXQgdG8gcmVjb25jaWxlIHRoZSBTdXNwZW5zZVxuICAvLyBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGlzIGludm9sdmVzIHNvbWUgY3VzdG9tIHJlY29uY2lsaWF0aW9uIGxvZ2ljLiBUd29cbiAgLy8gbWFpbiByZWFzb25zIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQuXG4gIC8vXG4gIC8vIEZpcnN0LCBMZWdhY3kgTW9kZSBoYXMgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZVxuICAvLyBwcmltYXJ5IHRyZWUgd2lsbCBjb21taXQgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLCBzbyB3aGVuIHdlIGRvIHRoZVxuICAvLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG4gIC8vIGhhY2tzIHRvIG1ha2UgdGhhdCBub3QgdG90YWxseSBicmVhay4gTGlrZSB0cmFuc2ZlcnJpbmcgZWZmZWN0cyBhbmRcbiAgLy8gZGVsZXRpb25zIGZyb20gaGlkZGVuIHRyZWUuIEluIENvbmN1cnJlbnQgTW9kZSwgaXQncyBtdWNoIHNpbXBsZXIsXG4gIC8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcbiAgLy8gc3RhdGUsIG5vIGVmZmVjdHMuIFNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgT2Zmc2NyZWVuIChleGNlcHQgdGhhdFxuICAvLyBPZmZzY3JlZW4gZG9lc24ndCBoYXZlIHRoZSBmaXJzdCByZW5kZXIgcGFzcykuXG4gIC8vXG4gIC8vIFNlY29uZCBpcyBoeWRyYXRpb24uIER1cmluZyBoeWRyYXRpb24sIHRoZSBTdXNwZW5zZSBmaWJlciBoYXMgYSBzbGlnaHRseVxuICAvLyBkaWZmZXJlbnQgbGF5b3V0LCB3aGVyZSB0aGUgY2hpbGQgcG9pbnRzIHRvIGEgZGVoeWRyYXRlZCBmcmFnbWVudCwgd2hpY2hcbiAgLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuICAvL1xuICAvLyBUaGlyZCwgZXZlbiBpZiB5b3Ugc2V0IGFsbCB0aGF0IGFzaWRlLCBTdXNwZW5zZSBpcyBsaWtlIGVycm9yIGJvdW5kYXJpZXMgaW5cbiAgLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG4gIC8vIGFuZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHJlZS4gTGlrZSBhIHRyeS9jYXRjaCBibG9jay4gU28gd2UgaGF2ZSB0byB0cmFja1xuICAvLyB3aGljaCBicmFuY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZy4gSWRlYWxseSB3ZSB3b3VsZCBtb2RlbCB0aGlzIHVzaW5nXG4gIC8vIGEgc3RhY2suXG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgY291bGQndmUgYmVlbiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuXG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkZWh5ZHJhdGVkID0gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICBpZiAoZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQod29ya0luUHJvZ3Jlc3MsIGRlaHlkcmF0ZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcblxuICAgIGlmIChzaG93RmFsbGJhY2spIHtcbiAgICAgIHZhciBmYWxsYmFja0ZyYWdtZW50ID0gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIG5leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG5cbiAgICAgIHJldHVybiBmYWxsYmFja0ZyYWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYW4gdXBkYXRlLlxuICAgIC8vIElmIHRoZSBjdXJyZW50IGZpYmVyIGhhcyBhIFN1c3BlbnNlU3RhdGUsIHRoYXQgbWVhbnMgaXQncyBhbHJlYWR5IHNob3dpbmdcbiAgICAvLyBhIGZhbGxiYWNrLlxuICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCB0cmVlIGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrXG4gICAgICAvLyBTcGVjaWFsIHBhdGggZm9yIGh5ZHJhdGlvblxuICAgICAgdmFyIF9kZWh5ZHJhdGVkID0gcHJldlN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgIGlmIChfZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWRpZFN1c3BlbmQpIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfZGVoeWRyYXRlZCwgcHJldlN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBoeWRyYXRpb24uIFRyeSBhZ2FpbiB3aXRob3V0IGh5ZHJhdGluZy5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+Rm9yY2VDbGllbnRSZW5kZXI7XG4gICAgICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIHRoaXMgU3VzcGVuc2UgYm91bmRhcnkuICcgKyAnU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy4nKSk7XG4gICAgICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYW5kIHdlIHNob3VsZCBzdGlsbCBiZSBpbiBkZWh5ZHJhdGVkIG1vZGUuXG4gICAgICAgICAgLy8gTGVhdmUgdGhlIGV4aXN0aW5nIGNoaWxkIGluIHBsYWNlLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDsgLy8gVGhlIGRlaHlkcmF0ZWQgY29tcGxldGlvbiBwYXNzIGV4cGVjdHMgdGhpcyBmbGFnIHRvIGJlIHRoZXJlXG4gICAgICAgICAgLy8gYnV0IHRoZSBub3JtYWwgc3VzcGVuc2UgcGFzcyBkb2Vzbid0LlxuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTdXNwZW5kZWQgYnV0IHdlIHNob3VsZCBubyBsb25nZXIgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBub3cgaGF2ZSB0byByZW5kZXIgdGhlIGZhbGxiYWNrLlxuICAgICAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4sIF9uZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgICAgICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG93RmFsbGJhY2spIHtcbiAgICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZHJlbjIgPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbjIgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAgICAgdmFyIF9mYWxsYmFja0NoaWxkRnJhZ21lbnQgPSB1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiwgX25leHRGYWxsYmFja0NoaWxkcmVuMiwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMubWVtb2l6ZWRTdGF0ZSA9IHByZXZPZmZzY3JlZW5TdGF0ZSA9PT0gbnVsbCA/IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykgOiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICAvLyBUaW1lZCBvdXQuXG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW40ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW40LCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIF9wcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUubWVtb2l6ZWRTdGF0ZSA9IF9wcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShfcHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgLy8gZmFsbGJhY2sgY2hpbGRyZW4uXG5cblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgICAgcmV0dXJuIF9mYWxsYmFja0NoaWxkRnJhZ21lbnQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RpbGwgaGF2ZW4ndCB0aW1lZCBvdXQuIENvbnRpbnVlIHJlbmRlcmluZyB0aGUgY2hpbGRyZW4sIGxpa2Ugd2VcbiAgICAgICAgLy8gbm9ybWFsbHkgZG8uXG4gICAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbjUgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDYgPSB1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW41LCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ2O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmICgobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlICYmIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gICAgLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbmAgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZVxuICAvLyB0aGlzIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKG9mZnNjcmVlblByb3BzLCBtb2RlLCBOb0xhbmVzLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZVdvcmtJblByb2dyZXNzYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlIHRoaXNcbiAgLy8gd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH0pO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQubGFuZXMgPSByZW5kZXJMYW5lcztcbiAgfVxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gbnVsbDtcblxuICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIC8vIERlbGV0ZSB0aGUgZmFsbGJhY2sgY2hpbGQgZnJhZ21lbnRcbiAgICB2YXIgZGVsZXRpb25zID0gd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnRdO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXG4gIGlmICggLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGNvbW1pdCB0aGUgcHJpbWFyeSB0cmVlIGFzIGlmIGl0IHN1Y2Nlc3NmdWxseVxuICAvLyBjb21wbGV0ZWQsIGV2ZW4gdGhvdWdoIGl0J3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLlxuICAobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlICYmIC8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgc2Vjb25kIHBhc3MsIGkuZS4gdGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgd2FzXG4gIC8vIGFscmVhZHkgY2xvbmVkLiBJbiBsZWdhY3kgbW9kZSwgdGhlIG9ubHkgY2FzZSB3aGVyZSB0aGlzIGlzbid0IHRydWUgaXNcbiAgLy8gd2hlbiBEZXZUb29scyBmb3JjZXMgdXMgdG8gZGlzcGxheSBhIGZhbGxiYWNrOyB3ZSBza2lwIHRoZSBmaXJzdCByZW5kZXJcbiAgLy8gcGFzcyBlbnRpcmVseSBhbmQgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjay4gKEluIENvbmN1cnJlbnRcbiAgLy8gTW9kZSwgU3VzcGVuc2VMaXN0IGNhbiBhbHNvIHRyaWdnZXIgdGhpcyBzY2VuYXJpbywgYnV0IHRoaXMgaXMgYSBsZWdhY3ktXG4gIC8vIG9ubHkgY29kZXBhdGguKVxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50KSB7XG4gICAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIGdvaW5nIHRvIHJlbWFpbiBvbiB0aGUgZmFsbGJhY2ssIHdlIG5vIGxvbmdlciB3YW50XG4gICAgLy8gdG8gZGVsZXRlIGl0LlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHByaW1hcnlDaGlsZFByb3BzKTtcbiAgICAvLyAoV2UgZG9uJ3QgZG8gdGhpcyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBpbiBsZWdhY3kgbW9kZSB3ZSBkb24ndCByZS11c2VcbiAgICAvLyB0aGUgY3VycmVudCB0cmVlOyBzZWUgcHJldmlvdXMgYnJhbmNoLilcblxuXG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gIH1cblxuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCwgZmFsbGJhY2tDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbiAgICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgcmVjb3ZlcmFibGVFcnJvcikge1xuICAvLyBGYWxsaW5nIGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy4gQmVjYXVzZSB0aGlzIGhhcyBwZXJmb3JtYW5jZVxuICAvLyBpbXBsaWNhdGlvbnMsIGl0J3MgY29uc2lkZXJlZCBhIHJlY292ZXJhYmxlIGVycm9yLCBldmVuIHRob3VnaCB0aGUgdXNlclxuICAvLyBsaWtlbHkgd29uJ3Qgb2JzZXJ2ZSBhbnl0aGluZyB3cm9uZyB3aXRoIHRoZSBVSS5cbiAgLy9cbiAgLy8gVGhlIGVycm9yIGlzIHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudCB0byBlbmZvcmNlIHRoYXQgZXZlcnkgY2FsbGVyIHByb3ZpZGVcbiAgLy8gYSBjdXN0b20gbWVzc2FnZSwgb3IgZXhwbGljaXRseSBvcHQgb3V0IChjdXJyZW50bHkgdGhlIG9ubHkgcGF0aCB0aGF0IG9wdHNcbiAgLy8gb3V0IGlzIGxlZ2FjeSBtb2RlOyBldmVyeSBjb25jdXJyZW50IHBhdGggcHJvdmlkZXMgYW4gZXJyb3IpLlxuICBpZiAocmVjb3ZlcmFibGVFcnJvciAhPT0gbnVsbCkge1xuICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IocmVjb3ZlcmFibGVFcnJvcik7XG4gIH0gLy8gVGhpcyB3aWxsIGFkZCB0aGUgb2xkIGZpYmVyIHRvIHRoZSBkZWxldGlvbiBsaXN0XG5cblxuICByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBXZSdyZSBub3cgbm90IHN1c3BlbmRlZCBub3IgZGVoeWRyYXRlZC5cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbiAgLy8gbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBmaWJlck1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKHByaW1hcnlDaGlsZFByb3BzLCBmaWJlck1vZGUpO1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgZmliZXJNb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZVxuICAvLyBib3VuZGFyeSkgYWxyZWFkeSBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAvLyBXZSB3aWxsIGhhdmUgZHJvcHBlZCB0aGUgZWZmZWN0IGxpc3Qgd2hpY2ggY29udGFpbnMgdGhlXG4gICAgLy8gZGVsZXRpb24uIFdlIG5lZWQgdG8gcmVjb25jaWxlIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBjaGlsZC5cbiAgICByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG4gIC8vIER1cmluZyB0aGUgZmlyc3QgcGFzcywgd2UnbGwgYmFpbCBvdXQgYW5kIG5vdCBkcmlsbCBpbnRvIHRoZSBjaGlsZHJlbi5cbiAgLy8gSW5zdGVhZCwgd2UnbGwgbGVhdmUgdGhlIGNvbnRlbnQgaW4gcGxhY2UgYW5kIHRyeSB0byBoeWRyYXRlIGl0IGxhdGVyLlxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCdDYW5ub3QgaHlkcmF0ZSBTdXNwZW5zZSBpbiBsZWdhY3kgbW9kZS4gU3dpdGNoIGZyb20gJyArICdSZWFjdERPTS5oeWRyYXRlKGVsZW1lbnQsIGNvbnRhaW5lcikgdG8gJyArICdSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChjb250YWluZXIsIDxBcHAgLz4pJyArICcucmVuZGVyKGVsZW1lbnQpIG9yIHJlbW92ZSB0aGUgU3VzcGVuc2UgY29tcG9uZW50cyBmcm9tICcgKyAndGhlIHNlcnZlciByZW5kZXJlZCBjb21wb25lbnRzLicpO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFuZVRvTGFuZXMoU3luY0xhbmUpO1xuICB9IGVsc2UgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgLy8gVGhpcyBpcyBhIGNsaWVudC1vbmx5IGJvdW5kYXJ5LiBTaW5jZSB3ZSB3b24ndCBnZXQgYW55IGNvbnRlbnQgZnJvbSB0aGUgc2VydmVyXG4gICAgLy8gZm9yIHRoaXMsIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhhdCBhdCBhIGhpZ2hlciBwcmlvcml0eSBiYXNlZCBvbiB3aGVuIGl0IHdvdWxkXG4gICAgLy8gaGF2ZSB0aW1lZCBvdXQuIEluIHRoZW9yeSB3ZSBjb3VsZCByZW5kZXIgaXQgaW4gdGhpcyBwYXNzIGJ1dCBpdCB3b3VsZCBoYXZlIHRoZVxuICAgIC8vIHdyb25nIHByaW9yaXR5IGFzc29jaWF0ZWQgd2l0aCBpdCBhbmQgd2lsbCBwcmV2ZW50IGh5ZHJhdGlvbiBvZiBwYXJlbnQgcGF0aC5cbiAgICAvLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB3b3JrIGxlZnQgb24gaXQgdG8gcmVuZGVyIGl0IGluIGEgc2VwYXJhdGUgY29tbWl0LlxuICAgIC8vIFRPRE8gVGhpcyB0aW1lIHNob3VsZCBiZSB0aGUgdGltZSBhdCB3aGljaCB0aGUgc2VydmVyIHJlbmRlcmVkIHJlc3BvbnNlIHRoYXQgaXNcbiAgICAvLyBhIHBhcmVudCB0byB0aGlzIGJvdW5kYXJ5IHdhcyBkaXNwbGF5ZWQuIEhvd2V2ZXIsIHNpbmNlIHdlIGN1cnJlbnRseSBkb24ndCBoYXZlXG4gICAgLy8gYSBwcm90b2NvbCB0byB0cmFuc2ZlciB0aGF0IHRpbWUsIHdlJ2xsIGp1c3QgZXN0aW1hdGUgaXQgYnkgdXNpbmcgdGhlIGN1cnJlbnRcbiAgICAvLyB0aW1lLiBUaGlzIHdpbGwgbWVhbiB0aGF0IFN1c3BlbnNlIHRpbWVvdXRzIGFyZSBzbGlnaHRseSBzaGlmdGVkIHRvIGxhdGVyIHRoYW5cbiAgICAvLyB0aGV5IHNob3VsZCBiZS5cbiAgICAvLyBTY2hlZHVsZSBhIG5vcm1hbCBwcmkgdXBkYXRlIHRvIHJlbmRlciB0aGlzIGNvbnRlbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhEZWZhdWx0SHlkcmF0aW9uTGFuZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UnbGwgY29udGludWUgaHlkcmF0aW5nIHRoZSByZXN0IGF0IG9mZnNjcmVlbiBwcmlvcml0eSBzaW5jZSB3ZSdsbCBhbHJlYWR5XG4gICAgLy8gYmUgc2hvd2luZyB0aGUgcmlnaHQgY29udGVudCBjb21pbmcgZnJvbSB0aGUgc2VydmVyLCBpdCBpcyBubyBydXNoLlxuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUluc3RhbmNlLCBzdXNwZW5zZVN0YXRlLCByZW5kZXJMYW5lcykge1xuICAvLyBXZSBzaG91bGQgbmV2ZXIgYmUgaHlkcmF0aW5nIGF0IHRoaXMgcG9pbnQgYmVjYXVzZSBpdCBpcyB0aGUgZmlyc3QgcGFzcyxcbiAgLy8gYnV0IGFmdGVyIHdlJ3ZlIGFscmVhZHkgY29tbWl0dGVkIG9uY2UuXG4gIHdhcm5JZkh5ZHJhdGluZygpO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgLy8gVE9ETzogV2hlbiB3ZSBkZWxldGUgbGVnYWN5IG1vZGUsIHdlIHNob3VsZCBtYWtlIHRoaXMgZXJyb3IgYXJndW1lbnRcbiAgICAvLyByZXF1aXJlZCDigJQgZXZlcnkgY29uY3VycmVudCBtb2RlIHBhdGggdGhhdCBjYXVzZXMgaHlkcmF0aW9uIHRvXG4gICAgLy8gZGUtb3B0IHRvIGNsaWVudCByZW5kZXJpbmcgc2hvdWxkIGhhdmUgYW4gZXJyb3IgbWVzc2FnZS5cbiAgICBudWxsKTtcbiAgfVxuXG4gIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSkge1xuICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgaW4gYSBwZXJtYW5lbnQgZmFsbGJhY2sgc3RhdGUuIEluIHRoaXMgY2FzZSwgd2UnbGwgbmV2ZXJcbiAgICAvLyBnZXQgYW4gdXBkYXRlIGFuZCB3ZSdsbCBuZXZlciBiZSBhYmxlIHRvIGh5ZHJhdGUgdGhlIGZpbmFsIGNvbnRlbnQuIExldCdzIGp1c3QgdHJ5IHRoZVxuICAgIC8vIGNsaWVudCBzaWRlIHJlbmRlciBpbnN0ZWFkLlxuICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIC8vIFRPRE86IFRoZSBzZXJ2ZXIgc2hvdWxkIHNlcmlhbGl6ZSB0aGUgZXJyb3IgbWVzc2FnZSBzbyB3ZSBjYW4gbG9nIGl0XG4gICAgLy8gaGVyZSBvbiB0aGUgY2xpZW50LiBPciwgaW4gcHJvZHVjdGlvbiwgYSBoYXNoL2lkIHRoYXQgY29ycmVzcG9uZHMgdG9cbiAgICAvLyB0aGUgZXJyb3IuXG4gICAgbmV3IEVycm9yKCdUaGUgc2VydmVyIGNvdWxkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeSwgbGlrZWx5ICcgKyAnZHVlIHRvIGFuIGVycm9yIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLiBTd2l0Y2hlZCB0byAnICsgJ2NsaWVudCByZW5kZXJpbmcuJykpO1xuICB9XG4gIC8vIGFueSBjb250ZXh0IGhhcyBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHRyZWF0IGlzIGFzIGlmIHRoZSBpbnB1dCBtaWdodCBoYXZlIGNoYW5nZWQuXG5cblxuICB2YXIgaGFzQ29udGV4dENoYW5nZWQgPSBpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBjdXJyZW50LmNoaWxkTGFuZXMpO1xuXG4gIGlmIChkaWRSZWNlaXZlVXBkYXRlIHx8IGhhc0NvbnRleHRDaGFuZ2VkKSB7XG4gICAgLy8gVGhpcyBib3VuZGFyeSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgZmlyc3QgcmVuZGVyLiBUaGlzIG1lYW5zIHRoYXQgd2UgYXJlIG5vdyB1bmFibGUgdG9cbiAgICAvLyBoeWRyYXRlIGl0LiBXZSBtaWdodCBzdGlsbCBiZSBhYmxlIHRvIGh5ZHJhdGUgaXQgdXNpbmcgYSBoaWdoZXIgcHJpb3JpdHkgbGFuZS5cbiAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lID0gZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbihyb290LCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIGlmIChhdHRlbXB0SHlkcmF0aW9uQXRMYW5lICE9PSBOb0xhbmUgJiYgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSAhPT0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpIHtcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBtdXRhdGluZyBzaW5jZSB0aGlzIHJlbmRlciB3aWxsIGdldCBpbnRlcnJ1cHRlZC4gVGhpc1xuICAgICAgICAvLyBpcyBvbmUgb2YgdGhlIHZlcnkgcmFyZSB0aW1lcyB3aGVyZSB3ZSBtdXRhdGUgdGhlIGN1cnJlbnQgdHJlZVxuICAgICAgICAvLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lOyAvLyBUT0RPOiBJZGVhbGx5IHRoaXMgd291bGQgaW5oZXJpdCB0aGUgZXZlbnQgdGltZSBvZiB0aGUgY3VycmVudCByZW5kZXJcblxuICAgICAgICB2YXIgZXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50LCBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lLCBldmVudFRpbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgd2UgaGF2ZSBzY2hlZHVsZWQgaGlnaGVyIHByaSB3b3JrIGFib3ZlLCB0aGlzIHdpbGwgcHJvYmFibHkganVzdCBhYm9ydCB0aGUgcmVuZGVyXG4gICAgLy8gc2luY2Ugd2Ugbm93IGhhdmUgaGlnaGVyIHByaW9yaXR5IHdvcmssIGJ1dCBpbiBjYXNlIGl0IGRvZXNuJ3QsIHdlIG5lZWQgdG8gcHJlcGFyZSB0b1xuICAgIC8vIHJlbmRlciBzb21ldGhpbmcsIGlmIHdlIHRpbWUgb3V0LiBFdmVuIGlmIHRoYXQgcmVxdWlyZXMgdXMgdG8gZGVsZXRlIGV2ZXJ5dGhpbmcgYW5kXG4gICAgLy8gc2tpcCBoeWRyYXRpb24uXG4gICAgLy8gRGVsYXkgaGF2aW5nIHRvIGRvIHRoaXMgYXMgbG9uZyBhcyB0aGUgc3VzcGVuc2UgdGltZW91dCBhbGxvd3MgdXMuXG5cblxuICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCBuZXcgRXJyb3IoJ1RoaXMgU3VzcGVuc2UgYm91bmRhcnkgcmVjZWl2ZWQgYW4gdXBkYXRlIGJlZm9yZSBpdCBmaW5pc2hlZCAnICsgJ2h5ZHJhdGluZy4gVGhpcyBjYXVzZWQgdGhlIGJvdW5kYXJ5IHRvIHN3aXRjaCB0byBjbGllbnQgcmVuZGVyaW5nLiAnICsgJ1RoZSB1c3VhbCB3YXkgdG8gZml4IHRoaXMgaXMgdG8gd3JhcCB0aGUgb3JpZ2luYWwgdXBkYXRlICcgKyAnaW4gc3RhcnRUcmFuc2l0aW9uLicpKTtcbiAgfSBlbHNlIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgLy8gVGhpcyBjb21wb25lbnQgaXMgc3RpbGwgcGVuZGluZyBtb3JlIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBjYW4ndCBoeWRyYXRlIGl0c1xuICAgIC8vIGNvbnRlbnQuIFdlIHRyZWF0IGl0IGFzIGlmIHRoaXMgY29tcG9uZW50IHN1c3BlbmRlZCBpdHNlbGYuIEl0IG1pZ2h0IHNlZW0gYXMgaWZcbiAgICAvLyB3ZSBjb3VsZCBqdXN0IHRyeSB0byByZW5kZXIgaXQgY2xpZW50LXNpZGUgaW5zdGVhZC4gSG93ZXZlciwgdGhpcyB3aWxsIHBlcmZvcm0gYVxuICAgIC8vIGxvdCBvZiB1bm5lY2Vzc2FyeSB3b3JrIGFuZCBpcyB1bmxpa2VseSB0byBjb21wbGV0ZSBzaW5jZSBpdCBvZnRlbiB3aWxsIHN1c3BlbmRcbiAgICAvLyBvbiBtaXNzaW5nIGRhdGEgYW55d2F5LiBBZGRpdGlvbmFsbHksIHRoZSBzZXJ2ZXIgbWlnaHQgYmUgYWJsZSB0byByZW5kZXIgbW9yZVxuICAgIC8vIHRoYW4gd2UgY2FuIG9uIHRoZSBjbGllbnQgeWV0LiBJbiB0aGF0IGNhc2Ugd2UnZCBlbmQgdXAgd2l0aCBtb3JlIGZhbGxiYWNrIHN0YXRlc1xuICAgIC8vIG9uIHRoZSBjbGllbnQgdGhhbiBpZiB3ZSBqdXN0IGxlYXZlIGl0IGFsb25lLiBJZiB0aGUgc2VydmVyIHRpbWVzIG91dCBvciBlcnJvcnNcbiAgICAvLyB0aGVzZSBzaG91bGQgdXBkYXRlIHRoaXMgYm91bmRhcnkgdG8gdGhlIHBlcm1hbmVudCBGYWxsYmFjayBzdGF0ZSBpbnN0ZWFkLlxuICAgIC8vIE1hcmsgaXQgYXMgaGF2aW5nIGNhcHR1cmVkIChpLmUuIHN1c3BlbmRlZCkuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gTGVhdmUgdGhlIGNoaWxkIGluIHBsYWNlLiBJLmUuIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50LlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIHJldHJ5IHRoaXMgYm91bmRhcnkgb25jZSB0aGUgc2VydmVyIGhhcyBzZW50IHRoZSByZXN1bHQuXG5cbiAgICB2YXIgcmV0cnkgPSByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5LmJpbmQobnVsbCwgY3VycmVudCk7XG4gICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkoc3VzcGVuc2VJbnN0YW5jZSwgcmV0cnkpO1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQuXG4gICAgcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUluc3RhbmNlLCBzdXNwZW5zZVN0YXRlLnRyZWVDb250ZXh0KTtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciBwcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKTsgLy8gTWFyayB0aGUgY2hpbGRyZW4gYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgIC8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuXG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gSHlkcmF0aW5nO1xuICAgIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCk7XG59XG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgZmlyc3RDaGlsZCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTWFyayBhbnkgU3VzcGVuc2UgYm91bmRhcmllcyB3aXRoIGZhbGxiYWNrcyBhcyBoYXZpbmcgd29yayB0byBkby5cbiAgLy8gSWYgdGhleSB3ZXJlIHByZXZpb3VzbHkgZm9yY2VkIGludG8gZmFsbGJhY2tzLCB0aGV5IG1heSBub3cgYmUgYWJsZVxuICAvLyB0byB1bmJsb2NrLlxuICB2YXIgbm9kZSA9IGZpcnN0Q2hpbGQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQpIHtcbiAgICAgIC8vIElmIHRoZSB0YWlsIGlzIGhpZGRlbiB0aGVyZSBtaWdodCBub3QgYmUgYW4gU3VzcGVuc2UgYm91bmRhcmllc1xuICAgICAgLy8gdG8gc2NoZWR1bGUgd29yayBvbi4gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgb24gdGhlXG4gICAgICAvLyBsaXN0IGl0c2VsZi5cbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgdG8gdHJhdmVyc2UgdG8gdGhlIGNoaWxkcmVuIG9mIHRoZSBsaXN0IHNpbmNlXG4gICAgICAvLyB0aGUgbGlzdCB3aWxsIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIHdoZW4gaXQgcmVyZW5kZXJzLlxuICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKG5vZGUsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZExhc3RDb250ZW50Um93KGZpcnN0Q2hpbGQpIHtcbiAgLy8gVGhpcyBpcyBnb2luZyB0byBmaW5kIHRoZSBsYXN0IHJvdyBhbW9uZyB0aGVzZSBjaGlsZHJlbiB0aGF0IGlzIGFscmVhZHlcbiAgLy8gc2hvd2luZyBjb250ZW50IG9uIHRoZSBzY3JlZW4sIGFzIG9wcG9zZWQgdG8gYmVpbmcgaW4gZmFsbGJhY2sgc3RhdGUgb3JcbiAgLy8gbmV3LiBJZiBhIHJvdyBoYXMgbXVsdGlwbGUgU3VzcGVuc2UgYm91bmRhcmllcywgYW55IG9mIHRoZW0gYmVpbmcgaW4gdGhlXG4gIC8vIGZhbGxiYWNrIHN0YXRlLCBjb3VudHMgYXMgdGhlIHdob2xlIHJvdyBiZWluZyBpbiBhIGZhbGxiYWNrIHN0YXRlLlxuICAvLyBOb3RlIHRoYXQgdGhlIFwicm93c1wiIHdpbGwgYmUgd29ya0luUHJvZ3Jlc3MsIGJ1dCBhbnkgbmVzdGVkIGNoaWxkcmVuXG4gIC8vIHdpbGwgc3RpbGwgYmUgY3VycmVudCBzaW5jZSB3ZSBoYXZlbid0IHJlbmRlcmVkIHRoZW0geWV0LiBUaGUgbW91bnRlZFxuICAvLyBvcmRlciBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBuZXcgb3JkZXIuIFdlIHVzZSB0aGUgbmV3IG9yZGVyLlxuICB2YXIgcm93ID0gZmlyc3RDaGlsZDtcbiAgdmFyIGxhc3RDb250ZW50Um93ID0gbnVsbDtcblxuICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgIGxhc3RDb250ZW50Um93ID0gcm93O1xuICAgIH1cblxuICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RDb250ZW50Um93O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAocmV2ZWFsT3JkZXIgIT09IHVuZGVmaW5lZCAmJiByZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICd0b2dldGhlcicgJiYgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSkge1xuICAgICAgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiByZXZlYWxPcmRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1VzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZm9yd2FyZCc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1JlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAodGFpbE1vZGUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdKSB7XG4gICAgICBpZiAodGFpbE1vZGUgIT09ICdjb2xsYXBzZWQnICYmIHRhaWxNb2RlICE9PSAnaGlkZGVuJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciB0YWlsIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgJyArICdcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gJyArICdEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAge1xuICAgIHZhciBpc0FuQXJyYXkgPSBpc0FycmF5KGNoaWxkU2xvdCk7XG4gICAgdmFyIGlzSXRlcmFibGUgPSAhaXNBbkFycmF5ICYmIHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCkgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoaXNBbkFycmF5IHx8IGlzSXRlcmFibGUpIHtcbiAgICAgIHZhciB0eXBlID0gaXNBbkFycmF5ID8gJ2FycmF5JyA6ICdpdGVyYWJsZSc7XG5cbiAgICAgIGVycm9yKCdBIG5lc3RlZCAlcyB3YXMgcGFzc2VkIHRvIHJvdyAjJXMgaW4gPFN1c3BlbnNlTGlzdCAvPi4gV3JhcCBpdCBpbiAnICsgJ2FuIGFkZGl0aW9uYWwgU3VzcGVuc2VMaXN0IHRvIGNvbmZpZ3VyZSBpdHMgcmV2ZWFsT3JkZXI6ICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+IC4uLiAnICsgJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPnslc308L1N1c3BlbnNlTGlzdD4gLi4uICcgKyAnPC9TdXNwZW5zZUxpc3Q+JywgdHlwZSwgaW5kZXgsIHR5cGUpO1xuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4oY2hpbGRyZW4sIHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAoKHJldmVhbE9yZGVyID09PSAnZm9yd2FyZHMnIHx8IHJldmVhbE9yZGVyID09PSAnYmFja3dhcmRzJykgJiYgY2hpbGRyZW4gIT09IHVuZGVmaW5lZCAmJiBjaGlsZHJlbiAhPT0gbnVsbCAmJiBjaGlsZHJlbiAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkcmVuW2ldLCBpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5JdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW5JdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHZhciBfaSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBzdGVwID0gY2hpbGRyZW5JdGVyYXRvci5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKHN0ZXAudmFsdWUsIF9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9pKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yKCdBIHNpbmdsZSByb3cgd2FzIHBhc3NlZCB0byBhIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCIlc1wiIC8+LiAnICsgJ1RoaXMgaXMgbm90IHVzZWZ1bCBzaW5jZSBpdCBuZWVkcyBtdWx0aXBsZSByb3dzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBwYXNzIG11bHRpcGxlIGNoaWxkcmVuIG9yIGFuIGFycmF5PycsIHJldmVhbE9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGlzQmFja3dhcmRzLCB0YWlsLCBsYXN0Q29udGVudFJvdywgdGFpbE1vZGUpIHtcbiAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocmVuZGVyU3RhdGUgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgaXNCYWNrd2FyZHM6IGlzQmFja3dhcmRzLFxuICAgICAgcmVuZGVyaW5nOiBudWxsLFxuICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgbGFzdDogbGFzdENvbnRlbnRSb3csXG4gICAgICB0YWlsOiB0YWlsLFxuICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIHJlbmRlcnMuXG4gICAgcmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcztcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IDA7XG4gICAgcmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93O1xuICAgIHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsO1xuICAgIHJlbmRlclN0YXRlLnRhaWxNb2RlID0gdGFpbE1vZGU7XG4gIH1cbn0gLy8gVGhpcyBjYW4gZW5kIHVwIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBtdWx0aXBsZSBwYXNzZXMuXG4vLyBUaGUgZmlyc3QgcGFzcyBzcGxpdHMgdGhlIGNoaWxkcmVuIGZpYmVycyBpbnRvIHR3byBzZXRzLiBBIGhlYWQgYW5kIHRhaWwuXG4vLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG4vLyBwYXNzIHRocm91Z2ggYmVnaW5Xb3JrIHRvIHJlcmVuZGVyIGFsbCBjaGlsZHJlbiAoaW5jbHVkaW5nIHRoZSB0YWlsKSB3aXRoXG4vLyB0aGUgZm9yY2Ugc3VzcGVuZCBjb250ZXh0LiBJZiB0aGUgZmlyc3QgcmVuZGVyIGRpZG4ndCBoYXZlIGFueXRoaW5nIGluXG4vLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cbi8vIFRoYXQgaGFwcGVucyBpbiB0aGUgY29tcGxldGVXb3JrIHBoYXNlIHdpdGhvdXQgZ29pbmcgYmFjayB0byBiZWdpbldvcmsuXG5cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXI7XG4gIHZhciB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4sIHJldmVhbE9yZGVyKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHZhciBzaG91bGRGb3JjZUZhbGxiYWNrID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblxuICBpZiAoc2hvdWxkRm9yY2VGYWxsYmFjaykge1xuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSBjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgLy8gSWYgd2UgcHJldmlvdXNseSBmb3JjZWQgYSBmYWxsYmFjaywgd2UgbmVlZCB0byBzY2hlZHVsZSB3b3JrXG4gICAgICAvLyBvbiBhbnkgbmVzdGVkIGJvdW5kYXJpZXMgdG8gbGV0IHRoZW0ga25vdyB0byB0cnkgdG8gcmVuZGVyXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxuICAgICAgcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIH1cblxuICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgLy8gSW4gbGVnYWN5IG1vZGUsIFN1c3BlbnNlTGlzdCBkb2Vzbid0IHdvcmsgc28gd2UganVzdFxuICAgIC8vIHVzZSBtYWtlIGl0IGEgbm9vcCBieSB0cmVhdGluZyBpdCBhcyB0aGUgZGVmYXVsdCByZXZlYWxPcmRlci5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGFzdENvbnRlbnRSb3cgPSBmaW5kTGFzdENvbnRlbnRSb3cod29ya0luUHJvZ3Jlc3MuY2hpbGQpO1xuICAgICAgICAgIHZhciB0YWlsO1xuXG4gICAgICAgICAgaWYgKGxhc3RDb250ZW50Um93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgbGlzdCBpcyBwYXJ0IG9mIHRoZSB0YWlsLlxuICAgICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgZmFzdCBwYXRoIGJ5IGp1c3QgcmVuZGVyaW5nIHRoZSB0YWlsIG5vdy5cbiAgICAgICAgICAgIHRhaWwgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgdGFpbCByb3dzIGFmdGVyIHRoZSBjb250ZW50IHJvdy5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGVtIHNlcGFyYXRlbHkgbGF0ZXIuXG4gICAgICAgICAgICB0YWlsID0gbGFzdENvbnRlbnRSb3cuc2libGluZztcbiAgICAgICAgICAgIGxhc3RDb250ZW50Um93LnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmluZCB0aGUgZmlyc3Qgcm93IHRoYXQgaGFzIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSB3ZSdyZSBnb2luZyB0byByZXZlcnNlIHRoZSBsaXN0IG9mIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAvLyB3ZSBwYXNzIGluIHRoZSBtZWFudGltZS4gVGhhdCdzIGdvaW5nIHRvIGJlIG91ciB0YWlsIGluIHJldmVyc2VcbiAgICAgICAgICAvLyBvcmRlci5cbiAgICAgICAgICB2YXIgX3RhaWwgPSBudWxsO1xuICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWFpbiBjb250ZW50LlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJvdztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0Um93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICByb3cuc2libGluZyA9IF90YWlsO1xuICAgICAgICAgICAgX3RhaWwgPSByb3c7XG4gICAgICAgICAgICByb3cgPSBuZXh0Um93O1xuICAgICAgICAgIH0gLy8gVE9ETzogSWYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgaXMgbnVsbCwgd2UgY2FuIGNvbnRpbnVlIG9uIHRoZSB0YWlsIGltbWVkaWF0ZWx5LlxuXG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIHRydWUsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgX3RhaWwsIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB0YWlsTW9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICB7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBudWxsLCAvLyB0YWlsXG4gICAgICAgICAgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHVuZGVmaW5lZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHJldmVhbCBvcmRlciBpcyB0aGUgc2FtZSBhcyBub3QgaGF2aW5nXG4gICAgICAgICAgLy8gYSBib3VuZGFyeS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBwcm92aWRlclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV3VmFsdWUgPSBuZXdQcm9wcy52YWx1ZTtcblxuICB7XG4gICAgaWYgKCEoJ3ZhbHVlJyBpbiBuZXdQcm9wcykpIHtcbiAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIpIHtcbiAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb3ZpZGVyUHJvcFR5cGVzID0gd29ya0luUHJvZ3Jlc3MudHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAocHJvdmlkZXJQcm9wVHlwZXMpIHtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3ZpZGVyUHJvcFR5cGVzLCBuZXdQcm9wcywgJ3Byb3AnLCAnQ29udGV4dC5Qcm92aWRlcicpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgbmV3VmFsdWUpO1xuXG4gIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0SXMob2xkVmFsdWUsIG5ld1ZhbHVlKSkge1xuICAgICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGNvbnRleHQgdmFsdWUgY2hhbmdlZC4gU2VhcmNoIGZvciBtYXRjaGluZyBjb25zdW1lcnMgYW5kIHNjaGVkdWxlXG4gICAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7IC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cblxuICB7XG4gICAgaWYgKGNvbnRleHQuX2NvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gVGhpcyBtYXkgYmUgYmVjYXVzZSBpdCdzIGEgQ29udGV4dCAocmF0aGVyIHRoYW4gYSBDb25zdW1lcikuXG4gICAgICAvLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG4gICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gd2FybiBpZiB3ZSdyZSBzdXJlIGl0J3MgYSBuZXcgUmVhY3QuXG4gICAgICBpZiAoY29udGV4dCAhPT0gY29udGV4dC5Db25zdW1lcikge1xuICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0Ll9jb250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHJlbmRlciA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICsgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICsgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICsgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJyk7XG4gICAgfVxuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5ld1ZhbHVlID0gcmVhZENvbnRleHQoY29udGV4dCk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXdDaGlsZHJlbjtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCkge1xuICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBSZXVzZSBwcmV2aW91cyBkZXBlbmRlbmNpZXNcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCB1cGRhdGUgXCJiYXNlXCIgcmVuZGVyIHRpbWVzIGZvciBiYWlsb3V0cy5cbiAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZygpO1xuICB9XG5cbiAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcyk7IC8vIENoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIGFueSBwZW5kaW5nIHdvcmsuXG5cbiAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSkge1xuICAgIC8vIFRoZSBjaGlsZHJlbiBkb24ndCBoYXZlIGFueSB3b3JrIGVpdGhlci4gV2UgY2FuIHNraXAgdGhlbS5cbiAgICAvLyBUT0RPOiBPbmNlIHdlIGFkZCBiYWNrIHJlc3VtaW5nLCB3ZSBzaG91bGQgY2hlY2sgaWYgdGhlIGNoaWxkcmVuIGFyZVxuICAgIC8vIGEgd29yay1pbi1wcm9ncmVzcyBzZXQuIElmIHNvLCB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZWlyIGVmZmVjdHMuXG4gICAge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIFRoaXMgZmliZXIgZG9lc24ndCBoYXZlIHdvcmssIGJ1dCBpdHMgc3VidHJlZSBkb2VzLiBDbG9uZSB0aGUgY2hpbGRcbiAgLy8gZmliZXJzIGFuZCBjb250aW51ZS5cblxuXG4gIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHJlbW91bnRGaWJlcihjdXJyZW50LCBvbGRXb3JrSW5Qcm9ncmVzcywgbmV3V29ya0luUHJvZ3Jlc3MpIHtcbiAge1xuICAgIHZhciByZXR1cm5GaWJlciA9IG9sZFdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICAgIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuJyk7XG4gICAgfSAvLyBEaXNjb25uZWN0IGZyb20gdGhlIG9sZCBjdXJyZW50LlxuICAgIC8vIEl0IHdpbGwgZ2V0IGRlbGV0ZWQuXG5cblxuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBvbGRXb3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBDb25uZWN0IHRvIHRoZSBuZXcgdHJlZS5cblxuICAgIG5ld1dvcmtJblByb2dyZXNzLmluZGV4ID0gb2xkV29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgbmV3V29ya0luUHJvZ3Jlc3Muc2libGluZyA9IG9sZFdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmV0dXJuID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJlZiA9IG9sZFdvcmtJblByb2dyZXNzLnJlZjsgLy8gUmVwbGFjZSB0aGUgY2hpbGQvc2libGluZyBwb2ludGVycyBhYm92ZSBpdC5cblxuICAgIGlmIChvbGRXb3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpIHtcbiAgICAgIHJldHVybkZpYmVyLmNoaWxkID0gbmV3V29ya0luUHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2U2libGluZyA9IHJldHVybkZpYmVyLmNoaWxkO1xuXG4gICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLicpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAocHJldlNpYmxpbmcuc2libGluZyAhPT0gb2xkV29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZTaWJsaW5nLnNpYmxpbmcgPSBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgICB9IC8vIERlbGV0ZSB0aGUgb2xkIGZpYmVyIGFuZCBwbGFjZSB0aGUgbmV3IG9uZS5cbiAgICAvLyBTaW5jZSB0aGUgb2xkIGZpYmVyIGlzIGRpc2Nvbm5lY3RlZCwgd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBtYW51YWxseS5cblxuXG4gICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcblxuICAgIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjdXJyZW50XTtcbiAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0aW9ucy5wdXNoKGN1cnJlbnQpO1xuICAgIH1cblxuICAgIG5ld1dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDsgLy8gUmVzdGFydCB3b3JrIGZyb20gdGhlIG5ldyBmaWJlci5cblxuICAgIHJldHVybiBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuICAvLyBCZWZvcmUgcGVyZm9ybWluZyBhbiBlYXJseSBiYWlsb3V0LCB3ZSBtdXN0IGNoZWNrIGlmIHRoZXJlIGFyZSBwZW5kaW5nXG4gIC8vIHVwZGF0ZXMgb3IgY29udGV4dC5cbiAgdmFyIHVwZGF0ZUxhbmVzID0gY3VycmVudC5sYW5lcztcblxuICBpZiAoaW5jbHVkZXNTb21lTGFuZSh1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm8gcGVuZGluZyB1cGRhdGUsIGJ1dCBiZWNhdXNlIGNvbnRleHQgaXMgcHJvcGFnYXRlZCBsYXppbHksIHdlIG5lZWRcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZpYmVyIGRvZXMgbm90IGhhdmUgYW55IHBlbmRpbmcgd29yay4gQmFpbG91dCB3aXRob3V0IGVudGVyaW5nXG4gIC8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAvLyBpbiB0aGlzIG9wdGltaXplZCBwYXRoLCBtb3N0bHkgcHVzaGluZyBzdHVmZiBvbnRvIHRoZSBzdGFjay5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLl9jb250ZXh0O1xuICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIG5ld1ZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICAvLyBQcm9maWxlciBzaG91bGQgb25seSBjYWxsIG9uUmVuZGVyIHdoZW4gb25lIG9mIGl0cyBkZXNjZW5kYW50cyBhY3R1YWxseSByZW5kZXJlZC5cbiAgICAgICAgdmFyIGhhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgIGlmIChoYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgLy8gUmVzZXQgZWZmZWN0IGR1cmF0aW9ucyBmb3IgdGhlIG5leHQgZXZlbnR1YWwgZWZmZWN0IHBoYXNlLlxuICAgICAgICAgIC8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG4gICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7IC8vIFdlIGtub3cgdGhhdCB0aGlzIGNvbXBvbmVudCB3aWxsIHN1c3BlbmQgYWdhaW4gYmVjYXVzZSBpZiBpdCBoYXNcbiAgICAgICAgICAgIC8vIGJlZW4gdW5zdXNwZW5kZWQgaXQgaGFzIGNvbW1pdHRlZCBhcyBhIHJlc29sdmVkIFN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICAgICAgICAgIC8vIElmIGl0IG5lZWRzIHRvIGJlIHJldHJpZWQsIGl0IHNob3VsZCBoYXZlIHdvcmsgc2NoZWR1bGVkIG9uIGl0LlxuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlOyAvLyBXZSBzaG91bGQgbmV2ZXIgcmVuZGVyIHRoZSBjaGlsZHJlbiBvZiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgdW50aWwgd2VcbiAgICAgICAgICAgIC8vIHVwZ3JhZGUgaXQuIFdlIHJldHVybiBudWxsIGluc3RlYWQgb2YgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yay5cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSAvLyBJZiB0aGlzIGJvdW5kYXJ5IGlzIGN1cnJlbnRseSB0aW1lZCBvdXQsIHdlIG5lZWQgdG8gZGVjaWRlXG4gICAgICAgICAgLy8gd2hldGhlciB0byByZXRyeSB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgb3IgdG8gc2tpcCBvdmVyIGl0IGFuZFxuICAgICAgICAgIC8vIGdvIHN0cmFpZ2h0IHRvIHRoZSBmYWxsYmFjay4gQ2hlY2sgdGhlIHByaW9yaXR5IG9mIHRoZSBwcmltYXJ5XG4gICAgICAgICAgLy8gY2hpbGQgZnJhZ21lbnQuXG5cblxuICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRMYW5lcyA9IHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXM7XG5cbiAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgcHJpbWFyeUNoaWxkTGFuZXMpKSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuICAgICAgICAgICAgLy8gdG8gYXR0ZW1wdCB0byByZW5kZXIgdGhlIHByaW1hcnkgY2hpbGRyZW4gYWdhaW4uXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBwZW5kaW5nIHdvcmsgbWFya2VkXG4gICAgICAgICAgICAvLyBvbiBpdFxuICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7IC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbiAgICAgICAgICAgIC8vIHByaW9yaXR5LiBCYWlsb3V0LlxuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGUgZmFsbGJhY2sgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFNraXAgb3ZlciB0aGVcbiAgICAgICAgICAgICAgLy8gcHJpbWFyeSBjaGlsZHJlbiBhbmQgd29yayBvbiB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogV2UgY2FuIHJldHVybiBgbnVsbGAgaGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgY2hlY2tlZFxuICAgICAgICAgICAgICAvLyB3aGV0aGVyIHRoZXJlIHdlcmUgbmVzdGVkIGNvbnRleHQgY29uc3VtZXJzLCB2aWEgdGhlIGNhbGwgdG9cbiAgICAgICAgICAgICAgLy8gYGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmtgIGFib3ZlLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICAgICAgdmFyIF9oYXNDaGlsZFdvcmsgPSBpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcblxuICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgIGlmIChfaGFzQ2hpbGRXb3JrKSB7XG4gICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgd2FzIGluIGZhbGxiYWNrIHN0YXRlIGxhc3QgdGltZSwgYW5kIHdlIGhhdmUgYWxsIHRoZVxuICAgICAgICAgICAgLy8gc2FtZSBjaGlsZHJlbiB0aGVuIHdlJ3JlIHN0aWxsIGluIHByb2dyZXNzaXZlIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAvLyBTb21ldGhpbmcgbWlnaHQgZ2V0IHVuYmxvY2tlZCBieSBzdGF0ZSB1cGRhdGVzIG9yIHJldHJpZXMgaW4gdGhlXG4gICAgICAgICAgICAvLyB0cmVlIHdoaWNoIHdpbGwgYWZmZWN0IHRoZSB0YWlsLiBTbyB3ZSBuZWVkIHRvIHVzZSB0aGUgbm9ybWFsXG4gICAgICAgICAgICAvLyBwYXRoIHRvIGNvbXB1dGUgdGhlIGNvcnJlY3QgdGFpbC5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB9IC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuXG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkIGJlZm9yZSBhbmQgd2UncmUgcmVuZGVyaW5nIHRoZSBzYW1lIGNoaWxkcmVuLFxuICAgICAgICAvLyB0aGVuIHRoZSB0YWlsIGRvZXNuJ3QgbWF0dGVyLiBBbnl0aGluZyBuZXcgdGhhdCBzdXNwZW5kcyB3aWxsIHdvcmtcbiAgICAgICAgLy8gaW4gdGhlIFwidG9nZXRoZXJcIiBtb2RlLCBzbyB3ZSBjYW4gY29udGludWUgZnJvbSB0aGUgc3RhdGUgd2UgaGFkLlxuXG5cbiAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAocmVuZGVyU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBSZXNldCB0byB0aGUgXCJ0b2dldGhlclwiIG1vZGUgaW4gY2FzZSB3ZSd2ZSBzdGFydGVkIGEgZGlmZmVyZW50XG4gICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBwYXN0IGJ1dCBkaWRuJ3QgY29tcGxldGUgaXQuXG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbnVsbDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG5cbiAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgLy8gdGhlbSBnb3QgcmV0cmllZCBzbyB0aGV5J2xsIHN0aWxsIGJlIGJsb2NrZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAgLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyZWUgc3RpbGwgbmVlZHMgdG8gYmUgZGVmZXJyZWQuIFRoaXMgaXNcbiAgICAgICAgLy8gYWxtb3N0IGlkZW50aWNhbCB0byB0aGUgbG9naWMgdXNlZCBpbiB0aGUgbm9ybWFsIHVwZGF0ZSBwYXRoLFxuICAgICAgICAvLyBzbyB3ZSdsbCBqdXN0IGVudGVyIHRoYXQuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgd2UnbGwgYmFpbCBvdXRcbiAgICAgICAgLy8gYXQgdGhlIG5leHQgbGV2ZWwgaW5zdGVhZCBvZiB0aGlzIG9uZSwgYmVjYXVzZSB0aGUgY2hpbGQgcHJvcHNcbiAgICAgICAgLy8gaGF2ZSBub3QgY2hhbmdlZC4gV2hpY2ggaXMgZmluZS5cbiAgICAgICAgLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIHJlZmFjdG9yIGBiZWdpbldvcmtgIHRvIHNwbGl0IHRoZSBiYWlsb3V0XG4gICAgICAgIC8vIHBhdGggZnJvbSB0aGUgbm9ybWFsIHBhdGguIEknbSB0ZW1wdGVkIHRvIGRvIGEgbGFiZWxlZCBicmVhayBoZXJlXG4gICAgICAgIC8vIGJ1dCBJIHdvbid0IDopXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVzdGFydCB0aGUgYmVnaW4gcGhhc2Ugd2l0aCBhIG5ldyBmaWJlci5cbiAgICAgIHJldHVybiByZW1vdW50RmliZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5rZXksIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgfHwgbnVsbCwgd29ya0luUHJvZ3Jlc3MubW9kZSwgd29ya0luUHJvZ3Jlc3MubGFuZXMpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IGhhc0NvbnRleHRDaGFuZ2VkKCkgfHwgKCAvLyBGb3JjZSBhIHJlLXJlbmRlciBpZiB0aGUgaW1wbGVtZW50YXRpb24gY2hhbmdlZCBkdWUgdG8gaG90IHJlbG9hZDpcbiAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gY3VycmVudC50eXBlICkpIHtcbiAgICAgIC8vIElmIHByb3BzIG9yIGNvbnRleHQgY2hhbmdlZCwgbWFyayB0aGUgZmliZXIgYXMgaGF2aW5nIHBlcmZvcm1lZCB3b3JrLlxuICAgICAgLy8gVGhpcyBtYXkgYmUgdW5zZXQgaWYgdGhlIHByb3BzIGFyZSBkZXRlcm1pbmVkIHRvIGJlIGVxdWFsIGxhdGVyIChtZW1vKS5cbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIHByb3BzIG5vciBsZWdhY3kgY29udGV4dCBjaGFuZ2VzLiBDaGVjayBpZiB0aGVyZSdzIGEgcGVuZGluZ1xuICAgICAgLy8gdXBkYXRlIG9yIGNvbnRleHQgY2hhbmdlLlxuICAgICAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQgJiYgLy8gSWYgdGhpcyBpcyB0aGUgc2Vjb25kIHBhc3Mgb2YgYW4gZXJyb3Igb3Igc3VzcGVuc2UgYm91bmRhcnksIHRoZXJlXG4gICAgICAvLyBtYXkgbm90IGJlIHdvcmsgc2NoZWR1bGVkIG9uIGBjdXJyZW50YCwgc28gd2UgY2hlY2sgZm9yIHRoaXMgZmxhZy5cbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIE5vIHBlbmRpbmcgdXBkYXRlcyBvciBjb250ZXh0LiBCYWlsIG91dCBub3cuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbiB0aGlzIGZpYmVyLCBidXQgdGhlcmUgYXJlIG5vIG5ldyBwcm9wc1xuICAgICAgICAvLyBub3IgbGVnYWN5IGNvbnRleHQuIFNldCB0aGlzIHRvIGZhbHNlLiBJZiBhbiB1cGRhdGUgcXVldWUgb3IgY29udGV4dFxuICAgICAgICAvLyBjb25zdW1lciBwcm9kdWNlcyBhIGNoYW5nZWQgdmFsdWUsIGl0IHdpbGwgc2V0IHRoaXMgdG8gdHJ1ZS4gT3RoZXJ3aXNlLFxuICAgICAgICAvLyB0aGUgY29tcG9uZW50IHdpbGwgYXNzdW1lIHRoZSBjaGlsZHJlbiBoYXZlIG5vdCBjaGFuZ2VkIGFuZCBiYWlsIG91dC5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBpc0ZvcmtlZENoaWxkKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjaGlsZCBiZWxvbmdzIHRvIGEgbGlzdCBvZiBtdWxpcGxlIGNoaWxkcmVuIGluXG4gICAgICAvLyBpdHMgcGFyZW50LlxuICAgICAgLy9cbiAgICAgIC8vIEluIGEgdHJ1ZSBtdWx0aS10aHJlYWRlZCBpbXBsZW1lbnRhdGlvbiwgd2Ugd291bGQgcmVuZGVyIGNoaWxkcmVuIG9uXG4gICAgICAvLyBwYXJhbGxlbCB0aHJlYWRzLiBUaGlzIHdvdWxkIHJlcHJlc2VudCB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IHJlbmRlclxuICAgICAgLy8gdGhyZWFkIGZvciB0aGlzIHN1YnRyZWUuXG4gICAgICAvL1xuICAgICAgLy8gV2Ugb25seSB1c2UgdGhpcyBmb3IgaWQgZ2VuZXJhdGlvbiBkdXJpbmcgaHlkcmF0aW9uLCB3aGljaCBpcyB3aHkgdGhlXG4gICAgICAvLyBsb2dpYyBpcyBsb2NhdGVkIGluIHRoaXMgc3BlY2lhbCBicmFuY2guXG4gICAgICB2YXIgc2xvdEluZGV4ID0gd29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IGdldEZvcmtzQXRMZXZlbCgpO1xuICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgbnVtYmVyT2ZGb3Jrcywgc2xvdEluZGV4KTtcbiAgICB9XG4gIH0gLy8gQmVmb3JlIGVudGVyaW5nIHRoZSBiZWdpbiBwaGFzZSwgY2xlYXIgcGVuZGluZyB1cGRhdGUgcHJpb3JpdHkuXG4gIC8vIFRPRE86IFRoaXMgYXNzdW1lcyB0aGF0IHdlJ3JlIGFib3V0IHRvIGV2YWx1YXRlIHRoZSBjb21wb25lbnQgYW5kIHByb2Nlc3NcbiAgLy8gdGhlIHVwZGF0ZSBxdWV1ZS4gSG93ZXZlciwgdGhlcmUncyBhbiBleGNlcHRpb246IFNpbXBsZU1lbW9Db21wb25lbnRcbiAgLy8gc29tZXRpbWVzIGJhaWxzIG91dCBsYXRlciBpbiB0aGUgYmVnaW4gcGhhc2UuIFRoaXMgaW5kaWNhdGVzIHRoYXQgd2Ugc2hvdWxkXG4gIC8vIG1vdmUgdGhpcyBhc3NpZ25tZW50IG91dCBvZiB0aGUgY29tbW9uIHBhdGggYW5kIGludG8gZWFjaCBicmFuY2guXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGU7XG4gICAgICAgIHJldHVybiBtb3VudExhenlDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnRUeXBlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gQ29tcG9uZW50ID8gdW5yZXNvbHZlZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHVucmVzb2x2ZWRQcm9wcyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBfQ29tcG9uZW50ID8gX3VucmVzb2x2ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudCwgX3VucmVzb2x2ZWRQcm9wcyk7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50LCBfcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSB0eXBlID8gX3VucmVzb2x2ZWRQcm9wczIgOiByZXNvbHZlRGVmYXVsdFByb3BzKHR5cGUsIF91bnJlc29sdmVkUHJvcHMyKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgX3Jlc29sdmVkUHJvcHMyLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHJldHVybiB1cGRhdGVQcm9maWxlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90eXBlMiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gUmVzb2x2ZSBvdXRlciBwcm9wcyBmaXJzdCwgdGhlbiByZXNvbHZlIGlubmVyIHByb3BzLlxuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczMgPSByZXNvbHZlRGVmYXVsdFByb3BzKF90eXBlMiwgX3VucmVzb2x2ZWRQcm9wczMpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IF90eXBlMi5wcm9wVHlwZXM7XG5cbiAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgX3Jlc29sdmVkUHJvcHMzLCAvLyBSZXNvbHZlZCBmb3Igb3V0ZXIgb25seVxuICAgICAgICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShfdHlwZTIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfcmVzb2x2ZWRQcm9wczMgPSByZXNvbHZlRGVmYXVsdFByb3BzKF90eXBlMi50eXBlLCBfcmVzb2x2ZWRQcm9wczMpO1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX3R5cGUyLCBfcmVzb2x2ZWRQcm9wczMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50MiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQyID8gX3VucmVzb2x2ZWRQcm9wczQgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQyLCBfdW5yZXNvbHZlZFByb3BzNCk7XG5cbiAgICAgICAgcmV0dXJuIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50MiwgX3Jlc29sdmVkUHJvcHM0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cbiAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIHZhciBfZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoKF9mbGFncyAmIFNob3VsZENhcHR1cmUpICE9PSBOb0ZsYWdzICYmIChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgcmVuZGVyIHRoYXQgd2Fzbid0IGNhcHR1cmVkIGJ5IGEgc3VzcGVuc2VcbiAgICAgICAgICAvLyBib3VuZGFyeS4gRG8gYSBzZWNvbmQgcGFzcyBvbiB0aGUgcm9vdCB0byB1bm1vdW50IHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH0gLy8gV2UgdW53b3VuZCB0byB0aGUgcm9vdCB3aXRob3V0IGNvbXBsZXRpbmcgaXQuIEV4aXQuXG5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCAmJiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RocmV3IGluIG5ld2x5IG1vdW50ZWQgZGVoeWRyYXRlZCBjb21wb25lbnQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluICcgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZmxhZ3MyID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKF9mbGFnczIgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MyICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlOyAvLyBDYXB0dXJlZCBhIHN1c3BlbnNlIGVmZmVjdC4gUmUtcmVuZGVyIHRoZSBib3VuZGFyeS5cblxuICAgICAgICAgIGlmICggKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTsgLy8gU3VzcGVuc2VMaXN0IGRvZXNuJ3QgYWN0dWFsbHkgY2F0Y2ggYW55dGhpbmcuIEl0IHNob3VsZCd2ZSBiZWVuXG4gICAgICAgIC8vIGNhdWdodCBieSBhIG5lc3RlZCBib3VuZGFyeS4gSWYgbm90LCBpdCBzaG91bGQgYnViYmxlIHRocm91Z2guXG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGUuX2NvbnRleHQ7XG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgcG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrLCByZW5kZXJMYW5lcykge1xuICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cbiAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcblxuICBzd2l0Y2ggKGludGVycnVwdGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBpbnRlcnJ1cHRlZFdvcmsudHlwZS5jaGlsZENvbnRleHRUeXBlcztcblxuICAgICAgICBpZiAoY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBvcENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3QgPSBpbnRlcnJ1cHRlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgdmFyIGNvbnRleHQgPSBpbnRlcnJ1cHRlZFdvcmsudHlwZS5fY29udGV4dDtcbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgcG9wUmVuZGVyTGFuZXMoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG5cbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59IC8vIFVzZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgdG8gdHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHN0YWNrLlxuLy8gQWxsb3dzIHVzIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIHJldHVybiBwYXRoIHRvIGZpbmQgdGhlIG5lYXJlc3QgT2Zmc2NyZWVuIGFuY2VzdG9yLlxuLy8gT25seSB1c2VkIHdoZW4gZW5hYmxlU3VzcGVuc2VMYXlvdXRFZmZlY3RTZW1hbnRpY3MgaXMgZW5hYmxlZC5cblxuXG52YXIgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gZmFsc2U7XG52YXIgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IGZhbHNlO1xudmFyIFBvc3NpYmx5V2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nID8gV2Vha1NldCA6IFNldDtcbnZhciBuZXh0RWZmZWN0ID0gbnVsbDsgLy8gVXNlZCBmb3IgUHJvZmlsaW5nIGJ1aWxkcyB0byB0cmFjayB1cGRhdGVycy5cblxudmFyIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG52YXIgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuZnVuY3Rpb24gcmVwb3J0VW5jYXVnaHRFcnJvckluREVWKGVycm9yKSB7XG4gIC8vIFdyYXBwaW5nIGVhY2ggc21hbGwgcGFydCBvZiB0aGUgY29tbWl0IHBoYXNlIGludG8gYSBndWFyZGVkXG4gIC8vIGNhbGxiYWNrIGlzIGEgYml0IHRvbyBzbG93IChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMTY2NikuXG4gIC8vIEJ1dCB3ZSByZWx5IG9uIGl0IHRvIHN1cmZhY2UgZXJyb3JzIHRvIERFViB0b29scyBsaWtlIG92ZXJsYXlzXG4gIC8vIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIxNzEyKS5cbiAgLy8gQXMgYSBjb21wcm9taXNlLCByZXRocm93IG9ubHkgY2F1Z2h0IGVycm9ycyBpbiBhIGd1YXJkLlxuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQsIGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufSAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBpbnN0YW5jZSkge1xuICB0cnkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lcihjdXJyZW50LCBpbnN0YW5jZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnREaWRNb3VudChjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBpbnN0YW5jZSkge1xuICB0cnkge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IG1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUF0dGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHRyeSB7XG4gICAgY29tbWl0QXR0YWNoUmVmKGN1cnJlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcmV0VmFsO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzICYmIGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgIHJldFZhbCA9IHJlZihudWxsKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldFZhbCA9IHJlZihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0VmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gYSBjYWxsYmFjayByZWYgaW4gJXMuICcgKyAnQSBjYWxsYmFjayByZWYgc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbi4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpIHtcbiAgdHJ5IHtcbiAgICBkZXN0cm95KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59XG5cbnZhciBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQpIHtcbiAgZm9jdXNlZEluc3RhbmNlSGFuZGxlID0gcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcbiAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCk7IC8vIFdlIG5vIGxvbmdlciBuZWVkIHRvIHRyYWNrIHRoZSBhY3RpdmUgaW5zdGFuY2UgZmliZXJcblxuICB2YXIgc2hvdWxkRmlyZSA9IHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG4gIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG4gIHJldHVybiBzaG91bGRGaXJlO1xufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfYmVnaW4oKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDsgLy8gVGhpcyBwaGFzZSBpcyBvbmx5IHVzZWQgZm9yIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ci5cblxuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBCZWZvcmVNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzICYmIGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaWJlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgIHNldEN1cnJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IHByZXZQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgJyArICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG5cbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKChlZmZlY3QudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAvLyBVbm1vdW50XG4gICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG4gICAgICAgIGVmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlJDEpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gTW91bnRcblxuXG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWZmZWN0LmRlc3Ryb3kgPSBjcmVhdGUoKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuXG4gICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGhvb2tOYW1lID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoKGVmZmVjdC50YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChlZmZlY3QudGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlRWZmZWN0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJyArICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSAnICsgaG9va05hbWUgKyAnKGFzeW5jICgpID0+IC4uLikgb3IgcmV0dXJuZWQgYSBQcm9taXNlLiAnICsgJ0luc3RlYWQsIHdyaXRlIHRoZSBhc3luYyBmdW5jdGlvbiBpbnNpZGUgeW91ciBlZmZlY3QgJyArICdhbmQgY2FsbCBpdCBpbW1lZGlhdGVseTpcXG5cXG4nICsgaG9va05hbWUgKyAnKCgpID0+IHtcXG4nICsgJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicgKyAnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicgKyAnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicgKyAnICAgIC8vIC4uLlxcbicgKyAnICB9XFxuJyArICcgIGZldGNoRGF0YSgpO1xcbicgKyBcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiICsgJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgZGVzdHJveTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJyVzIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sICcgKyAnd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXMnLCBob29rTmFtZSwgYWRkZW5kdW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG4gIHtcbiAgICAvLyBPbmx5IFByb2ZpbGVycyB3aXRoIHdvcmsgaW4gdGhlaXIgc3VidHJlZSB3aWxsIGhhdmUgYW4gVXBkYXRlIGVmZmVjdCBzY2hlZHVsZWQuXG4gICAgaWYgKChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBVcGRhdGUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgaWQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUuaWQsXG4gICAgICAgICAgICAgICAgb25Qb3N0Q29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLm9uUG9zdENvbW1pdDsgLy8gVGhpcyB2YWx1ZSB3aWxsIHN0aWxsIHJlZmxlY3QgdGhlIHByZXZpb3VzIGNvbW1pdCBwaGFzZS5cbiAgICAgICAgICAgIC8vIEl0IGRvZXMgbm90IGdldCByZXNldCB1bnRpbCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0IHBoYXNlLlxuXG4gICAgICAgICAgICB2YXIgY29tbWl0VGltZSA9IGdldENvbW1pdFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBwaGFzZSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZSc7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgPSAnbmVzdGVkLXVwZGF0ZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblBvc3RDb21taXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb25Qb3N0Q29tbWl0KGlkLCBwaGFzZSwgcGFzc2l2ZUVmZmVjdER1cmF0aW9uLCBjb21taXRUaW1lKTtcbiAgICAgICAgICAgIH0gLy8gQnViYmxlIHRpbWVzIHRvIHRoZSBuZXh0IG5lYXJlc3QgYW5jZXN0b3IgUHJvZmlsZXIuXG4gICAgICAgICAgICAvLyBBZnRlciB3ZSBwcm9jZXNzIHRoYXQgUHJvZmlsZXIsIHdlJ2xsIGJ1YmJsZSBmdXJ0aGVyIHVwLlxuXG5cbiAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IGZpbmlzaGVkV29yay5yZXR1cm47XG5cbiAgICAgICAgICAgIG91dGVyOiB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICByb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcblxuICAgICAgICAgICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgcGFyZW50U3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIoZmluaXNoZWRSb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKSB7XG4gIGlmICgoZmluaXNoZWRXb3JrLmZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoICFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IGxheW91dCBlZmZlY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCAoZHVyaW5nIG11dGF0aW9uIHBoYXNlKS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgICAgICAvLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IHNob3VsZCBuZXZlciBvdmVycmlkZSBhIHJlZiBzZXRcbiAgICAgICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG4gICAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZE1vdW50LiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTsgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cblxuXG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuXG4gICAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbiAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlOyAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgICAgb25Db21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uQ29tbWl0LFxuICAgICAgICAgICAgICAgIG9uUmVuZGVyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjtcbiAgICAgICAgICAgIHZhciBlZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICB2YXIgY29tbWl0VGltZSA9IGdldENvbW1pdFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBwaGFzZSA9IGN1cnJlbnQgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZSc7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgcGhhc2UgPSAnbmVzdGVkLXVwZGF0ZSc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgcGhhc2UsIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbiwgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsIGNvbW1pdFRpbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Db21taXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvbkNvbW1pdChmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgcGhhc2UsIGVmZmVjdER1cmF0aW9uLCBjb21taXRUaW1lKTtcbiAgICAgICAgICAgICAgfSAvLyBTY2hlZHVsZSBhIHBhc3NpdmUgZWZmZWN0IGZvciB0aGlzIFByb2ZpbGVyIHRvIGNhbGwgb25Qb3N0Q29tbWl0IGhvb2tzLlxuICAgICAgICAgICAgICAvLyBUaGlzIGVmZmVjdCBzaG91bGQgYmUgc2NoZWR1bGVkIGV2ZW4gaWYgdGhlcmUgaXMgbm8gb25Qb3N0Q29tbWl0IGNhbGxiYWNrIGZvciB0aGlzIFByb2ZpbGVyLFxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBlZmZlY3QgaXMgYWxzbyB3aGVyZSB0aW1lcyBidWJibGUgdG8gcGFyZW50IFByb2ZpbGVycy5cblxuXG4gICAgICAgICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0KGZpbmlzaGVkV29yayk7IC8vIFByb3BhZ2F0ZSBsYXlvdXQgZWZmZWN0IGR1cmF0aW9ucyB0byB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yLlxuICAgICAgICAgICAgICAvLyBEbyBub3QgcmVzZXQgdGhlc2UgdmFsdWVzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBzbyBEZXZUb29scyBoYXMgYSBjaGFuY2UgdG8gcmVhZCB0aGVtIGZpcnN0LlxuXG4gICAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IGZpbmlzaGVkV29yay5yZXR1cm47XG5cbiAgICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lZmZlY3REdXJhdGlvbiArPSBlZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPSBlZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgJyArICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoICFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAge1xuICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFJlZikge1xuICAgICAgICBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzT25GaWJlcihub2RlKSB7XG4gIC8vIFR1cm4gb24gbGF5b3V0IGVmZmVjdHMgaW4gYSB0cmVlIHRoYXQgcHJldmlvdXNseSBkaXNhcHBlYXJlZC5cbiAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBMYXlvdXRTdGF0aWNcbiAgc3dpdGNoIChub2RlLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBub2RlLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChub2RlLCBub2RlLnJldHVybik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tbWl0SG9va0xheW91dEVmZmVjdExpc3RNb3VudChub2RlLCBub2RlLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50RGlkTW91bnQobm9kZSwgbm9kZS5yZXR1cm4sIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihub2RlLCBub2RlLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlBdHRhY2hSZWYobm9kZSwgbm9kZS5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKSB7XG4gIC8vIE9ubHkgaGlkZSBvciB1bmhpZGUgdGhlIHRvcC1tb3N0IGhvc3Qgbm9kZXMuXG4gIHZhciBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuXG4gIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBudWxsKSB7XG4gICAgICAgICAgaG9zdFN1YnRyZWVSb290ID0gbm9kZTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmhpZGVJbnN0YW5jZShub2RlLnN0YXRlTm9kZSwgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBudWxsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UzID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgobm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50KSAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgbm9kZSAhPT0gZmluaXNoZWRXb3JrKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbm9kZSkge1xuICAgICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcbiAgICAgICAgaG9zdFN1YnRyZWVSb290ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB2YXIgaW5zdGFuY2VUb1VzZTtcblxuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgIH0gLy8gTW92ZWQgb3V0c2lkZSB0byBlbnN1cmUgRENFIHdvcmtzIHdpdGggdGhpcyBmbGFnXG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHJldFZhbDtcblxuICAgICAgaWYgKCBmaW5pc2hlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgIHJldFZhbCA9IHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRWYWwgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXRWYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZXR1cm4gdmFsdWUgZnJvbSBhIGNhbGxiYWNrIHJlZiBpbiAlcy4gJyArICdBIGNhbGxiYWNrIHJlZiBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuICcgKyAnVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlVG9Vc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyTXV0YXRpb24oZmliZXIpIHtcbiAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXIgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGV0ZWN0IGFuZCB3YXJuIGFnYWluc3Qgc3RhdGUgdXBkYXRlcyBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlxuICAvLyBJdCBhbHNvIHByZXZlbnRzIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIGZyb20gd2l0aGluIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzLlxuICAvL1xuICAvLyBJZGVhbGx5LCB3ZSBzaG91bGQgYWxzbyBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLlxuICAvLyBUaGlzIGNoaWxkIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjbGVhciBjaGlsZCBvciBzaWJsaW5nIHBvaW50ZXJzIHlldC5cbiAgLy8gVGhleSdyZSBuZWVkZWQgZm9yIHBhc3NpdmUgZWZmZWN0cyBhbmQgZm9yIGZpbmRET01Ob2RlLlxuICAvLyBXZSBkZWZlciB0aG9zZSBmaWVsZHMsIGFuZCBhbGwgb3RoZXIgY2xlYW51cCwgdG8gdGhlIHBhc3NpdmUgcGhhc2UgKHNlZSBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cykuXG4gIC8vXG4gIC8vIERvbid0IHJlc2V0IHRoZSBhbHRlcm5hdGUgeWV0LCBlaXRoZXIuIFdlIG5lZWQgdGhhdCBzbyB3ZSBjYW4gZGV0YWNoIHRoZVxuICAvLyBhbHRlcm5hdGUncyBmaWVsZHMgaW4gdGhlIHBhc3NpdmUgcGhhc2UuIENsZWFyaW5nIHRoZSByZXR1cm4gcG9pbnRlciBpc1xuICAvLyBzdWZmaWNpZW50IGZvciBmaW5kRE9NTm9kZSBzZW1hbnRpY3MuXG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5yZXR1cm4gPSBudWxsO1xuICB9XG5cbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpO1xuICB9IC8vIE5vdGU6IERlZmVuc2l2ZWx5IHVzaW5nIG5lZ2F0aW9uIGluc3RlYWQgb2YgPCBpbiBjYXNlXG4gIC8vIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgaXMgdW5kZWZpbmVkLlxuXG5cbiAge1xuICAgIC8vIENsZWFyIGN5Y2xpY2FsIEZpYmVyIGZpZWxkcy4gVGhpcyBsZXZlbCBhbG9uZSBpcyBkZXNpZ25lZCB0byByb3VnaGx5XG4gICAgLy8gYXBwcm94aW1hdGUgdGhlIHBsYW5uZWQgRmliZXIgcmVmYWN0b3IuIEluIHRoYXQgd29ybGQsIGBzZXRTdGF0ZWAgd2lsbCBiZVxuICAgIC8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG4gICAgLy8gb2JqZWN0IHdpbGwgbm90IGhhdmUgYW55IG9mIHRoZXNlIGZpZWxkcy4gSXQgd2lsbCBvbmx5IGJlIGNvbm5lY3RlZCB0b1xuICAgIC8vIHRoZSBmaWJlciB0cmVlIHZpYSBhIHNpbmdsZSBsaW5rIGF0IHRoZSByb290LiBTbyBpZiB0aGlzIGxldmVsIGFsb25lIGlzXG4gICAgLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG4gICAgZmliZXIuY2hpbGQgPSBudWxsO1xuICAgIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgZmliZXIuc2libGluZyA9IG51bGw7IC8vIFRoZSBgc3RhdGVOb2RlYCBpcyBjeWNsaWNhbCBiZWNhdXNlIG9uIGhvc3Qgbm9kZXMgaXQgcG9pbnRzIHRvIHRoZSBob3N0XG4gICAgLy8gdHJlZSwgd2hpY2ggaGFzIGl0cyBvd24gcG9pbnRlcnMgdG8gY2hpbGRyZW4sIHBhcmVudHMsIGFuZCBzaWJsaW5ncy5cbiAgICAvLyBUaGUgb3RoZXIgaG9zdCBub2RlcyBhbHNvIHBvaW50IGJhY2sgdG8gZmliZXJzLCBzbyB3ZSBzaG91bGQgZGV0YWNoIHRoYXRcbiAgICAvLyBvbmUsIHRvby5cblxuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDsgLy8gSSdtIGludGVudGlvbmFsbHkgbm90IGNsZWFyaW5nIHRoZSBgcmV0dXJuYCBmaWVsZCBpbiB0aGlzIGxldmVsLiBXZVxuICAgIC8vIGFscmVhZHkgZGlzY29ubmVjdCB0aGUgYHJldHVybmAgcG9pbnRlciBhdCB0aGUgcm9vdCBvZiB0aGUgZGVsZXRlZFxuICAgIC8vIHN1YnRyZWUgKGluIGBkZXRhY2hGaWJlck11dGF0aW9uYCkuIEJlc2lkZXMsIGByZXR1cm5gIGJ5IGl0c2VsZiBpcyBub3RcbiAgICAvLyBjeWNsaWNhbCDigJQgaXQncyBvbmx5IGN5Y2xpY2FsIHdoZW4gY29tYmluZWQgd2l0aCBgY2hpbGRgLCBgc2libGluZ2AsIGFuZFxuICAgIC8vIGBhbHRlcm5hdGVgLiBCdXQgd2UnbGwgY2xlYXIgaXQgaW4gdGhlIG5leHQgbGV2ZWwgYW55d2F5LCBqdXN0IGluIGNhc2UuXG5cbiAgICB7XG4gICAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gVGhlb3JldGljYWxseSwgbm90aGluZyBpbiBoZXJlIHNob3VsZCBiZSBuZWNlc3NhcnksIGJlY2F1c2Ugd2UgYWxyZWFkeVxuICAgICAgLy8gZGlzY29ubmVjdGVkIHRoZSBmaWJlciBmcm9tIHRoZSB0cmVlLiBTbyBldmVuIGlmIHNvbWV0aGluZyBsZWFrcyB0aGlzXG4gICAgICAvLyBwYXJ0aWN1bGFyIGZpYmVyLCBpdCB3b24ndCBsZWFrIGFueXRoaW5nIGVsc2VcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcHVycG9zZSBvZiB0aGlzIGJyYW5jaCBpcyB0byBiZSBzdXBlciBhZ2dyZXNzaXZlIHNvIHdlIGNhbiBtZWFzdXJlXG4gICAgICAvLyBpZiB0aGVyZSdzIGFueSBkaWZmZXJlbmNlIGluIG1lbW9yeSBpbXBhY3QuIElmIHRoZXJlIGlzLCB0aGF0IGNvdWxkXG4gICAgICAvLyBpbmRpY2F0ZSBhIFJlYWN0IGxlYWsgd2UgZG9uJ3Qga25vdyBhYm91dC5cbiAgICAgIGZpYmVyLnJldHVybiA9IG51bGw7XG4gICAgICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsOyAvLyBUT0RPOiBNb3ZlIHRvIGBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcmAgaW5zdGVhZC5cblxuICAgICAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RSb290IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbDtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgLy8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4gIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgLy8gVE9ETzogRmluZCBhIG1vcmUgZWZmaWNpZW50IHdheSB0byBkbyB0aGlzLlxuICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcblxuICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQgJiYgbm9kZS50YWcgIT09IERlaHlkcmF0ZWRGcmFnbWVudCkge1xuICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgaWYgKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG5cblxuICAgICAgaWYgKG5vZGUuY2hpbGQgPT09IG51bGwgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cblxuXG4gICAgaWYgKCEobm9kZS5mbGFncyAmIFBsYWNlbWVudCkpIHtcbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG5cblxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgICAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICB2YXIgX3BhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgX2JlZm9yZSwgX3BhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gVGhlc2UgYXJlIHRyYWNrZWQgb24gdGhlIHN0YWNrIGFzIHdlIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFcbi8vIGRlbGV0ZWQgc3VidHJlZS5cbi8vIFRPRE86IFVwZGF0ZSB0aGVzZSBkdXJpbmcgdGhlIHdob2xlIG11dGF0aW9uIHBoYXNlLCBub3QganVzdCBkdXJpbmdcbi8vIGEgZGVsZXRpb24uXG5cblxudmFyIGhvc3RQYXJlbnQgPSBudWxsO1xudmFyIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHMocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcikge1xuICB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgZGVsZXRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQsIGRldGFjaCByZWZzLCBjbGVhblxuICAgIC8vIHVwIG1vdW50ZWQgbGF5b3V0IGVmZmVjdHMsIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50LlxuICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIHRvcG1vc3QgaG9zdCBjaGlsZCBpbiBlYWNoIGJyYW5jaC4gQnV0IHRoZW4gd2VcbiAgICAvLyBzdGlsbCBuZWVkIHRvIGtlZXAgdHJhdmVyc2luZyB0byB1bm1vdW50IGVmZmVjdHMsIHJlZnMsIGFuZCBjV1UuIFRPRE86IFdlXG4gICAgLy8gY291bGQgc3BsaXQgdGhpcyBpbnRvIHR3byBzZXBhcmF0ZSB0cmF2ZXJzYWxzIGZ1bmN0aW9ucywgd2hlcmUgdGhlIHNlY29uZFxuICAgIC8vIG9uZSBkb2Vzbid0IGluY2x1ZGUgYW55IHJlbW92ZUNoaWxkIGxvZ2ljLiBUaGlzIGlzIG1heWJlIHRoZSBzYW1lXG4gICAgLy8gZnVuY3Rpb24gYXMgXCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzXCIgKG9yIHdoYXRldmVyIHRoYXQgdHVybnMgaW50byBhZnRlclxuICAgIC8vIHRoZSBsYXlvdXQgcGhhc2UgaXMgcmVmYWN0b3JlZCB0byB1c2UgcmVjdXJzaW9uKS5cbiAgICAvLyBCZWZvcmUgc3RhcnRpbmcsIGZpbmQgdGhlIG5lYXJlc3QgaG9zdCBwYXJlbnQgb24gdGhlIHN0YWNrIHNvIHdlIGtub3dcbiAgICAvLyB3aGljaCBpbnN0YW5jZS9jb250YWluZXIgdG8gcmVtb3ZlIHRoZSBjaGlsZHJlbiBmcm9tLlxuICAgIC8vIFRPRE86IEluc3RlYWQgb2Ygc2VhcmNoaW5nIHVwIHRoZSBmaWJlciByZXR1cm4gcGF0aCBvbiBldmVyeSBkZWxldGlvbiwgd2VcbiAgICAvLyBjYW4gdHJhY2sgdGhlIG5lYXJlc3QgaG9zdCBjb21wb25lbnQgb24gdGhlIEpTIHN0YWNrIGFzIHdlIHRyYXZlcnNlIHRoZVxuICAgIC8vIHRyZWUgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoaXMgd291bGQgbWFrZSBpbnNlcnRpb25zIGZhc3RlciwgdG9vLlxuICAgIHZhciBwYXJlbnQgPSByZXR1cm5GaWJlcjtcblxuICAgIGZpbmRQYXJlbnQ6IHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaG9zdFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnICsgJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpO1xuICAgIGhvc3RQYXJlbnQgPSBudWxsO1xuICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICB9XG5cbiAgZGV0YWNoRmliZXJNdXRhdGlvbihkZWxldGVkRmliZXIpO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgcGFyZW50KSB7XG4gIC8vIFRPRE86IFVzZSBhIHN0YXRpYyBmbGFnIHRvIHNraXAgdHJlZXMgdGhhdCBkb24ndCBoYXZlIHVubW91bnQgZWZmZWN0c1xuICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGNoaWxkKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcikge1xuICBvbkNvbW1pdFVubW91bnQoZGVsZXRlZEZpYmVyKTsgLy8gVGhlIGNhc2VzIGluIHRoaXMgb3V0ZXIgc3dpdGNoIG1vZGlmeSB0aGUgc3RhY2sgYmVmb3JlIHRoZXkgdHJhdmVyc2VcbiAgLy8gaW50byB0aGVpciBzdWJ0cmVlLiBUaGVyZSBhcmUgc2ltcGxlciBjYXNlcyBpbiB0aGUgaW5uZXIgc3dpdGNoXG4gIC8vIHRoYXQgZG9uJ3QgbW9kaWZ5IHRoZSBzdGFjay5cblxuICBzd2l0Y2ggKGRlbGV0ZWRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9IC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoIHRvIG5leHQgYnJhbmNoXG5cbiAgICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIG5lYXJlc3QgaG9zdCBjaGlsZC4gU2V0IHRoZSBob3N0IHBhcmVudFxuICAgICAgICAvLyB0byBgbnVsbGAgb24gdGhlIHN0YWNrIHRvIGluZGljYXRlIHRoYXQgbmVzdGVkIGNoaWxkcmVuIGRvbid0XG4gICAgICAgIC8vIG5lZWQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG5cbiAgICAgICAgICBpZiAoaG9zdFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gTm93IHRoYXQgYWxsIHRoZSBjaGlsZCBlZmZlY3RzIGhhdmUgdW5tb3VudGVkLCB3ZSBjYW4gcmVtb3ZlIHRoZVxuICAgICAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW1vdmVDaGlsZChob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IGFuZCBhbGwgb2YgaXRzIGNvbnRlbnQuXG5cblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGhvc3RQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChob3N0UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcihob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBfcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBkZWxldGVkRmliZXIudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgICAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciBfZWZmZWN0ID0gZWZmZWN0LFxuICAgICAgICAgICAgICAgICAgICBkZXN0cm95ID0gX2VmZmVjdC5kZXN0cm95LFxuICAgICAgICAgICAgICAgICAgICB0YWcgPSBfZWZmZWN0LnRhZztcblxuICAgICAgICAgICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChkZWxldGVkRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWxldGVkRmliZXIubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZWFkIGZsYWdcbiAgICAgICAgIGRlbGV0ZWRGaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIG9mZnNjcmVlbiBjb21wb25lbnQgaXMgaGlkZGVuLCB3ZSBhbHJlYWR5IHVubW91bnRlZCBpdC4gQmVmb3JlXG4gICAgICAgICAgLy8gZGVsZXRpbmcgdGhlIGNoaWxkcmVuLCB0cmFjayB0aGF0IGl0J3MgYWxyZWFkeSB1bm1vdW50ZWQgc28gdGhhdCB3ZVxuICAgICAgICAgIC8vIGRvbid0IGF0dGVtcHQgdG8gdW5tb3VudCB0aGUgZWZmZWN0cyBhZ2Fpbi5cbiAgICAgICAgICAvLyBUT0RPOiBJZiB0aGUgdHJlZSBpcyBoaWRkZW4sIGluIG1vc3QgY2FzZXMgd2Ugc2hvdWxkIGJlIGFibGUgdG8gc2tpcFxuICAgICAgICAgIC8vIG92ZXIgdGhlIG5lc3RlZCBjaGlsZHJlbiBlbnRpcmVseS4gQW4gZXhjZXB0aW9uIGlzIHdlIGhhdmVuJ3QgeWV0IGZvdW5kXG4gICAgICAgICAgLy8gdGhlIHRvcG1vc3QgaG9zdCBub2RlIHRvIGRlbGV0ZSwgd2hpY2ggd2UgYWxyZWFkeSB0cmFjayBvbiB0aGUgc3RhY2suXG4gICAgICAgICAgLy8gQnV0IHRoZSBvdGhlciBjYXNlIGlzIHBvcnRhbHMsIHdoaWNoIG5lZWQgdG8gYmUgZGV0YWNoZWQgbm8gbWF0dGVyIGhvd1xuICAgICAgICAgIC8vIGRlZXBseSB0aGV5IGFyZSBuZXN0ZWQuIFdlIHNob3VsZCB1c2UgYSBzdWJ0cmVlIGZsYWcgdG8gdHJhY2sgd2hldGhlciBhXG4gICAgICAgICAgLy8gc3VidHJlZSBpbmNsdWRlcyBhIG5lc3RlZCBwb3J0YWwuXG4gICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHwgZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKSB7XG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBwYXNzaXZlIHBoYXNlXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gcHJldlN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgICAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspIHtcbiAgLy8gSWYgdGhpcyBib3VuZGFyeSBqdXN0IHRpbWVkIG91dCwgdGhlbiBpdCB3aWxsIGhhdmUgYSBzZXQgb2Ygd2FrZWFibGVzLlxuICAvLyBGb3IgZWFjaCB3YWtlYWJsZSwgYXR0YWNoIGEgbGlzdGVuZXIgc28gdGhhdCB3aGVuIGl0IHJlc29sdmVzLCBSZWFjdFxuICAvLyBhdHRlbXB0cyB0byByZS1yZW5kZXIgdGhlIGJvdW5kYXJ5IGluIHRoZSBwcmltYXJ5IChwcmUtdGltZW91dCkgc3RhdGUuXG4gIHZhciB3YWtlYWJsZXMgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgaWYgKHdha2VhYmxlcyAhPT0gbnVsbCkge1xuICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgaWYgKHJldHJ5Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpO1xuICAgIH1cblxuICAgIHdha2VhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uICh3YWtlYWJsZSkge1xuICAgICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgYm91bmRhcnkgZmliZXIgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuICAgICAgdmFyIHJldHJ5ID0gcmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHdha2VhYmxlKTtcblxuICAgICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkpIHtcbiAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIGlmIChpblByb2dyZXNzTGFuZXMgIT09IG51bGwgJiYgaW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIGFzc29jaWF0ZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnMgd2l0aCBpdC5cbiAgICAgICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhpblByb2dyZXNzUm9vdCwgaW5Qcm9ncmVzc0xhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCdFeHBlY3RlZCBmaW5pc2hlZCByb290IGFuZCBsYW5lcyB0byBiZSBzZXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGVuIGEgU3VzcGVuc2UgYm91bmRhcnkgZ29lcyBmcm9tIHZpc2libGUgdG8gaGlkZGVuLlxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgc2V0Q3VycmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KTtcbiAgc2V0Q3VycmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgbGFuZXMpIHtcbiAgLy8gRGVsZXRpb25zIGVmZmVjdHMgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXIgdHlwZS4gVGhleSBuZWVkIHRvIGhhcHBlblxuICAvLyBiZWZvcmUgdGhlIGNoaWxkcmVuIGVmZmVjdHMgaGFlIGZpcmVkLlxuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuXG4gIGlmIChkZWxldGlvbnMgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjaGlsZFRvRGVsZXRlLCBwYXJlbnRGaWJlciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBNdXRhdGlvbk1hc2spIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGNoaWxkKTtcbiAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoY2hpbGQsIHJvb3QpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnRGaWJlcihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290LCBsYW5lcykge1xuICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFnczsgLy8gVGhlIGVmZmVjdCBmbGFnIHNob3VsZCBiZSBjaGVja2VkICphZnRlciogd2UgcmVmaW5lIHRoZSB0eXBlIG9mIGZpYmVyLFxuICAvLyBiZWNhdXNlIHRoZSBmaWJlciB0YWcgaXMgbW9yZSBzcGVjaWZpYy4gQW4gZXhjZXB0aW9uIGlzIGFueSBmbGFnIHJlbGF0ZWRcbiAgLy8gdG8gcmVjb25jaWxhdGlvbiwgYmVjYXVzZSB0aG9zZSBjYW4gYmUgc2V0IG9uIGFsbCBmaWJlciB0eXBlcy5cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChJbnNlcnRpb24gfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH0gLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgICAgLy8gZGVzdHJveSBmdW5jdGlvbnMgZm9yIGFsbCBmaWJlcnMgYXJlIGNhbGxlZCBiZWZvcmUgYW55IGNyZWF0ZSBmdW5jdGlvbnMuXG4gICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBzaWJsaW5nIGNvbXBvbmVudCBlZmZlY3RzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLFxuICAgICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG5cblxuICAgICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogQ29udGVudFJlc2V0IGdldHMgY2xlYXJlZCBieSB0aGUgY2hpbGRyZW4gZHVyaW5nIHRoZSBjb21taXRcbiAgICAgICAgICAvLyBwaGFzZS4gVGhpcyBpcyBhIHJlZmFjdG9yIGhhemFyZCBiZWNhdXNlIGl0IG1lYW5zIHdlIG11c3QgcmVhZFxuICAgICAgICAgIC8vIGZsYWdzIHRoZSBmbGFncyBhZnRlciBgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzYCBoYXMgYWxyZWFkeSBydW47XG4gICAgICAgICAgLy8gdGhlIG9yZGVyIG1hdHRlcnMuIFdlIHNob3VsZCByZWZhY3RvciBzbyB0aGF0IENvbnRlbnRSZXNldCBkb2VzIG5vdFxuICAgICAgICAgIC8vIHJlbHkgb24gbXV0YXRpbmcgdGhlIGZsYWcgZHVyaW5nIGNvbW1pdC4gTGlrZSBieSBzZXR0aW5nIGEgZmxhZ1xuICAgICAgICAgIC8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIGluc3RlYWQuXG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzZXRUZXh0Q29udGVudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2U0ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZTQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7IC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb21taXRVcGRhdGUoX2luc3RhbmNlNCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2Um9vdFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2Um9vdFN0YXRlLmlzRGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgdmFyIG9mZnNjcmVlbkZpYmVyID0gZmluaXNoZWRXb3JrLmNoaWxkO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5GaWJlci5mbGFncyAmIFZpc2liaWxpdHkpIHtcbiAgICAgICAgICB2YXIgbmV3U3RhdGUgPSBvZmZzY3JlZW5GaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBpc0hpZGRlbiA9IG5ld1N0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gb2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlICE9PSBudWxsICYmIG9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIXdhc0hpZGRlbikge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRvIHBhc3NpdmUgcGhhc2VcbiAgICAgICAgICAgICAgbWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdFN1c3BlbnNlQ2FsbGJhY2soZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfd2FzSGlkZGVuID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKCAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZWFkIGZsYWdcbiAgICAgICAgIGZpbmlzaGVkV29yay5tb2RlICYgQ29uY3VycmVudE1vZGUpIHtcbiAgICAgICAgICAvLyBCZWZvcmUgY29tbWl0dGluZyB0aGUgY2hpbGRyZW4sIHRyYWNrIG9uIHRoZSBzdGFjayB3aGV0aGVyIHRoaXNcbiAgICAgICAgICAvLyBvZmZzY3JlZW4gc3VidHJlZSB3YXMgYWxyZWFkeSBoaWRkZW4sIHNvIHRoYXQgd2UgZG9uJ3QgdW5tb3VudCB0aGVcbiAgICAgICAgICAvLyBlZmZlY3RzIGFnYWluLlxuICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8IF93YXNIaWRkZW47XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgdmFyIF9uZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgdmFyIF9pc0hpZGRlbiA9IF9uZXdTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIHZhciBvZmZzY3JlZW5Cb3VuZGFyeSA9IGZpbmlzaGVkV29yaztcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgbmVlZHMgdG8gcnVuIHdoZW5ldmVyIHRoZXJlJ3MgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZVxuICAgICAgICAgICAgLy8gaW5zaWRlIGEgaGlkZGVuIE9mZnNjcmVlbiB0cmVlLlxuICAgICAgICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4ob2Zmc2NyZWVuQm91bmRhcnksIF9pc0hpZGRlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKF9pc0hpZGRlbikge1xuICAgICAgICAgICAgICBpZiAoIV93YXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoKG9mZnNjcmVlbkJvdW5kYXJ5Lm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IG9mZnNjcmVlbkJvdW5kYXJ5O1xuICAgICAgICAgICAgICAgICAgdmFyIG9mZnNjcmVlbkNoaWxkID0gb2Zmc2NyZWVuQm91bmRhcnkuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzY3JlZW5DaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gb2Zmc2NyZWVuQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHNfYmVnaW4ob2Zmc2NyZWVuQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzY3JlZW5DaGlsZCA9IG9mZnNjcmVlbkNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICAvLyBQbGFjZW1lbnQgZWZmZWN0cyAoaW5zZXJ0aW9ucywgcmVvcmRlcnMpIGNhbiBiZSBzY2hlZHVsZWQgb24gYW55IGZpYmVyXG4gIC8vIHR5cGUuIFRoZXkgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSBjaGlsZHJlbiBlZmZlY3RzIGhhdmUgZmlyZWQsIGJ1dFxuICAvLyBiZWZvcmUgdGhlIGVmZmVjdHMgb24gdGhpcyBmaWJlciBoYXZlIGZpcmVkLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgaWYgKGZsYWdzICYgUGxhY2VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9IC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzXG4gICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAvLyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIGtpbGwgdGhpcy5cblxuXG4gICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5QbGFjZW1lbnQ7XG4gIH1cblxuICBpZiAoZmxhZ3MgJiBIeWRyYXRpbmcpIHtcbiAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gfkh5ZHJhdGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgbmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihmaW5pc2hlZFdvcmssIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICAvLyBTdXNwZW5zZSBsYXlvdXQgZWZmZWN0cyBzZW1hbnRpY3MgZG9uJ3QgY2hhbmdlIGZvciBsZWdhY3kgcm9vdHMuXG4gIHZhciBpc01vZGVyblJvb3QgPSAoc3VidHJlZVJvb3QubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKCBmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBpc01vZGVyblJvb3QpIHtcbiAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgT2Zmc2NyZWVuIHN0YWNrJ3Mgc3RhdGUuXG4gICAgICB2YXIgaXNIaWRkZW4gPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcblxuICAgICAgaWYgKG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbikge1xuICAgICAgICAvLyBUaGUgT2Zmc2NyZWVuIHRyZWUgaXMgaGlkZGVuLiBTa2lwIG92ZXIgaXRzIGxheW91dCBlZmZlY3RzLlxuICAgICAgICBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIEFsc28gY2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dE1hc2tcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSB3YXNIaWRkZW4gfHwgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47IC8vIFRyYXZlcnNlIHRoZSBPZmZzY3JlZW4gc3VidHJlZSB3aXRoIHRoZSBjdXJyZW50IE9mZnNjcmVlbiBhcyB0aGUgcm9vdC5cblxuICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuICYmICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSByZWFwcGVhcmluZyBib3VuZGFyeS4gVHVybiBpdHMgbGF5b3V0IGVmZmVjdHNcbiAgICAgICAgICAvLyBiYWNrIG9uLlxuICAgICAgICAgIG5leHRFZmZlY3QgPSBmaWJlcjtcbiAgICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfYmVnaW4oZmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZmlyc3RDaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0c19iZWdpbihjaGlsZCwgLy8gTmV3IHJvb3Q7IGJ1YmJsZSBiYWNrIHVwIHRvIGhlcmUgYW5kIHN0b3AuXG4gICAgICAgICAgcm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfSAvLyBSZXN0b3JlIE9mZnNjcmVlbiBzdGF0ZSBhbmQgcmVzdW1lIGluIG91ci1wcm9ncmVzcyB0cmF2ZXJzYWwuXG5cblxuICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXI7XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MgJiYgZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRMYXlvdXRNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGF5b3V0TW91bnRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBjdXJyZW50LCBmaWJlciwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19iZWdpbihzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBmaWJlci5jaGlsZDsgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiAoUmVmU3RhdGljIHwgTGF5b3V0U3RhdGljKVxuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIGZpYmVyLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0LCBmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCwgZmliZXIsIGZpYmVyLnJldHVybik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgUmVmU3RhdGljXG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChmaWJlciwgZmliZXIucmV0dXJuLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpYmVyLCBmaWJlci5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhXG4gICAgICAgICAgdmFyIGlzSGlkZGVuID0gZmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgLy8gTmVzdGVkIE9mZnNjcmVlbiB0cmVlIGlzIGFscmVhZHkgaGlkZGVuLiBEb24ndCBkaXNhcHBlYXJcbiAgICAgICAgICAgIC8vIGl0cyBlZmZlY3RzLlxuICAgICAgICAgICAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogc3VidHJlZUZsYWdzICYgTGF5b3V0U3RhdGljXG5cblxuICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICBmaXJzdENoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2NvbXBsZXRlKHN1YnRyZWVSb290KSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290KSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gT2Zmc2NyZWVuQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaXNIaWRkZW4gPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgLy8gTmVzdGVkIE9mZnNjcmVlbiB0cmVlIGlzIHN0aWxsIGhpZGRlbi4gRG9uJ3QgcmUtYXBwZWFyIGl0cyBlZmZlY3RzLlxuICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IHN1YnRyZWVGbGFncyAmIExheW91dFN0YXRpY1xuXG5cbiAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBub2RlIG1heSBoYXZlIGJlZW4gcmV1c2VkIGZyb20gYSBwcmV2aW91cyByZW5kZXIsIHNvIHdlIGNhbid0XG4gICAgICAvLyBhc3N1bWUgaXRzIHJldHVybiBwb2ludGVyIGlzIGNvcnJlY3QuXG4gICAgICBmaXJzdENoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZShzdWJ0cmVlUm9vdCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgTGF5b3V0U3RhdGljXG5cbiAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIoZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblxuICAgIGlmIChmaWJlciA9PT0gc3VidHJlZVJvb3QpIHtcbiAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIG5vZGUgbWF5IGhhdmUgYmVlbiByZXVzZWQgZnJvbSBhIHByZXZpb3VzIHJlbmRlciwgc28gd2UgY2FuJ3RcbiAgICAgIC8vIGFzc3VtZSBpdHMgcmV0dXJuIHBvaW50ZXIgaXMgY29ycmVjdC5cbiAgICAgIHNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIG5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4oZmluaXNoZWRXb3JrLCByb290LCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2JlZ2luKHN1YnRyZWVSb290LCByb290LCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBmaXJzdENoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICBpZiAoKGZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyAmJiBmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICBmaXJzdENoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfY29tcGxldGUoc3VidHJlZVJvb3QsIHJvb3QsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCwgZmliZXIsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyID09PSBzdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIGZpbmlzaGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgICBzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmlyc3RDaGlsZCkge1xuICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcbiAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzX2JlZ2luKCk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbigpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKChuZXh0RWZmZWN0LmZsYWdzICYgQ2hpbGREZWxldGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBmaWJlci5kZWxldGlvbnM7XG5cbiAgICAgIGlmIChkZWxldGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZmliZXJUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gZmliZXJUb0RlbGV0ZTtcbiAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGZpYmVyVG9EZWxldGUsIGZpYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBBIGZpYmVyIHdhcyBkZWxldGVkIGZyb20gdGhpcyBwYXJlbnQgZmliZXIsIGJ1dCBpdCdzIHN0aWxsIHBhcnQgb2ZcbiAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgKGFsdGVybmF0ZSkgcGFyZW50IGZpYmVyJ3MgbGlzdCBvZiBjaGlsZHJlbi4gQmVjYXVzZVxuICAgICAgICAgIC8vIGNoaWxkcmVuIGFyZSBhIGxpbmtlZCBsaXN0LCBhbiBlYXJsaWVyIHNpYmxpbmcgdGhhdCdzIHN0aWxsIGFsaXZlXG4gICAgICAgICAgLy8gd2lsbCBiZSBjb25uZWN0ZWQgdG8gdGhlIGRlbGV0ZWQgZmliZXIgdmlhIGl0cyBgYWx0ZXJuYXRlYDpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vICAgbGl2ZSBmaWJlclxuICAgICAgICAgIC8vICAgLS1hbHRlcm5hdGUtLT4gcHJldmlvdXMgbGl2ZSBmaWJlclxuICAgICAgICAgIC8vICAgLS1zaWJsaW5nLS0+IGRlbGV0ZWQgZmliZXJcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIGNhbid0IGRpc2Nvbm5lY3QgYGFsdGVybmF0ZWAgb24gbm9kZXMgdGhhdCBoYXZlbid0IGJlZW4gZGVsZXRlZFxuICAgICAgICAgIC8vIHlldCwgYnV0IHdlIGNhbiBkaXNjb25uZWN0IHRoZSBgc2libGluZ2AgYW5kIGBjaGlsZGAgcG9pbnRlcnMuXG4gICAgICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICBpZiAocHJldmlvdXNGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRldGFjaGVkQ2hpbGQgPSBwcmV2aW91c0ZpYmVyLmNoaWxkO1xuXG4gICAgICAgICAgICBpZiAoZGV0YWNoZWRDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c0ZpYmVyLmNoaWxkID0gbnVsbDtcblxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIGRldGFjaGVkU2libGluZyA9IGRldGFjaGVkQ2hpbGQuc2libGluZztcbiAgICAgICAgICAgICAgICBkZXRhY2hlZENoaWxkLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGRldGFjaGVkQ2hpbGQgPSBkZXRhY2hlZFNpYmxpbmc7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGRldGFjaGVkQ2hpbGQgIT09IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRFZmZlY3QgPSBmaWJlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoKGZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyAmJiBjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcblxuICAgIGlmICgoZmliZXIuZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaWJlcik7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICggZmluaXNoZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihkZWxldGVkU3VidHJlZVJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0OyAvLyBEZWxldGlvbiBlZmZlY3RzIGZpcmUgaW4gcGFyZW50IC0+IGNoaWxkIG9yZGVyXG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgZmliZXIgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnXG5cbiAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkOyAvLyBUT0RPOiBPbmx5IHRyYXZlcnNlIHN1YnRyZWUgaWYgaXQgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnLiAoQnV0LCBpZiB3ZVxuICAgIC8vIGRvIHRoaXMsIHN0aWxsIG5lZWQgdG8gaGFuZGxlIGBkZWxldGVkVHJlZUNsZWFuVXBMZXZlbGAgY29ycmVjdGx5LilcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZShkZWxldGVkU3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgICB7XG4gICAgICAvLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSB0aGUgZW50aXJlIGRlbGV0ZWQgdHJlZSBhbmQgY2xlYW4gdXAgZmliZXIgZmllbGRzLlxuICAgICAgLy8gVGhpcyBpcyBtb3JlIGFnZ3Jlc3NpdmUgdGhhbiBpZGVhbCwgYW5kIHRoZSBsb25nIHRlcm0gZ29hbCBpcyB0byBvbmx5XG4gICAgICAvLyBoYXZlIHRvIGRldGFjaCB0aGUgZGVsZXRlZCB0cmVlIGF0IHRoZSByb290LlxuICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpO1xuXG4gICAgICBpZiAoZmliZXIgPT09IGRlbGV0ZWRTdWJ0cmVlUm9vdCkge1xuICAgICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCBjdXJyZW50Lm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFBhc3NpdmUkMSwgY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgcmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChQYXNzaXZlJDEsIGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn0gLy8gVE9ETzogUmV1c2UgcmVhcHBlYXJMYXlvdXRFZmZlY3RzIHRyYXZlcnNhbCBoZXJlP1xuXG5cbmZ1bmN0aW9uIGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2sgU3RyaWN0RWZmZWN0c01vZGUgaGVyZS5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGlmIHRoYXQgY2hlY2sgaGFzIGFscmVhZHkgcGFzc2VkLlxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaWJlcik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0TW91bnRJbkRFVihmaWJlcikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChQYXNzaXZlJDEgfCBIYXNFZmZlY3QsIGZpYmVyKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZUxheW91dEVmZmVjdFVubW91bnRJbkRFVihmaWJlcikge1xuICB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZS1jaGVjayBTdHJpY3RFZmZlY3RzTW9kZSBoZXJlLlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWQgaWYgdGhhdCBjaGVjayBoYXMgYWxyZWFkeSBwYXNzZWQuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmliZXIsIGZpYmVyLnJldHVybik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGZpYmVyLCBmaWJlci5yZXR1cm4sIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VQYXNzaXZlRWZmZWN0VW5tb3VudEluREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoUGFzc2l2ZSQxIHwgSGFzRWZmZWN0LCBmaWJlciwgZmliZXIucmV0dXJuKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmliZXIsIGZpYmVyLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgQ09NUE9ORU5UX1RZUEUgPSAwO1xudmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDE7XG52YXIgUk9MRV9UWVBFID0gMjtcbnZhciBURVNUX05BTUVfVFlQRSA9IDM7XG52YXIgVEVYVF9UWVBFID0gNDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3MnKTtcbiAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IudGV4dCcpO1xufVxudmFyIGNvbW1pdEhvb2tzID0gW107XG5mdW5jdGlvbiBvbkNvbW1pdFJvb3QkMSgpIHtcbiAge1xuICAgIGNvbW1pdEhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1pdEhvb2spIHtcbiAgICAgIHJldHVybiBjb21taXRIb29rKCk7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudEFjdFF1ZXVlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7XG5mdW5jdGlvbiBpc0xlZ2FjeUFjdEVudmlyb25tZW50KGZpYmVyKSB7XG4gIHtcbiAgICAvLyBMZWdhY3kgbW9kZS4gV2UgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mIFJlYWN0IDE3J3MgYWN0LiBJdCBhc3N1bWVzIGFuXG4gICAgLy8gYWN0IGVudmlyb25tZW50IHdoZW5ldmVyIGBqZXN0YCBpcyBkZWZpbmVkLCBidXQgeW91IGNhbiBzdGlsbCB0dXJuIG9mZlxuICAgIC8vIHNwdXJpb3VzIHdhcm5pbmdzIGJ5IHNldHRpbmcgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGV4cGxpY2l0bHlcbiAgICAvLyB0byBmYWxzZS5cbiAgICB2YXIgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsID0gLy8gJEZsb3dFeHBlY3RlZEVycm9yIOKAkyBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgZ2xvYmFsXG4gICAgdHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCAhPT0gJ3VuZGVmaW5lZCcgPyBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgOiB1bmRlZmluZWQ7IC8vICRGbG93RXhwZWN0ZWRFcnJvciAtIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IGplc3RcblxuICAgIHZhciBqZXN0SXNEZWZpbmVkID0gdHlwZW9mIGplc3QgIT09ICd1bmRlZmluZWQnO1xuICAgIHJldHVybiAgamVzdElzRGVmaW5lZCAmJiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgIT09IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAge1xuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0V4cGVjdGVkRXJyb3Ig4oCTIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IEluY2x1ZGUgbGluayB0byByZWxldmFudCBkb2N1bWVudGF0aW9uIHBhZ2UuXG4gICAgICBlcnJvcignVGhlIGN1cnJlbnQgdGVzdGluZyBlbnZpcm9ubWVudCBpcyBub3QgY29uZmlndXJlZCB0byBzdXBwb3J0ICcgKyAnYWN0KC4uLiknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsO1xuICB9XG59XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyLFxuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgICBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWU7XG52YXIgTm9Db250ZXh0ID1cbi8qICAgICAgICAgICAgICovXG4wO1xudmFyIEJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUmVuZGVyQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBDb21taXRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgICovXG40O1xudmFyIFJvb3RJblByb2dyZXNzID0gMDtcbnZhciBSb290RmF0YWxFcnJvcmVkID0gMTtcbnZhciBSb290RXJyb3JlZCA9IDI7XG52YXIgUm9vdFN1c3BlbmRlZCA9IDM7XG52YXIgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQ7XG52YXIgUm9vdENvbXBsZXRlZCA9IDU7XG52YXIgUm9vdERpZE5vdENvbXBsZXRlID0gNjsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSAoKm5vdCogYW4gaW50ZXJsZWF2ZWQgZXZlbnQpLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzOyAvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7IC8vIFRoZXNlIGFyZSBlcnJvcnMgdGhhdCB3ZSByZWNvdmVyZWQgZnJvbSB3aXRob3V0IHN1cmZhY2luZyB0aGVtIHRvIHRoZSBVSS5cbi8vIFdlIHdpbGwgbG9nIHRoZW0gb25jZSB0aGUgdHJlZSBjb21taXRzLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsOyAvLyBUaGUgbW9zdCByZWNlbnQgdGltZSB3ZSBjb21taXR0ZWQgYSBmYWxsYmFjay4gVGhpcyBsZXRzIHVzIGVuc3VyZSBhIHRyYWluXG4vLyBtb2RlbCB3aGVyZSB3ZSBkb24ndCBjb21taXQgbmV3IGxvYWRpbmcgc3RhdGVzIGluIHRvbyBxdWljayBzdWNjZXNzaW9uLlxuXG52YXIgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IDA7XG52YXIgRkFMTEJBQ0tfVEhST1RUTEVfTVMgPSA1MDA7IC8vIFRoZSBhYnNvbHV0ZSB0aW1lIGZvciB3aGVuIHdlIHNob3VsZCBzdGFydCBnaXZpbmcgdXAgb24gcmVuZGVyaW5nXG4vLyBtb3JlIGFuZCBwcmVmZXIgQ1BVIHN1c3BlbnNlIGhldXJpc3RpY3MgaW5zdGVhZC5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBJbmZpbml0eTsgLy8gSG93IGxvbmcgYSByZW5kZXIgaXMgc3VwcG9zZWQgdG8gdGFrZSBiZWZvcmUgd2Ugc3RhcnQgZm9sbG93aW5nIENQVVxuLy8gc3VzcGVuc2UgaGV1cmlzdGljcyBhbmQgb3B0IG91dCBvZiByZW5kZXJpbmcgbW9yZSBjb250ZW50LlxuXG52YXIgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDA7XG52YXIgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc2V0UmVuZGVyVGltZXIoKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3coKSArIFJFTkRFUl9USU1FT1VUX01TO1xufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZTtcbn1cbnZhciBoYXNVbmNhdWdodEVycm9yID0gZmFsc2U7XG52YXIgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbnZhciBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7IC8vIE9ubHkgdXNlZCB3aGVuIGVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlU2NoZWR1bGVkSG9vayBpcyB0cnVlO1xudmFyIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xudmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gTm9MYW5lcztcbnZhciBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyA9IFtdO1xudmFyIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsOyAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG52YXIgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7IC8vIElmIHR3byB1cGRhdGVzIGFyZSBzY2hlZHVsZWQgd2l0aGluIHRoZSBzYW1lIGV2ZW50LCB3ZSBzaG91bGQgdHJlYXQgdGhlaXJcbi8vIGV2ZW50IHRpbWVzIGFzIHNpbXVsdGFuZW91cywgZXZlbiBpZiB0aGUgYWN0dWFsIGNsb2NrIHRpbWUgaGFzIGFkdmFuY2VkXG4vLyBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNhbGwuXG5cbnZhciBjdXJyZW50RXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG52YXIgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBOb0xhbmVzO1xudmFyIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O1xufVxuZnVuY3Rpb24gcmVxdWVzdEV2ZW50VGltZSgpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBSZWFjdCwgc28gaXQncyBmaW5lIHRvIHJlYWQgdGhlIGFjdHVhbCB0aW1lLlxuICAgIHJldHVybiBub3coKTtcbiAgfSAvLyBXZSdyZSBub3QgaW5zaWRlIFJlYWN0LCBzbyB3ZSBtYXkgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXIgZXZlbnQuXG5cblxuICBpZiAoY3VycmVudEV2ZW50VGltZSAhPT0gTm9UaW1lc3RhbXApIHtcbiAgICAvLyBVc2UgdGhlIHNhbWUgc3RhcnQgdGltZSBmb3IgYWxsIHVwZGF0ZXMgdW50aWwgd2UgZW50ZXIgUmVhY3QgYWdhaW4uXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG4gIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHNpbmNlIFJlYWN0IHlpZWxkZWQuIENvbXB1dGUgYSBuZXcgc3RhcnQgdGltZS5cblxuXG4gIGN1cnJlbnRFdmVudFRpbWUgPSBub3coKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICggKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFRoZXNlIGFyZSBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuIFRoZVxuICAgIC8vIG9sZCBiZWhhdmlvciBpcyB0byBnaXZlIHRoaXMgdGhlIHNhbWUgXCJ0aHJlYWRcIiAobGFuZXMpIGFzXG4gICAgLy8gd2hhdGV2ZXIgaXMgY3VycmVudGx5IHJlbmRlcmluZy4gU28gaWYgeW91IGNhbGwgYHNldFN0YXRlYCBvbiBhIGNvbXBvbmVudFxuICAgIC8vIHRoYXQgaGFwcGVucyBsYXRlciBpbiB0aGUgc2FtZSByZW5kZXIsIGl0IHdpbGwgZmx1c2guIElkZWFsbHksIHdlIHdhbnQgdG9cbiAgICAvLyByZW1vdmUgdGhlIHNwZWNpYWwgY2FzZSBhbmQgdHJlYXQgdGhlbSBhcyBpZiB0aGV5IGNhbWUgZnJvbSBhblxuICAgIC8vIGludGVybGVhdmVkIGV2ZW50LiBSZWdhcmRsZXNzLCB0aGlzIHBhdHRlcm4gaXMgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgb25seSBhIGZhbGxiYWNrLiBUaGUgZmxhZyBvbmx5IGV4aXN0cyB1bnRpbCB3ZSBjYW4gcm9sbFxuICAgIC8vIG91dCB0aGUgc2V0U3RhdGUgd2FybmluZywgc2luY2UgZXhpc3RpbmcgY29kZSBtaWdodCBhY2NpZGVudGFsbHkgcmVseSBvblxuICAgIC8vIHRoZSBjdXJyZW50IGJlaGF2aW9yLlxuICAgIHJldHVybiBwaWNrQXJiaXRyYXJ5TGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgaXNUcmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkgIT09IE5vVHJhbnNpdGlvbjtcblxuICBpZiAoaXNUcmFuc2l0aW9uKSB7XG4gICAgaWYgKCBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO1xuXG4gICAgICBpZiAoIXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpO1xuICAgIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gICAgLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZVxuICAgIC8vIGlucHV0cyB0byB0aGUgYWxnb3JpdGhtIG11c3QgYmUgdGhlIHNhbWUuXG4gICAgLy9cbiAgICAvLyBUaGUgdHJpY2sgd2UgdXNlIGlzIHRvIGNhY2hlIHRoZSBmaXJzdCBvZiBlYWNoIG9mIHRoZXNlIGlucHV0cyB3aXRoaW4gYW5cbiAgICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpc1xuICAgIC8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cblxuXG4gICAgaWYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIEFsbCB0cmFuc2l0aW9ucyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgYXJlIGFzc2lnbmVkIHRoZSBzYW1lIGxhbmUuXG4gICAgICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO1xuICB9IC8vIFVwZGF0ZXMgb3JpZ2luYXRpbmcgaW5zaWRlIGNlcnRhaW4gUmVhY3QgbWV0aG9kcywgbGlrZSBmbHVzaFN5bmMsIGhhdmVcbiAgLy8gdGhlaXIgcHJpb3JpdHkgc2V0IGJ5IHRyYWNraW5nIGl0IHdpdGggYSBjb250ZXh0IHZhcmlhYmxlLlxuICAvL1xuICAvLyBUaGUgb3BhcXVlIHR5cGUgcmV0dXJuZWQgYnkgdGhlIGhvc3QgY29uZmlnIGlzIGludGVybmFsbHkgYSBsYW5lLCBzbyB3ZSBjYW5cbiAgLy8gdXNlIHRoYXQgZGlyZWN0bHkuXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0eXBlIGNvbnZlcnNpb24gdG8gdGhlIGV2ZW50IHByaW9yaXR5IG1vZHVsZS5cblxuXG4gIHZhciB1cGRhdGVMYW5lID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgaWYgKHVwZGF0ZUxhbmUgIT09IE5vTGFuZSkge1xuICAgIHJldHVybiB1cGRhdGVMYW5lO1xuICB9IC8vIFRoaXMgdXBkYXRlIG9yaWdpbmF0ZWQgb3V0c2lkZSBSZWFjdC4gQXNrIHRoZSBob3N0IGVudmlyb25tZW50IGZvciBhblxuICAvLyBhcHByb3ByaWF0ZSBwcmlvcml0eSwgYmFzZWQgb24gdGhlIHR5cGUgb2YgZXZlbnQuXG4gIC8vXG4gIC8vIFRoZSBvcGFxdWUgdHlwZSByZXR1cm5lZCBieSB0aGUgaG9zdCBjb25maWcgaXMgaW50ZXJuYWxseSBhIGxhbmUsIHNvIHdlIGNhblxuICAvLyB1c2UgdGhhdCBkaXJlY3RseS5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHR5cGUgY29udmVyc2lvbiB0byB0aGUgZXZlbnQgcHJpb3JpdHkgbW9kdWxlLlxuXG5cbiAgdmFyIGV2ZW50TGFuZSA9IGdldEN1cnJlbnRFdmVudFByaW9yaXR5KCk7XG4gIHJldHVybiBldmVudExhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfVxuXG4gIHJldHVybiBjbGFpbU5leHRSZXRyeUxhbmUoKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG5cbiAge1xuICAgIGlmIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QpIHtcbiAgICAgIGVycm9yKCd1c2VJbnNlcnRpb25FZmZlY3QgbXVzdCBub3Qgc2NoZWR1bGUgdXBkYXRlcy4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcblxuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmIChpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgIH1cbiAgfSAvLyBNYXJrIHRoYXQgdGhlIHJvb3QgaGFzIGEgcGVuZGluZyB1cGRhdGUuXG5cblxuICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSwgZXZlbnRUaW1lKTtcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9MYW5lcyAmJiByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBUaGlzIHVwZGF0ZSB3YXMgZGlzcGF0Y2hlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpcyBpcyBhIG1pc3Rha2VcbiAgICAvLyBpZiB0aGUgdXBkYXRlIG9yaWdpbmF0ZXMgZnJvbSB1c2VyIHNwYWNlICh3aXRoIHRoZSBleGNlcHRpb24gb2YgbG9jYWxcbiAgICAvLyBob29rIHVwZGF0ZXMsIHdoaWNoIGFyZSBoYW5kbGVkIGRpZmZlcmVudGx5IGFuZCBkb24ndCByZWFjaCB0aGlzXG4gICAgLy8gZnVuY3Rpb24pLCBidXQgdGhlcmUgYXJlIHNvbWUgaW50ZXJuYWwgUmVhY3QgZmVhdHVyZXMgdGhhdCB1c2UgdGhpcyBhc1xuICAgIC8vIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCwgbGlrZSBzZWxlY3RpdmUgaHlkcmF0aW9uLlxuICAgIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKTsgLy8gVHJhY2sgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2VcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgbm9ybWFsIHVwZGF0ZSwgc2NoZWR1bGVkIGZyb20gb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLiBGb3JcbiAgICAvLyBleGFtcGxlLCBkdXJpbmcgYW4gaW5wdXQgZXZlbnQuXG4gICAge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKTtcblxuICAgIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAgIC8vIFRPRE86IENvbnNvbGlkYXRlIHdpdGggYGlzSW50ZXJsZWF2ZWRVcGRhdGVgIGNoZWNrXG4gICAgICAvLyBSZWNlaXZlZCBhbiB1cGRhdGUgdG8gYSB0cmVlIHRoYXQncyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZy4gTWFya1xuICAgICAgLy8gdGhhdCB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgdXBkYXRlIHdvcmsgb24gdGhpcyByb290LiBVbmxlc3MgdGhlXG4gICAgICAvLyBgZGVmZXJSZW5kZXJQaGFzZVVwZGF0ZVRvTmV4dEJhdGNoYCBmbGFnIGlzIG9mZiBhbmQgdGhpcyBpcyBhIHJlbmRlclxuICAgICAgLy8gcGhhc2UgdXBkYXRlLiBJbiB0aGF0IGNhc2UsIHdlIGRvbid0IHRyZWF0IHJlbmRlciBwaGFzZSB1cGRhdGVzIGFzIGlmXG4gICAgICAvLyB0aGV5IHdlcmUgaW50ZXJsZWF2ZWQsIGZvciBiYWNrd2FyZHMgY29tcGF0IHJlYXNvbnMuXG4gICAgICBpZiAoIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsIGxhbmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgICAgICAvLyBUaGUgcm9vdCBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHdoaWNoIG1lYW5zIHRoaXMgcmVuZGVyXG4gICAgICAgIC8vIGRlZmluaXRlbHkgd29uJ3QgZmluaXNoLiBTaW5jZSB3ZSBoYXZlIGEgbmV3IHVwZGF0ZSwgbGV0J3MgbWFyayBpdCBhc1xuICAgICAgICAvLyBzdXNwZW5kZWQgbm93LCByaWdodCBiZWZvcmUgbWFya2luZyB0aGUgaW5jb21pbmcgdXBkYXRlLiBUaGlzIGhhcyB0aGVcbiAgICAgICAgLy8gZWZmZWN0IG9mIGludGVycnVwdGluZyB0aGUgY3VycmVudCByZW5kZXIgYW5kIHN3aXRjaGluZyB0byB0aGUgdXBkYXRlLlxuICAgICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgdGhpcyBkb2Vzbid0IG92ZXJyaWRlIHBpbmdzIHRoYXQgaGFwcGVuIHdoaWxlIHdlJ3ZlXG4gICAgICAgIC8vIGFscmVhZHkgc3RhcnRlZCByZW5kZXJpbmcuXG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuXG4gICAgaWYgKGxhbmUgPT09IFN5bmNMYW5lICYmIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlICYmIC8vIFRyZWF0IGBhY3RgIGFzIGlmIGl0J3MgaW5zaWRlIGBiYXRjaGVkVXBkYXRlc2AsIGV2ZW4gaW4gbGVnYWN5IG1vZGUuXG4gICAgISggUmVhY3RDdXJyZW50QWN0UXVldWUkMS5pc0JhdGNoaW5nTGVnYWN5KSkge1xuICAgICAgLy8gRmx1c2ggdGhlIHN5bmNocm9ub3VzIHdvcmsgbm93LCB1bmxlc3Mgd2UncmUgYWxyZWFkeSB3b3JraW5nIG9yIGluc2lkZVxuICAgICAgLy8gYSBiYXRjaC4gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGluc2lkZSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgaW5zdGVhZCBvZlxuICAgICAgLy8gc2NoZWR1bGVDYWxsYmFja0ZvckZpYmVyIHRvIHByZXNlcnZlIHRoZSBhYmlsaXR5IHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgIC8vIHdpdGhvdXQgaW1tZWRpYXRlbHkgZmx1c2hpbmcgaXQuIFdlIG9ubHkgZG8gdGhpcyBmb3IgdXNlci1pbml0aWF0ZWRcbiAgICAgIC8vIHVwZGF0ZXMsIHRvIHByZXNlcnZlIGhpc3RvcmljYWwgYmVoYXZpb3Igb2YgbGVnYWN5IG1vZGUuXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja3NPbmx5SW5MZWdhY3lNb2RlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUluaXRpYWxIeWRyYXRpb25PblJvb3Qocm9vdCwgbGFuZSwgZXZlbnRUaW1lKSB7XG4gIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGZvcmsgb2Ygc2NoZWR1bGVVcGRhdGVPbkZpYmVyIHRoYXQgaXMgb25seSB1c2VkIHRvXG4gIC8vIHNjaGVkdWxlIHRoZSBpbml0aWFsIGh5ZHJhdGlvbiBvZiBhIHJvb3QgdGhhdCBoYXMganVzdCBiZWVuIGNyZWF0ZWQuIE1vc3RcbiAgLy8gb2YgdGhlIHN0dWZmIGluIHNjaGVkdWxlVXBkYXRlT25GaWJlciBjYW4gYmUgc2tpcHBlZC5cbiAgLy9cbiAgLy8gVGhlIG1haW4gcmVhc29uIGZvciB0aGlzIHNlcGFyYXRlIHBhdGgsIHRob3VnaCwgaXMgdG8gZGlzdGluZ3Vpc2ggdGhlXG4gIC8vIGluaXRpYWwgY2hpbGRyZW4gZnJvbSBzdWJzZXF1ZW50IHVwZGF0ZXMuIEluIGZ1bGx5IGNsaWVudC1yZW5kZXJlZCByb290c1xuICAvLyAoY3JlYXRlUm9vdCBpbnN0ZWFkIG9mIGh5ZHJhdGVSb290KSwgYWxsIHRvcC1sZXZlbCByZW5kZXJzIGFyZSBtb2RlbGVkIGFzXG4gIC8vIHVwZGF0ZXMsIGJ1dCBoeWRyYXRpb24gcm9vdHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgbXVzdFxuICAvLyBtYXRjaCB3aGF0IHdhcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyLlxuICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgY3VycmVudC5sYW5lcyA9IGxhbmU7XG4gIG1hcmtSb290VXBkYXRlZChyb290LCBsYW5lLCBldmVudFRpbWUpO1xuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbn0gLy8gVGhpcyBpcyBzcGxpdCBpbnRvIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gd2UgY2FuIG1hcmsgYSBmaWJlciB3aXRoIHBlbmRpbmdcbi8vIHdvcmsgd2l0aG91dCB0cmVhdGluZyBpdCBhcyBhIHR5cGljYWwgdXBkYXRlIHRoYXQgb3JpZ2luYXRlcyBmcm9tIGFuIGV2ZW50O1xuLy8gZS5nLiByZXRyeWluZyBhIFN1c3BlbnNlIGJvdW5kYXJ5IGlzbid0IGFuIHVwZGF0ZSwgYnV0IGl0IGRvZXMgc2NoZWR1bGUgd29ya1xuLy8gb24gYSBmaWJlci5cblxuZnVuY3Rpb24gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIGxhbmUpIHtcbiAgLy8gVXBkYXRlIHRoZSBzb3VyY2UgZmliZXIncyBsYW5lc1xuICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIGxhbmUpO1xuICB2YXIgYWx0ZXJuYXRlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgbGFuZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCAmJiAoc291cmNlRmliZXIuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgIH1cbiAgfSAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIHRoZSBjaGlsZCBsYW5lcy5cblxuXG4gIHZhciBub2RlID0gc291cmNlRmliZXI7XG4gIHZhciBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudC5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnQuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKChwYXJlbnQuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgIHJldHVybiByb290O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJsZWF2ZWRVcGRhdGUoZmliZXIsIGxhbmUpIHtcbiAgcmV0dXJuICgvLyBUT0RPOiBPcHRpbWl6ZSBzbGlnaHRseSBieSBjb21wYXJpbmcgdG8gcm9vdCB0aGF0IGZpYmVyIGJlbG9uZ3MgdG8uXG4gICAgLy8gUmVxdWlyZXMgc29tZSByZWZhY3RvcmluZy4gTm90IGEgYmlnIGRlYWwgdGhvdWdoIHNpbmNlIGl0J3MgcmFyZSBmb3JcbiAgICAvLyBjb25jdXJyZW50IGFwcHMgdG8gaGF2ZSBtb3JlIHRoYW4gYSBzaW5nbGUgcm9vdC5cbiAgICAod29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsIHx8IC8vIElmIHRoZSBpbnRlcmxlYXZlZCB1cGRhdGVzIHF1ZXVlIGhhc24ndCBiZWVuIGNsZWFyZWQgeWV0LCB0aGVuXG4gICAgLy8gd2Ugc2hvdWxkIHRyZWF0IHRoaXMgYXMgYW4gaW50ZXJsZWF2ZWQgdXBkYXRlLCB0b28uIFRoaXMgaXMgYWxzbyBhXG4gICAgLy8gZGVmZW5zaXZlIGNvZGluZyBtZWFzdXJlIGluIGNhc2UgYSBuZXcgdXBkYXRlIGNvbWVzIGluIGJldHdlZW4gd2hlblxuICAgIC8vIHJlbmRlcmluZyBoYXMgZmluaXNoZWQgYW5kIHdoZW4gdGhlIGludGVybGVhdmVkIHVwZGF0ZXMgYXJlIHRyYW5zZmVycmVkXG4gICAgLy8gdG8gdGhlIG1haW4gcXVldWUuXG4gICAgaGFzSW50ZXJsZWF2ZWRVcGRhdGVzKCkpICYmIChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpICE9PSBOb01vZGUgJiYgKCAvLyBJZiB0aGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZSAoaS5lLiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyksXG4gICAgLy8gdGhlbiBkb24ndCB0cmVhdCB0aGlzIGFzIGFuIGludGVybGVhdmVkIHVwZGF0ZS4gVGhpcyBwYXR0ZXJuIGlzXG4gICAgLy8gYWNjb21wYW5pZWQgYnkgYSB3YXJuaW5nIGJ1dCB3ZSBoYXZlbid0IGZ1bGx5IGRlcHJlY2F0ZWQgaXQgeWV0LiBXZSBjYW5cbiAgICAvLyByZW1vdmUgb25jZSB0aGUgZGVmZXJSZW5kZXJQaGFzZVVwZGF0ZVRvTmV4dEJhdGNoIGZsYWcgaXMgZW5hYmxlZC5cbiAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KVxuICApO1xufSAvLyBVc2UgdGhpcyBmdW5jdGlvbiB0byBzY2hlZHVsZSBhIHRhc2sgZm9yIGEgcm9vdC4gVGhlcmUncyBvbmx5IG9uZSB0YXNrIHBlclxuLy8gcm9vdDsgaWYgYSB0YXNrIHdhcyBhbHJlYWR5IHNjaGVkdWxlZCwgd2UnbGwgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBwcmlvcml0eVxuLy8gb2YgdGhlIGV4aXN0aW5nIHRhc2sgaXMgdGhlIHNhbWUgYXMgdGhlIHByaW9yaXR5IG9mIHRoZSBuZXh0IGxldmVsIHRoYXQgdGhlXG4vLyByb290IGhhcyB3b3JrIG9uLiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSB1cGRhdGUsIGFuZCByaWdodCBiZWZvcmVcbi8vIGV4aXRpbmcgYSB0YXNrLlxuXG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7IC8vIENoZWNrIGlmIGFueSBsYW5lcyBhcmUgYmVpbmcgc3RhcnZlZCBieSBvdGhlciB3b3JrLiBJZiBzbywgbWFyayB0aGVtIGFzXG4gIC8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG5cbiAgbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSk7IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG5cbiAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgICByZXR1cm47XG4gIH0gLy8gV2UgdXNlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGxhbmUgdG8gcmVwcmVzZW50IHRoZSBwcmlvcml0eSBvZiB0aGUgY2FsbGJhY2suXG5cblxuICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB0YXNrLiBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSBpdC5cblxuICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuXG4gIGlmIChleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPT09IG5ld0NhbGxiYWNrUHJpb3JpdHkgJiYgLy8gU3BlY2lhbCBjYXNlIHJlbGF0ZWQgdG8gYGFjdGAuIElmIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkIHRhc2sgaXMgYVxuICAvLyBTY2hlZHVsZXIgdGFzaywgcmF0aGVyIHRoYW4gYW4gYGFjdGAgdGFzaywgY2FuY2VsIGl0IGFuZCByZS1zY2hlZHVsZWRcbiAgLy8gb24gdGhlIGBhY3RgIHF1ZXVlLlxuICAhKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmN1cnJlbnQgIT09IG51bGwgJiYgZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUpKSB7XG4gICAge1xuICAgICAgLy8gSWYgd2UncmUgZ29pbmcgdG8gcmUtdXNlIGFuIGV4aXN0aW5nIHRhc2ssIGl0IG5lZWRzIHRvIGV4aXN0LlxuICAgICAgLy8gQXNzdW1lIHRoYXQgZGlzY3JldGUgdXBkYXRlIG1pY3JvdGFza3MgYXJlIG5vbi1jYW5jZWxsYWJsZSBhbmQgbnVsbC5cbiAgICAgIC8vIFRPRE86IFRlbXBvcmFyeSB1bnRpbCB3ZSBjb25maXJtIHRoaXMgd2FybmluZyBpcyBub3QgZmlyZWQuXG4gICAgICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgPT0gbnVsbCAmJiBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgIT09IFN5bmNMYW5lKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCBzY2hlZHVsZWQgY2FsbGJhY2sgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgcHJpb3JpdHkgaGFzbid0IGNoYW5nZWQuIFdlIGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgdGFzay4gRXhpdC5cblxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9IG51bGwpIHtcbiAgICAvLyBDYW5jZWwgdGhlIGV4aXN0aW5nIGNhbGxiYWNrLiBXZSdsbCBzY2hlZHVsZSBhIG5ldyBvbmUgYmVsb3cuXG4gICAgY2FuY2VsQ2FsbGJhY2skMShleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gIH0gLy8gU2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG5cblxuICB2YXIgbmV3Q2FsbGJhY2tOb2RlO1xuXG4gIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBTeW5jTGFuZSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU3luYyBSZWFjdCBjYWxsYmFja3MgYXJlIHNjaGVkdWxlZCBvbiBhIHNwZWNpYWxcbiAgICAvLyBpbnRlcm5hbCBxdWV1ZVxuICAgIGlmIChyb290LnRhZyA9PT0gTGVnYWN5Um9vdCkge1xuICAgICAgaWYgKCBSZWFjdEN1cnJlbnRBY3RRdWV1ZSQxLmlzQmF0Y2hpbmdMZWdhY3kgIT09IG51bGwpIHtcbiAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5kaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlTGVnYWN5U3luY0NhbGxiYWNrKHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVTeW5jQ2FsbGJhY2socGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBxdWV1ZSBpbiBhIG1pY3JvdGFzay5cbiAgICAgIGlmICggUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEluc2lkZSBgYWN0YCwgdXNlIG91ciBpbnRlcm5hbCBgYWN0YCBxdWV1ZSBzbyB0aGF0IHRoZXNlIGdldCBmbHVzaGVkXG4gICAgICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc2NvcGUgZXZlbiB3aGVuIHVzaW5nIHRoZSBzeW5jIHZlcnNpb25cbiAgICAgICAgLy8gb2YgYGFjdGAuXG4gICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudC5wdXNoKGZsdXNoU3luY0NhbGxiYWNrcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gSW4gU2FmYXJpLCBhcHBlbmRpbmcgYW4gaWZyYW1lIGZvcmNlcyBtaWNyb3Rhc2tzIHRvIHJ1bi5cbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIyNDU5XG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBydW5uaW5nIGNhbGxiYWNrcyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlclxuICAgICAgICAgIC8vIG9yIGNvbW1pdCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QgdGhhdC5cbiAgICAgICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgICAgICAvLyBJdCdzIG9ubHkgc2FmZSB0byBkbyB0aGlzIGNvbmRpdGlvbmFsbHkgYmVjYXVzZSB3ZSBhbHdheXNcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBwZW5kaW5nIHdvcmsgYmVmb3JlIHdlIGV4aXQgdGhlIHRhc2suXG4gICAgICAgICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld0NhbGxiYWNrTm9kZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVkdWxlclByaW9yaXR5TGV2ZWw7XG5cbiAgICBzd2l0Y2ggKGxhbmVzVG9FdmVudFByaW9yaXR5KG5leHRMYW5lcykpIHtcbiAgICAgIGNhc2UgRGlzY3JldGVFdmVudFByaW9yaXR5OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERlZmF1bHRFdmVudFByaW9yaXR5OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gSWRsZVByaW9yaXR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrJDEoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCwgcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICB9XG5cbiAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gbmV3Q2FsbGJhY2tQcmlvcml0eTtcbiAgcm9vdC5jYWxsYmFja05vZGUgPSBuZXdDYWxsYmFja05vZGU7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBldmVyeSBjb25jdXJyZW50IHRhc2ssIGkuZS4gYW55dGhpbmcgdGhhdFxuLy8gZ29lcyB0aHJvdWdoIFNjaGVkdWxlci5cblxuXG5mdW5jdGlvbiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3Qocm9vdCwgZGlkVGltZW91dCkge1xuICB7XG4gICAgcmVzZXROZXN0ZWRVcGRhdGVGbGFnKCk7XG4gIH0gLy8gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBhIFJlYWN0IGV2ZW50LCB3ZSBjYW4gY2xlYXIgdGhlIGN1cnJlbnRcbiAgLy8gZXZlbnQgdGltZS4gVGhlIG5leHQgdXBkYXRlIHdpbGwgY29tcHV0ZSBhIG5ldyBldmVudCB0aW1lLlxuXG5cbiAgY3VycmVudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuICBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IE5vTGFuZXM7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7XG4gIH0gLy8gRmx1c2ggYW55IHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGJlZm9yZSBkZWNpZGluZyB3aGljaCBsYW5lcyB0byB3b3JrIG9uLFxuICAvLyBpbiBjYXNlIHRoZXkgc2NoZWR1bGUgYWRkaXRpb25hbCB3b3JrLlxuXG5cbiAgdmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG4gIHZhciBkaWRGbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXG4gIGlmIChkaWRGbHVzaFBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoZSBwYXNzaXZlIGVmZmVjdCBwaGFzZSBtYXkgaGF2ZSBjYW5jZWxlZCB0aGUgY3VycmVudCB0YXNrLlxuICAgIC8vIENoZWNrIGlmIHRoZSB0YXNrIG5vZGUgZm9yIHRoaXMgcm9vdCB3YXMgY2hhbmdlZC5cbiAgICBpZiAocm9vdC5jYWxsYmFja05vZGUgIT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCB0YXNrIHdhcyBjYW5jZWxlZC4gRXhpdC4gV2UgZG9uJ3QgbmVlZCB0byBjYWxsXG4gICAgICAvLyBgZW5zdXJlUm9vdElzU2NoZWR1bGVkYCBiZWNhdXNlIHRoZSBjaGVjayBhYm92ZSBpbXBsaWVzIGVpdGhlciB0aGF0XG4gICAgICAvLyB0aGVyZSdzIGEgbmV3IHRhc2ssIG9yIHRoYXQgdGhlcmUncyBubyByZW1haW5pbmcgd29yayBvbiB0aGlzIHJvb3QuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IGxhbmVzIHRvIHdvcmsgb24sIHVzaW5nIHRoZSBmaWVsZHMgc3RvcmVkXG4gIC8vIG9uIHRoZSByb290LlxuXG5cbiAgdmFyIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIDogTm9MYW5lcyk7XG5cbiAgaWYgKGxhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gVGhpcyBpcyBuZXZlciBleHBlY3RlZCB0byBoYXBwZW4uXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gV2UgZGlzYWJsZSB0aW1lLXNsaWNpbmcgaW4gc29tZSBjYXNlczogaWYgdGhlIHdvcmsgaGFzIGJlZW4gQ1BVLWJvdW5kXG4gIC8vIGZvciB0b28gbG9uZyAoXCJleHBpcmVkXCIgd29yaywgdG8gcHJldmVudCBzdGFydmF0aW9uKSwgb3Igd2UncmUgaW5cbiAgLy8gc3luYy11cGRhdGVzLWJ5LWRlZmF1bHQgbW9kZS5cbiAgLy8gVE9ETzogV2Ugb25seSBjaGVjayBgZGlkVGltZW91dGAgZGVmZW5zaXZlbHksIHRvIGFjY291bnQgZm9yIGEgU2NoZWR1bGVyXG4gIC8vIGJ1ZyB3ZSdyZSBzdGlsbCBpbnZlc3RpZ2F0aW5nLiBPbmNlIHRoZSBidWcgaW4gU2NoZWR1bGVyIGlzIGZpeGVkLFxuICAvLyB3ZSBjYW4gcmVtb3ZlIHRoaXMsIHNpbmNlIHdlIHRyYWNrIGV4cGlyYXRpb24gb3Vyc2VsdmVzLlxuXG5cbiAgdmFyIHNob3VsZFRpbWVTbGljZSA9ICFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCBsYW5lcykgJiYgIWluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCwgbGFuZXMpICYmICggIWRpZFRpbWVvdXQpO1xuICB2YXIgZXhpdFN0YXR1cyA9IHNob3VsZFRpbWVTbGljZSA/IHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSA6IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgIC8vIElmIHNvbWV0aGluZyB0aHJldyBhbiBlcnJvciwgdHJ5IHJlbmRlcmluZyBvbmUgbW9yZSB0aW1lLiBXZSdsbFxuICAgICAgLy8gcmVuZGVyIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsXG4gICAgICAvLyBpbmNsdWRlcyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXJcbiAgICAgIC8vIHRoZSBzZWNvbmQgYXR0ZW1wdCwgd2UnbGwgZ2l2ZSB1cCBhbmQgY29tbWl0IHRoZSByZXN1bHRpbmcgdHJlZS5cbiAgICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuICAgICAgaWYgKGVycm9yUmV0cnlMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBsYW5lcyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgIHZhciBmYXRhbEVycm9yID0gd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtcbiAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuICAgICAgdGhyb3cgZmF0YWxFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKSB7XG4gICAgICAvLyBUaGUgcmVuZGVyIHVud291bmQgd2l0aG91dCBjb21wbGV0aW5nIHRoZSB0cmVlLiBUaGlzIGhhcHBlbnMgaW4gc3BlY2lhbFxuICAgICAgLy8gY2FzZXMgd2hlcmUgbmVlZCB0byBleGl0IHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHByb2R1Y2luZyBhXG4gICAgICAvLyBjb25zaXN0ZW50IHRyZWUgb3IgY29tbWl0dGluZy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBkdXJpbmcgYSBjb25jdXJyZW50IHJlbmRlciwgbm90IGEgZGlzY3JldGUgb3JcbiAgICAgIC8vIHN5bmNocm9ub3VzIHVwZGF0ZS4gV2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBjaGVja2VkIGZvciB0aGlzIHdoZW4gd2VcbiAgICAgIC8vIHVud291bmQgdGhlIHN0YWNrLlxuICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZW5kZXIgY29tcGxldGVkLlxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyByZW5kZXIgbWF5IGhhdmUgeWllbGRlZCB0byBhIGNvbmN1cnJlbnQgZXZlbnQsIGFuZCBpZiBzbyxcbiAgICAgIC8vIGNvbmZpcm0gdGhhdCBhbnkgbmV3bHkgcmVuZGVyZWQgc3RvcmVzIGFyZSBjb25zaXN0ZW50LlxuICAgICAgLy8gVE9ETzogSXQncyBwb3NzaWJsZSB0aGF0IGV2ZW4gYSBjb25jdXJyZW50IHJlbmRlciBtYXkgbmV2ZXIgaGF2ZSB5aWVsZGVkXG4gICAgICAvLyB0byB0aGUgbWFpbiB0aHJlYWQsIGlmIGl0IHdhcyBmYXN0IGVub3VnaCwgb3IgaWYgaXQgZXhwaXJlZC4gV2UgY291bGRcbiAgICAgIC8vIHNraXAgdGhlIGNvbnNpc3RlbmN5IGNoZWNrIGluIHRoYXQgY2FzZSwgdG9vLlxuICAgICAgdmFyIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgbGFuZXMpO1xuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChyZW5kZXJXYXNDb25jdXJyZW50ICYmICFpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSkge1xuICAgICAgICAvLyBBIHN0b3JlIHdhcyBtdXRhdGVkIGluIGFuIGludGVybGVhdmVkIGV2ZW50LiBSZW5kZXIgYWdhaW4sXG4gICAgICAgIC8vIHN5bmNocm9ub3VzbHksIHRvIGJsb2NrIGZ1cnRoZXIgbXV0YXRpb25zLlxuICAgICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpOyAvLyBXZSBuZWVkIHRvIGNoZWNrIGFnYWluIGlmIHNvbWV0aGluZyB0aHJld1xuXG4gICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgIHZhciBfZXJyb3JSZXRyeUxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICAgICAgICBpZiAoX2Vycm9yUmV0cnlMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgICAgbGFuZXMgPSBfZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIF9lcnJvclJldHJ5TGFuZXMpOyAvLyBXZSBhc3N1bWUgdGhlIHRyZWUgaXMgbm93IGNvbnNpc3RlbnQgYmVjYXVzZSB3ZSBkaWRuJ3QgeWllbGQgdG8gYW55XG4gICAgICAgICAgICAvLyBjb25jdXJyZW50IGV2ZW50cy5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgICAgICAgIHZhciBfZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICAgICAgICB0aHJvdyBfZmF0YWxFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG4gICAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcblxuICBpZiAocm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgLy8gVGhlIHRhc2sgbm9kZSBzY2hlZHVsZWQgZm9yIHRoaXMgcm9vdCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzXG4gICAgLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cbiAgICByZXR1cm4gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgZXJyb3JSZXRyeUxhbmVzKSB7XG4gIC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sIGRpc2NhcmQgc2VydmVyIHJlc3BvbnNlIGFuZCBmYWxsXG4gIC8vIGJhY2sgdG8gY2xpZW50IHNpZGUgcmVuZGVyLlxuICAvLyBCZWZvcmUgcmVuZGVyaW5nIGFnYWluLCBzYXZlIHRoZSBlcnJvcnMgZnJvbSB0aGUgcHJldmlvdXMgYXR0ZW1wdC5cbiAgdmFyIGVycm9yc0Zyb21GaXJzdEF0dGVtcHQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuXG4gIGlmIChpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKSB7XG4gICAgLy8gVGhlIHNoZWxsIGZhaWxlZCB0byBoeWRyYXRlLiBTZXQgYSBmbGFnIHRvIGZvcmNlIGEgY2xpZW50IHJlbmRlcmluZ1xuICAgIC8vIGR1cmluZyB0aGUgbmV4dCBhdHRlbXB0LiBUbyBkbyB0aGlzLCB3ZSBjYWxsIHByZXBhcmVGcmVzaFN0YWNrIG5vd1xuICAgIC8vIHRvIGNyZWF0ZSB0aGUgcm9vdCB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGlzIGlzIGEgYml0IHdlaXJkIGluIHRlcm1zXG4gICAgLy8gb2YgZmFjdG9yaW5nLCBiZWNhdXNlIGl0IHJlbGllcyBvbiByZW5kZXJSb290U3luYyBub3QgY2FsbGluZ1xuICAgIC8vIHByZXBhcmVGcmVzaFN0YWNrIGFnYWluIGluIHRoZSBjYWxsIGJlbG93LCB3aGljaCBoYXBwZW5zIGJlY2F1c2UgdGhlXG4gICAgLy8gcm9vdCBhbmQgbGFuZXMgaGF2ZW4ndCBjaGFuZ2VkLlxuICAgIC8vXG4gICAgLy8gVE9ETzogSSB0aGluayB3aGF0IHdlIHNob3VsZCBkbyBpcyBzZXQgRm9yY2VDbGllbnRSZW5kZXIgaW5zaWRlXG4gICAgLy8gdGhyb3dFeGNlcHRpb24sIGxpa2Ugd2UgZG8gZm9yIG5lc3RlZCBTdXNwZW5zZSBib3VuZGFyaWVzLiBUaGUgcmVhc29uXG4gICAgLy8gaXQncyBoZXJlIGluc3RlYWQgaXMgc28gd2UgY2FuIHN3aXRjaCB0byB0aGUgc3luY2hyb25vdXMgd29yayBsb29wLCB0b28uXG4gICAgLy8gU29tZXRoaW5nIHRvIGNvbnNpZGVyIGZvciBhIGZ1dHVyZSByZWZhY3Rvci5cbiAgICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICByb290V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXI7XG5cbiAgICB7XG4gICAgICBlcnJvckh5ZHJhdGluZ0NvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcblxuICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEVycm9yZWQpIHtcbiAgICAvLyBTdWNjZXNzZnVsbHkgZmluaXNoZWQgcmVuZGVyaW5nIG9uIHJldHJ5XG4gICAgLy8gVGhlIGVycm9ycyBmcm9tIHRoZSBmYWlsZWQgZmlyc3QgYXR0ZW1wdCBoYXZlIGJlZW4gcmVjb3ZlcmVkLiBBZGRcbiAgICAvLyB0aGVtIHRvIHRoZSBjb2xsZWN0aW9uIG9mIHJlY292ZXJhYmxlIGVycm9ycy4gV2UnbGwgbG9nIHRoZW0gaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlLlxuICAgIHZhciBlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCA9IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdDsgLy8gVGhlIGVycm9ycyBmcm9tIHRoZSBzZWNvbmQgYXR0ZW1wdCBzaG91bGQgYmUgcXVldWVkIGFmdGVyIHRoZSBlcnJvcnNcbiAgICAvLyBmcm9tIHRoZSBmaXJzdCBhdHRlbXB0LCB0byBwcmVzZXJ2ZSB0aGUgY2F1c2FsIHNlcXVlbmNlLlxuXG4gICAgaWYgKGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0ICE9PSBudWxsKSB7XG4gICAgICBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhpdFN0YXR1cztcbn1cblxuZnVuY3Rpb24gcXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnM7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMucHVzaC5hcHBseSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hDb25jdXJyZW50UmVuZGVyKHJvb3QsIGV4aXRTdGF0dXMsIGxhbmVzKSB7XG4gIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgIGNhc2UgUm9vdEluUHJvZ3Jlc3M6XG4gICAgY2FzZSBSb290RmF0YWxFcnJvcmVkOlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICAvLyBGbG93IGtub3dzIGFib3V0IGludmFyaWFudCwgc28gaXQgY29tcGxhaW5zIGlmIEkgYWRkIGEgYnJlYWtcbiAgICAvLyBzdGF0ZW1lbnQsIGJ1dCBlc2xpbnQgZG9lc24ndCBrbm93IGFib3V0IGludmFyaWFudCwgc28gaXQgY29tcGxhaW5zXG4gICAgLy8gaWYgSSBkby4gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFJvb3RFcnJvcmVkOlxuICAgICAge1xuICAgICAgICAvLyBXZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byByZXRyeSB0aGlzIHRyZWUuIElmIHdlIHJlYWNoZWRcbiAgICAgICAgLy8gdGhpcyBwb2ludCwgaXQgZXJyb3JlZCBhZ2Fpbi4gQ29tbWl0IGl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpOyAvLyBXZSBoYXZlIGFuIGFjY2VwdGFibGUgbG9hZGluZyBzdGF0ZS4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHdlXG4gICAgICAgIC8vIHNob3VsZCBpbW1lZGlhdGVseSBjb21taXQgaXQgb3Igd2FpdCBhIGJpdC5cblxuICAgICAgICBpZiAoaW5jbHVkZXNPbmx5UmV0cmllcyhsYW5lcykgJiYgLy8gZG8gbm90IGRlbGF5IGlmIHdlJ3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZVxuICAgICAgICAhc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpIHtcbiAgICAgICAgICAvLyBUaGlzIHJlbmRlciBvbmx5IGluY2x1ZGVkIHJldHJpZXMsIG5vIHVwZGF0ZXMuIFRocm90dGxlIGNvbW1pdHRpbmdcbiAgICAgICAgICAvLyByZXRyaWVzIHNvIHRoYXQgd2UgZG9uJ3Qgc2hvdyB0b28gbWFueSBsb2FkaW5nIHN0YXRlcyB0b28gcXVpY2tseS5cbiAgICAgICAgICB2YXIgbXNVbnRpbFRpbWVvdXQgPSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICsgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLSBub3coKTsgLy8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5cbiAgICAgICAgICBpZiAobXNVbnRpbFRpbWVvdXQgPiAxMCkge1xuICAgICAgICAgICAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcblxuICAgICAgICAgICAgaWYgKG5leHRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgICAgICAvLyBUaGVyZSdzIGFkZGl0aW9uYWwgd29yayBvbiB0aGlzIHJvb3QuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuXG4gICAgICAgICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhzdXNwZW5kZWRMYW5lcywgbGFuZXMpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBwcmVmZXIgdG8gcmVuZGVyIHRoZSBmYWxsYmFjayBvZiBhdCB0aGUgbGFzdFxuICAgICAgICAgICAgICAvLyBzdXNwZW5kZWQgbGV2ZWwuIFBpbmcgdGhlIGxhc3Qgc3VzcGVuZGVkIGxldmVsIHRvIHRyeVxuICAgICAgICAgICAgICAvLyByZW5kZXJpbmcgaXQgYWdhaW4uXG4gICAgICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IGlmIHRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIElkbGU/IFNob3VsZCBub3QgcmVzdGFydC5cbiAgICAgICAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICAgICAgICAgICAgbWFya1Jvb3RQaW5nZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gLy8gVGhlIHJlbmRlciBpcyBzdXNwZW5kZWQsIGl0IGhhc24ndCB0aW1lZCBvdXQsIGFuZCB0aGVyZSdzIG5vXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB3b3JrIHRvIGRvLiBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cblxuXG4gICAgICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwsIHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKSwgbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRoZSB3b3JrIGV4cGlyZWQuIENvbW1pdCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdFN1c3BlbmRlZFdpdGhEZWxheTpcbiAgICAgIHtcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG5cbiAgICAgICAgaWYgKGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSB0cmFuc2l0aW9uLCBzbyB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IGNvbW1pdHRpbmcgYVxuICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIGFuZCB3aXRob3V0IHNjaGVkdWxpbmcgYSB0aW1lb3V0LiBEZWxheSBpbmRlZmluaXRlbHlcbiAgICAgICAgICAvLyB1bnRpbCB3ZSByZWNlaXZlIG1vcmUgZGF0YS5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIG5vdCBhIHRyYW5zaXRpb24sIGJ1dCB3ZSBkaWQgdHJpZ2dlciBhbiBhdm9pZGVkIHN0YXRlLlxuICAgICAgICAgIC8vIFNjaGVkdWxlIGEgcGxhY2Vob2xkZXIgdG8gZGlzcGxheSBhZnRlciBhIHNob3J0IGRlbGF5LCB1c2luZyB0aGUgSnVzdFxuICAgICAgICAgIC8vIE5vdGljZWFibGUgRGlmZmVyZW5jZS5cbiAgICAgICAgICAvLyBUT0RPOiBJcyB0aGUgSk5EIG9wdGltaXphdGlvbiB3b3J0aCB0aGUgYWRkZWQgY29tcGxleGl0eT8gSWYgdGhpcyBpc1xuICAgICAgICAgIC8vIHRoZSBvbmx5IHJlYXNvbiB3ZSB0cmFjayB0aGUgZXZlbnQgdGltZSwgdGhlbiBwcm9iYWJseSBub3QuXG4gICAgICAgICAgLy8gQ29uc2lkZXIgcmVtb3ZpbmcuXG4gICAgICAgICAgdmFyIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBnZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsIGxhbmVzKTtcbiAgICAgICAgICB2YXIgZXZlbnRUaW1lTXMgPSBtb3N0UmVjZW50RXZlbnRUaW1lO1xuICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE1zID0gbm93KCkgLSBldmVudFRpbWVNcztcblxuICAgICAgICAgIHZhciBfbXNVbnRpbFRpbWVvdXQgPSBqbmQodGltZUVsYXBzZWRNcykgLSB0aW1lRWxhcHNlZE1zOyAvLyBEb24ndCBib3RoZXIgd2l0aCBhIHZlcnkgc2hvcnQgc3VzcGVuc2UgdGltZS5cblxuXG4gICAgICAgICAgaWYgKF9tc1VudGlsVGltZW91dCA+IDEwKSB7XG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICAgIC8vIHRvIGFycml2ZS5cbiAgICAgICAgICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChjb21taXRSb290LmJpbmQobnVsbCwgcm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpLCBfbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbW1pdCB0aGUgcGxhY2Vob2xkZXIuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcm9vdCBleGl0IHN0YXR1cy4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFNlYXJjaCB0aGUgcmVuZGVyZWQgdHJlZSBmb3IgZXh0ZXJuYWwgc3RvcmUgcmVhZHMsIGFuZCBjaGVjayB3aGV0aGVyIHRoZVxuICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkIGluIGEgY29uY3VycmVudCBldmVudC4gSW50ZW50aW9uYWxseSB1c2luZyBhbiBpdGVyYXRpdmVcbiAgLy8gbG9vcCBpbnN0ZWFkIG9mIHJlY3Vyc2lvbiBzbyB3ZSBjYW4gZXhpdCBlYXJseS5cbiAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS5mbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IG5vZGUudXBkYXRlUXVldWU7XG5cbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gdXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgICAgIGlmIChjaGVja3MgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gY2hlY2tzW2ldO1xuICAgICAgICAgICAgdmFyIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRWYWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIHJlbmRlcmVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gaW5jb25zaXN0ZW50IHN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYGdldFNuYXBzaG90YCB0aHJvd3MsIHJldHVybiBgZmFsc2VgLiBUaGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgICAgICAgICAgLy8gYSByZS1yZW5kZXIsIGFuZCB0aGUgZXJyb3Igd2lsbCBiZSByZXRocm93biBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9IC8vIEZsb3cgZG9lc24ndCBrbm93IHRoaXMgaXMgdW5yZWFjaGFibGUsIGJ1dCBlc2xpbnQgZG9lc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIC8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbiAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyk7XG4gIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgZ29cbi8vIHRocm91Z2ggU2NoZWR1bGVyXG5cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QpIHtcbiAge1xuICAgIHN5bmNOZXN0ZWRVcGRhdGVGbGFnKCk7XG4gIH1cblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgdmFyIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIE5vTGFuZXMpO1xuXG4gIGlmICghaW5jbHVkZXNTb21lTGFuZShsYW5lcywgU3luY0xhbmUpKSB7XG4gICAgLy8gVGhlcmUncyBubyByZW1haW5pbmcgc3luYyB3b3JrIGxlZnQuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChyb290LnRhZyAhPT0gTGVnYWN5Um9vdCAmJiBleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgIC8vIElmIHNvbWV0aGluZyB0aHJldyBhbiBlcnJvciwgdHJ5IHJlbmRlcmluZyBvbmUgbW9yZSB0aW1lLiBXZSdsbCByZW5kZXJcbiAgICAvLyBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbCBpbmNsdWRlc1xuICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4gICAgLy8gYXR0ZW1wdCwgd2UnbGwgZ2l2ZSB1cCBhbmQgY29tbWl0IHRoZSByZXN1bHRpbmcgdHJlZS5cbiAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICBsYW5lcyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgdmFyIGZhdGFsRXJyb3IgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG4gICAgdGhyb3cgZmF0YWxFcnJvcjtcbiAgfVxuXG4gIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gQmVjYXVzZSB0aGlzIGlzIGEgc3luYyByZW5kZXIsIHdlXG4gIC8vIHdpbGwgY29tbWl0IGl0IGV2ZW4gaWYgc29tZXRoaW5nIHN1c3BlbmRlZC5cblxuXG4gIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gbGFuZXM7XG4gIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMpOyAvLyBCZWZvcmUgZXhpdGluZywgbWFrZSBzdXJlIHRoZXJlJ3MgYSBjYWxsYmFjayBzY2hlZHVsZWQgZm9yIHRoZSBuZXh0XG4gIC8vIHBlbmRpbmcgbGV2ZWwuXG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBsYW5lcykge1xuICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBtZXJnZUxhbmVzKGxhbmVzLCBTeW5jTGFuZSkpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja3MoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzJDEoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIElmIHRoZXJlIHdlcmUgbGVnYWN5IHN5bmMgdXBkYXRlcywgZmx1c2ggdGhlbSBhdCB0aGUgZW5kIG9mIHRoZSBvdXRlclxuICAgIC8vIG1vc3QgYmF0Y2hlZFVwZGF0ZXMtbGlrZSBtZXRob2QuXG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0ICYmIC8vIFRyZWF0IGBhY3RgIGFzIGlmIGl0J3MgaW5zaWRlIGBiYXRjaGVkVXBkYXRlc2AsIGV2ZW4gaW4gbGVnYWN5IG1vZGUuXG4gICAgISggUmVhY3RDdXJyZW50QWN0UXVldWUkMS5pc0JhdGNoaW5nTGVnYWN5KSkge1xuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tzT25seUluTGVnYWN5TW9kZSgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlzY3JldGVVcGRhdGVzKGZuLCBhLCBiLCBjLCBkKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjtcblxuICB0cnkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICB9XG4gIH1cbn0gLy8gT3ZlcmxvYWQgdGhlIGRlZmluaXRpb24gdG8gdGhlIHR3byB2YWxpZCBzaWduYXR1cmVzLlxuLy8gV2FybmluZywgdGhpcyBvcHRzLW91dCBvZiBjaGVja2luZyB0aGUgZnVuY3Rpb24gYm9keS5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG4gIC8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBmbHVzaCBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAvLyBuZXh0IGV2ZW50LCBub3QgYXQgdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgb25lLlxuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwgJiYgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMudGFnID09PSBMZWdhY3lSb290ICYmIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcblxuICB0cnkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbiA9IG51bGw7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG5cbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgaGFwcGVuIGV2ZW4gaWYgYmF0Y2hlZFVwZGF0ZXMgaXMgaGlnaGVyIHVwXG4gICAgLy8gdGhlIHN0YWNrLlxuXG4gICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0FscmVhZHlSZW5kZXJpbmcoKSB7XG4gIC8vIFVzZWQgYnkgdGhlIHJlbmRlcmVyIHRvIHByaW50IGEgd2FybmluZyBpZiBjZXJ0YWluIEFQSXMgYXJlIGNhbGxlZCBmcm9tXG4gIC8vIHRoZSB3cm9uZyBjb250ZXh0LlxuICByZXR1cm4gIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dDtcbn1cbmZ1bmN0aW9uIHB1c2hSZW5kZXJMYW5lcyhmaWJlciwgbGFuZXMpIHtcbiAgcHVzaChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIHN1YnRyZWVSZW5kZXJMYW5lcywgZmliZXIpO1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBtZXJnZUxhbmVzKHN1YnRyZWVSZW5kZXJMYW5lcywgbGFuZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiBwb3BSZW5kZXJMYW5lcyhmaWJlcikge1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcbiAgcG9wKHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAvLyBUaGUgcm9vdCBwcmV2aW91cyBzdXNwZW5kZWQgYW5kIHNjaGVkdWxlZCBhIHRpbWVvdXQgdG8gY29tbWl0IGEgZmFsbGJhY2tcbiAgICAvLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cbiAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7IC8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5cbiAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gaW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgd29ya0luUHJvZ3Jlc3MgPSByb290V29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IGxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDtcbiAgZW5xdWV1ZUludGVybGVhdmVkVXBkYXRlcygpO1xuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gIH1cblxuICByZXR1cm4gcm9vdFdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSkge1xuICBkbyB7XG4gICAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICB0cnkge1xuICAgICAgLy8gUmVzZXQgbW9kdWxlLWxldmVsIHN0YXRlIHRoYXQgd2FzIHNldCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTtcbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7IC8vIFRPRE86IEkgZm91bmQgYW5kIGFkZGVkIHRoaXMgbWlzc2luZyBsaW5lIHdoaWxlIGludmVzdGlnYXRpbmcgYVxuICAgICAgLy8gc2VwYXJhdGUgaXNzdWUuIFdyaXRlIGEgcmVncmVzc2lvbiB0ZXN0IHVzaW5nIHN0cmluZyByZWZzLlxuXG4gICAgICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgICBpZiAoZXJyb3JlZFdvcmsgPT09IG51bGwgfHwgZXJyb3JlZFdvcmsucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIHRvIGJlIHdvcmtpbmcgb24gYSBub24tcm9vdCBmaWJlci4gVGhpcyBpcyBhIGZhdGFsIGVycm9yXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBhbmNlc3RvciB0aGF0IGNhbiBoYW5kbGUgaXQ7IHRoZSByb290IGlzXG4gICAgICAgIC8vIHN1cHBvc2VkIHRvIGNhcHR1cmUgYWxsIGVycm9ycyB0aGF0IHdlcmVuJ3QgY2F1Z2h0IGJ5IGFuIGVycm9yXG4gICAgICAgIC8vIGJvdW5kYXJ5LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvciA9IHRocm93blZhbHVlOyAvLyBTZXQgYHdvcmtJblByb2dyZXNzYCB0byBudWxsLiBUaGlzIHJlcHJlc2VudHMgYWR2YW5jaW5nIHRvIHRoZSBuZXh0XG4gICAgICAgIC8vIHNpYmxpbmcsIG9yIHRoZSBwYXJlbnQgaWYgdGhlcmUgYXJlIG5vIHNpYmxpbmdzLiBCdXQgc2luY2UgdGhlIHJvb3RcbiAgICAgICAgLy8gaGFzIG5vIHNpYmxpbmdzIG5vciBhIHBhcmVudCwgd2Ugc2V0IGl0IHRvIG51bGwuIFVzdWFsbHkgdGhpcyBpc1xuICAgICAgICAvLyBoYW5kbGVkIGJ5IGBjb21wbGV0ZVVuaXRPZldvcmtgIG9yIGB1bndpbmRXb3JrYCwgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgbm90IGNhbGxpbmcgdGhvc2UsIHdlIG5lZWQgc2V0IGl0IGhlcmUuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGNhbGxpbmcgYHVud2luZFdvcmtgIHRvIHBvcCB0aGUgY29udGV4dHMuXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIGVycm9yZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHRpbWUgc3BlbnQgcmVuZGVyaW5nIGJlZm9yZSBhbiBlcnJvciB3YXMgdGhyb3duLiBUaGlzXG4gICAgICAgIC8vIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhXG4gICAgICAgIC8vIHN1c3BlbmRlZCByZW5kZXIuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZXJyb3JlZFdvcmssIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyKSB7XG4gICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG5cbiAgICAgICAgaWYgKHRocm93blZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB0aHJvd25WYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRocm93blZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgd2FrZWFibGUgPSB0aHJvd25WYWx1ZTtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50U3VzcGVuZGVkKGVycm9yZWRXb3JrLCB3YWtlYWJsZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcmtDb21wb25lbnRFcnJvcmVkKGVycm9yZWRXb3JrLCB0aHJvd25WYWx1ZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIGVycm9yZWRXb3JrLnJldHVybiwgZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO1xuICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxuICAgICAgdGhyb3duVmFsdWUgPSB5ZXRBbm90aGVyVGhyb3duVmFsdWU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGVycm9yZWRXb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgIHJldHVybjtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpIHtcbiAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdygpO1xufVxuZnVuY3Rpb24gbWFya1NraXBwZWRVcGRhdGVMYW5lcyhsYW5lKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IG1lcmdlTGFuZXMobGFuZSwgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmQoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcykge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB0cmVlIHRoYXQgbWlnaHQgaGF2ZSB1bmJsb2NrZWRcbiAgLy8gdGhpcyByZW5kZXIuXG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsICYmIChpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcykgfHwgaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcykpKSB7XG4gICAgLy8gTWFyayB0aGUgY3VycmVudCByZW5kZXIgYXMgc3VzcGVuZGVkIHNvIHRoYXQgd2Ugc3dpdGNoIHRvIHdvcmtpbmcgb25cbiAgICAvLyB0aGUgdXBkYXRlcyB0aGF0IHdlcmUgc2tpcHBlZC4gVXN1YWxseSB3ZSBvbmx5IHN1c3BlbmQgYXQgdGhlIGVuZCBvZlxuICAgIC8vIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IGFsd2F5cyBtYXJrIHRoZSByb290IGFzIHN1c3BlbmRlZCBpbW1lZGlhdGVseVxuICAgIC8vIChpbnNpZGUgdGhpcyBmdW5jdGlvbiksIHNpbmNlIGJ5IHN1c3BlbmRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgcmVuZGVyXG4gICAgLy8gcGhhc2UgaW50cm9kdWNlcyBhIHBvdGVudGlhbCBtaXN0YWtlIHdoZXJlIHdlIHN1c3BlbmQgbGFuZXMgdGhhdCB3ZXJlXG4gICAgLy8gcGluZ2VkIG9yIHVwZGF0ZWQgd2hpbGUgd2Ugd2VyZSByZW5kZXJpbmcuXG4gICAgbWFya1Jvb3RTdXNwZW5kZWQkMSh3b3JrSW5Qcm9ncmVzc1Jvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkRXJyb3IoZXJyb3IpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQ7XG4gIH1cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBbZXJyb3JdO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMucHVzaChlcnJvcik7XG4gIH1cbn0gLy8gQ2FsbGVkIGR1cmluZyByZW5kZXIgdG8gZGV0ZXJtaW5lIGlmIGFueXRoaW5nIGhhcyBzdXNwZW5kZWQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHdlJ3JlIG5vdCBzdXJlLlxuXG5mdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSB7XG4gIC8vIElmIHNvbWV0aGluZyBlcnJvcmVkIG9yIGNvbXBsZXRlZCwgd2UgY2FuJ3QgcmVhbGx5IGJlIHN1cmUsXG4gIC8vIHNvIHRob3NlIGFyZSBmYWxzZS5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuXG4gICAgICAgIGlmIChtZW1vaXplZFVwZGF0ZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgICAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIG1vdmUgRmliZXJzIHRoYXQgc2NoZWR1bGVkIHRoZSB1cGNvbWluZyB3b3JrIGZyb20gdGhlIE1hcCB0byB0aGUgU2V0LlxuICAgICAgICAvLyBJZiB3ZSBiYWlsb3V0IG9uIHRoaXMgd29yaywgd2UnbGwgbW92ZSB0aGVtIGJhY2sgKGxpa2UgYWJvdmUpLlxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBtb3ZlIHRoZW0gbm93IGluIGNhc2UgdGhlIHdvcmsgc3Bhd25zIG1vcmUgd29yayBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoIGRpZmZlcmVudCB1cGRhdGVycy5cbiAgICAgICAgLy8gVGhhdCB3YXkgd2UgY2FuIGtlZXAgdGhlIGN1cnJlbnQgdXBkYXRlIGFuZCBmdXR1cmUgdXBkYXRlcyBzZXBhcmF0ZS5cblxuXG4gICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IGdldFRyYW5zaXRpb25zRm9yTGFuZXMoKTtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhICcgKyAnYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhlcmUncyBubyBpbi1wcm9ncmVzcyByZW5kZXIuXG5cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xufSAvLyBUaGUgd29yayBsb29wIGlzIGFuIGV4dHJlbWVseSBob3QgcGF0aC4gVGVsbCBDbG9zdXJlIG5vdCB0byBpbmxpbmUgaXQuXG5cbi8qKiBAbm9pbmxpbmUgKi9cblxuXG5mdW5jdGlvbiB3b3JrTG9vcFN5bmMoKSB7XG4gIC8vIEFscmVhZHkgdGltZWQgb3V0LCBzbyBwZXJmb3JtIHdvcmsgd2l0aG91dCBjaGVja2luZyBpZiB3ZSBuZWVkIHRvIHlpZWxkLlxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZW5kZXJDb250ZXh0O1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpOyAvLyBJZiB0aGUgcm9vdCBvciBsYW5lcyBoYXZlIGNoYW5nZWQsIHRocm93IG91dCB0aGUgZXhpc3Rpbmcgc3RhY2tcbiAgLy8gYW5kIHByZXBhcmUgYSBmcmVzaCBvbmUuIE90aGVyd2lzZSB3ZSdsbCBjb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZi5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ICE9PSByb290IHx8IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBsYW5lcykge1xuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcblxuICAgICAgICBpZiAobWVtb2l6ZWRVcGRhdGVycy5zaXplID4gMCkge1xuICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICAgICAgfSAvLyBBdCB0aGlzIHBvaW50LCBtb3ZlIEZpYmVycyB0aGF0IHNjaGVkdWxlZCB0aGUgdXBjb21pbmcgd29yayBmcm9tIHRoZSBNYXAgdG8gdGhlIFNldC5cbiAgICAgICAgLy8gSWYgd2UgYmFpbG91dCBvbiB0aGlzIHdvcmssIHdlJ2xsIG1vdmUgdGhlbSBiYWNrIChsaWtlIGFib3ZlKS5cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gbW92ZSB0aGVtIG5vdyBpbiBjYXNlIHRoZSB3b3JrIHNwYXducyBtb3JlIHdvcmsgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aCBkaWZmZXJlbnQgdXBkYXRlcnMuXG4gICAgICAgIC8vIFRoYXQgd2F5IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50IHVwZGF0ZSBhbmQgZnV0dXJlIHVwZGF0ZXMgc2VwYXJhdGUuXG5cblxuICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBnZXRUcmFuc2l0aW9uc0ZvckxhbmVzKCk7XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gU3RpbGwgd29yayByZW1haW5pbmcuXG4gICAge1xuICAgICAgbWFya1JlbmRlcllpZWxkZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUm9vdEluUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcGxldGVkIHRoZSB0cmVlLlxuICAgIHtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICB9XG59XG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHNldEN1cnJlbnRGaWJlcih1bml0T2ZXb3JrKTtcbiAgdmFyIG5leHQ7XG5cbiAgaWYgKCAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrJDEoY3VycmVudCwgdW5pdE9mV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG4gIC8vIHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlIHBhcmVudCBmaWJlci5cbiAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuXG4gIGRvIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBjb21wbGV0ZWRXb3JrLnJldHVybjsgLy8gQ2hlY2sgaWYgdGhlIHdvcmsgY29tcGxldGVkIG9yIGlmIHNvbWV0aGluZyB0aHJldy5cblxuICAgIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIEluY29tcGxldGUpID09PSBOb0ZsYWdzKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIoY29tcGxldGVkV29yayk7XG4gICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7IC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrKTsgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBsYW5lcy5cblxuXG4gICAgICBpZiAoX25leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgLy8gU2luY2Ugd2UncmUgcmVzdGFydGluZywgcmVtb3ZlIGFueXRoaW5nIHRoYXQgaXMgbm90IGEgaG9zdCBlZmZlY3RcbiAgICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgICAgX25leHQuZmxhZ3MgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gX25leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSByZW5kZXIgZHVyYXRpb24gZm9yIHRoZSBmaWJlciB0aGF0IGVycm9yZWQuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpOyAvLyBJbmNsdWRlIHRoZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gZmFpbGVkIGNoaWxkcmVuIGJlZm9yZSBjb250aW51aW5nLlxuXG4gICAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTWFyayB0aGUgcGFyZW50IGZpYmVyIGFzIGluY29tcGxldGUgYW5kIGNsZWFyIGl0cyBzdWJ0cmVlIGZsYWdzLlxuICAgICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgICByZXR1cm5GaWJlci5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgdW53b3VuZCBhbGwgdGhlIHdheSB0byB0aGUgcm9vdC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmdGaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcblxuXG4gICAgY29tcGxldGVkV29yayA9IHJldHVybkZpYmVyOyAvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gIH0gd2hpbGUgKGNvbXBsZXRlZFdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMpIHtcbiAgLy8gVE9ETzogVGhpcyBubyBsb25nZXIgbWFrZXMgYW55IHNlbnNlLiBXZSBhbHJlYWR5IHdyYXAgdGhlIG11dGF0aW9uIGFuZFxuICAvLyBsYXlvdXQgcGhhc2VzLiBTaG91bGQgYmUgYWJsZSB0byByZW1vdmUuXG4gIHZhciBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb247XG5cbiAgdHJ5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIGNvbW1pdFJvb3RJbXBsKHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdEltcGwocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIGRvIHtcbiAgICAvLyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBjYWxsIGBmbHVzaFN5bmNVcGRhdGVRdWV1ZWAgYXQgdGhlIGVuZCwgd2hpY2hcbiAgICAvLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzaXZlIGVmZmVjdHMuIFNvIHdlIG5lZWQgdG8ga2VlcCBmbHVzaGluZyBpbiBhIGxvb3AgdW50aWwgdGhlcmUgYXJlXG4gICAgLy8gbm8gbW9yZSBwZW5kaW5nIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBmbHVzaCBzeW5jaHJvbm91cyB3b3JrIGF0IHRoZSBlbmQsIHRvIGF2b2lkIGZhY3RvcmluZyBoYXphcmRzIGxpa2UgdGhpcy5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gd2hpbGUgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKTtcblxuICBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKTtcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgdmFyIGxhbmVzID0gcm9vdC5maW5pc2hlZExhbmVzO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBpZiAoZmluaXNoZWRXb3JrID09PSBudWxsKSB7XG5cbiAgICB7XG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgICBlcnJvcigncm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgJyArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5ICcgKyAnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9IC8vIGNvbW1pdFJvb3QgbmV2ZXIgcmV0dXJucyBhIGNvbnRpbnVhdGlvbjsgaXQgYWx3YXlzIGZpbmlzaGVzIHN5bmNocm9ub3VzbHkuXG4gIC8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxuXG5cbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7IC8vIFVwZGF0ZSB0aGUgZmlyc3QgYW5kIGxhc3QgcGVuZGluZyB0aW1lcyBvbiB0aGlzIHJvb3QuIFRoZSBuZXcgZmlyc3RcbiAgLy8gcGVuZGluZyB0aW1lIGlzIHdoYXRldmVyIGlzIGxlZnQgb24gdGhlIHJvb3QgZmliZXIuXG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzID0gbWVyZ2VMYW5lcyhmaW5pc2hlZFdvcmsubGFuZXMsIGZpbmlzaGVkV29yay5jaGlsZExhbmVzKTtcbiAgbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcyk7XG5cbiAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFdlIGNhbiByZXNldCB0aGVzZSBub3cgdGhhdCB0aGV5IGFyZSBmaW5pc2hlZC5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvIHByb2Nlc3MgdGhlbS5cbiAgLy8gRG8gdGhpcyBhcyBlYXJseSBhcyBwb3NzaWJsZSwgc28gaXQgaXMgcXVldWVkIGJlZm9yZSBhbnl0aGluZyBlbHNlIHRoYXRcbiAgLy8gbWlnaHQgZ2V0IHNjaGVkdWxlZCBpbiB0aGUgY29tbWl0IHBoYXNlLiAoU2VlICMxNjcxNC4pXG4gIC8vIFRPRE86IERlbGV0ZSBhbGwgb3RoZXIgcGxhY2VzIHRoYXQgc2NoZWR1bGUgdGhlIHBhc3NpdmUgZWZmZWN0IGNhbGxiYWNrXG4gIC8vIFRoZXkncmUgcmVkdW5kYW50LlxuXG5cbiAgaWYgKChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzIHx8IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MpIHtcbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICAvLyB0byBzdG9yZSBpdCBpbiBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zIHVudGlsIHRoZXkgZ2V0IHByb2Nlc3NlZFxuICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIHRoaXMgdGhyb3VnaCBhcyBhbiBhcmd1bWVudCB0byBjb21taXRSb290XG4gICAgICAvLyBiZWNhdXNlIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgbWlnaHQgaGF2ZSBjaGFuZ2VkIGJldHdlZW5cbiAgICAgIC8vIHRoZSBwcmV2aW91cyByZW5kZXIgYW5kIGNvbW1pdCBpZiB3ZSB0aHJvdHRsZSB0aGUgY29tbWl0XG4gICAgICAvLyB3aXRoIHNldFRpbWVvdXRcblxuICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICAgICAgc2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTsgLy8gVGhpcyByZW5kZXIgdHJpZ2dlcmVkIHBhc3NpdmUgZWZmZWN0czogcmVsZWFzZSB0aGUgcm9vdCBjYWNoZSBwb29sXG4gICAgICAgIC8vICphZnRlciogcGFzc2l2ZSBlZmZlY3RzIGZpcmUgdG8gYXZvaWQgZnJlZWluZyBhIGNhY2hlIHBvb2wgdGhhdCBtYXlcbiAgICAgICAgLy8gYmUgcmVmZXJlbmNlZCBieSBhIG5vZGUgaW4gdGhlIHRyZWUgKEhvc3RSb290LCBDYWNoZSBib3VuZGFyeSBldGMpXG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBlZmZlY3RzIGluIHRoZSB3aG9sZSB0cmVlLlxuICAvLyBUT0RPOiBUaGlzIGlzIGxlZnQgb3ZlciBmcm9tIHRoZSBlZmZlY3QgbGlzdCBpbXBsZW1lbnRhdGlvbiwgd2hlcmUgd2UgaGFkXG4gIC8vIHRvIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGBmaXJzdEVmZmVjdGAgdG8gc2F0aXNmeSBGbG93LiBJIHRoaW5rIHRoZVxuICAvLyBvbmx5IG90aGVyIHJlYXNvbiB0aGlzIG9wdGltaXphdGlvbiBleGlzdHMgaXMgYmVjYXVzZSBpdCBhZmZlY3RzIHByb2ZpbGluZy5cbiAgLy8gUmVjb25zaWRlciB3aGV0aGVyIHRoaXMgaXMgbmVjZXNzYXJ5LlxuXG5cbiAgdmFyIHN1YnRyZWVIYXNFZmZlY3RzID0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAoQmVmb3JlTXV0YXRpb25NYXNrIHwgTXV0YXRpb25NYXNrIHwgTGF5b3V0TWFzayB8IFBhc3NpdmVNYXNrKSkgIT09IE5vRmxhZ3M7XG4gIHZhciByb290SGFzRWZmZWN0ID0gKGZpbmlzaGVkV29yay5mbGFncyAmIChCZWZvcmVNdXRhdGlvbk1hc2sgfCBNdXRhdGlvbk1hc2sgfCBMYXlvdXRNYXNrIHwgUGFzc2l2ZU1hc2spKSAhPT0gTm9GbGFncztcblxuICBpZiAoc3VidHJlZUhhc0VmZmVjdHMgfHwgcm9vdEhhc0VmZmVjdCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDMudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7IC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG5cbiAgICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsOyAvLyBUaGUgY29tbWl0IHBoYXNlIGlzIGJyb2tlbiBpbnRvIHNldmVyYWwgc3ViLXBoYXNlcy4gV2UgZG8gYSBzZXBhcmF0ZSBwYXNzXG4gICAgLy8gb2YgdGhlIGVmZmVjdCBsaXN0IGZvciBlYWNoIHBoYXNlOiBhbGwgbXV0YXRpb24gZWZmZWN0cyBjb21lIGJlZm9yZSBhbGxcbiAgICAvLyBsYXlvdXQgZWZmZWN0cywgYW5kIHNvIG9uLlxuICAgIC8vIFRoZSBmaXJzdCBwaGFzZSBhIFwiYmVmb3JlIG11dGF0aW9uXCIgcGhhc2UuIFdlIHVzZSB0aGlzIHBoYXNlIHRvIHJlYWQgdGhlXG4gICAgLy8gc3RhdGUgb2YgdGhlIGhvc3QgdHJlZSByaWdodCBiZWZvcmUgd2UgbXV0YXRlIGl0LiBUaGlzIGlzIHdoZXJlXG4gICAgLy8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgaXMgY2FsbGVkLlxuXG4gICAgdmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAge1xuICAgICAgLy8gTWFyayB0aGUgY3VycmVudCBjb21taXQgdGltZSB0byBiZSBzaGFyZWQgYnkgYWxsIFByb2ZpbGVycyBpbiB0aGlzXG4gICAgICAvLyBiYXRjaC4gVGhpcyBlbmFibGVzIHRoZW0gdG8gYmUgZ3JvdXBlZCBsYXRlci5cbiAgICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgICB9XG5cblxuICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcblxuICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgbXV0YXRpb24gcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGwgY3VycmVudCBkdXJpbmdcbiAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgbGF5b3V0IHBoYXNlLCBzbyB0aGF0IHRoZSBmaW5pc2hlZFxuICAgIC8vIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbGF5b3V0IHBoYXNlLCB3aGVyZSB3ZSBjYWxsIGVmZmVjdHMgdGhhdCByZWFkXG5cbiAgICB7XG4gICAgICBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cblxuICAgIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCByb290LCBsYW5lcyk7XG5cbiAgICB7XG4gICAgICBtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gICAgLy8gb3Bwb3J0dW5pdHkgdG8gcGFpbnQuXG5cblxuICAgIHJlcXVlc3RQYWludCgpO1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gUmVzZXQgdGhlIHByaW9yaXR5IHRvIHRoZSBwcmV2aW91cyBub24tc3luYyB2YWx1ZS5cblxuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQzLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBlZmZlY3RzLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gTWVhc3VyZSB0aGVzZSBhbnl3YXkgc28gdGhlIGZsYW1lZ3JhcGggZXhwbGljaXRseSBzaG93cyB0aGF0IHRoZXJlIHdlcmVcbiAgICAvLyBubyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGlzLlxuXG4gICAge1xuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM7XG5cbiAgaWYgKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gVGhpcyBjb21taXQgaGFzIHBhc3NpdmUgZWZmZWN0cy4gU3Rhc2ggYSByZWZlcmVuY2UgdG8gdGhlbS4gQnV0IGRvbid0XG4gICAgLy8gc2NoZWR1bGUgYSBjYWxsYmFjayB1bnRpbCBhZnRlciBmbHVzaGluZyBsYXlvdXQgd29yay5cbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdDtcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IGxhbmVzO1xuICB9IGVsc2Uge1xuXG4gICAge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuICAgIH1cbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGFuIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcblxuXG4gIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7IC8vIENoZWNrIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290XG4gIC8vIFRPRE86IFRoaXMgaXMgcGFydCBvZiB0aGUgYGNvbXBvbmVudERpZENhdGNoYCBpbXBsZW1lbnRhdGlvbi4gSXRzIHB1cnBvc2VcbiAgLy8gaXMgdG8gZGV0ZWN0IHdoZXRoZXIgc29tZXRoaW5nIG1pZ2h0IGhhdmUgY2FsbGVkIHNldFN0YXRlIGluc2lkZVxuICAvLyBgY29tcG9uZW50RGlkQ2F0Y2hgLiBUaGUgbWVjaGFuaXNtIGlzIGtub3duIHRvIGJlIGZsYXdlZCBiZWNhdXNlIGBzZXRTdGF0ZWBcbiAgLy8gaW5zaWRlIGBjb21wb25lbnREaWRDYXRjaGAgaXMgaXRzZWxmIGZsYXdlZCDigJQgdGhhdCdzIHdoeSB3ZSByZWNvbW1lbmRcbiAgLy8gYGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcmAgaW5zdGVhZC4gSG93ZXZlciwgaXQgY291bGQgYmUgaW1wcm92ZWQgYnlcbiAgLy8gY2hlY2tpbmcgaWYgcmVtYWluaW5nTGFuZXMgaW5jbHVkZXMgU3luYyB3b3JrLCBpbnN0ZWFkIG9mIHdoZXRoZXIgdGhlcmUnc1xuICAvLyBhbnkgd29yayByZW1haW5pbmcgYXQgYWxsICh3aGljaCB3b3VsZCBhbHNvIGluY2x1ZGUgc3R1ZmYgbGlrZSBTdXNwZW5zZVxuICAvLyByZXRyaWVzIG9yIHRyYW5zaXRpb25zKS4gSXQncyBiZWVuIGxpa2UgdGhpcyBmb3IgYSB3aGlsZSwgdGhvdWdoLCBzbyBmaXhpbmdcbiAgLy8gaXQgcHJvYmFibHkgaXNuJ3QgdGhhdCB1cmdlbnQuXG5cbiAgaWYgKHJlbWFpbmluZ0xhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIXJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LmN1cnJlbnQsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCk7XG5cbiAge1xuICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgcm9vdC5tZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG9uQ29tbWl0Um9vdCQxKCk7XG4gIH0gLy8gQWx3YXlzIGNhbGwgdGhpcyBiZWZvcmUgZXhpdGluZyBgY29tbWl0Um9vdGAsIHRvIGVuc3VyZSB0aGF0IGFueVxuICAvLyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290IGlzIHNjaGVkdWxlZC5cblxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cbiAgaWYgKHJlY292ZXJhYmxlRXJyb3JzICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUgd2VyZSBlcnJvcnMgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgcmVjb3ZlcmVkIGZyb20gdGhlbSB3aXRob3V0XG4gICAgLy8gbmVlZGluZyB0byBzdXJmYWNlIGl0IHRvIHRoZSBVSS4gV2UgbG9nIHRoZW0gaGVyZS5cbiAgICB2YXIgb25SZWNvdmVyYWJsZUVycm9yID0gcm9vdC5vblJlY292ZXJhYmxlRXJyb3I7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVjb3ZlcmFibGVFcnJvciA9IHJlY292ZXJhYmxlRXJyb3JzW2ldO1xuICAgICAgb25SZWNvdmVyYWJsZUVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciQxID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3IkMTtcbiAgfSAvLyBJZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgcmVuZGVyLCBmbHVzaCB0aGVtXG4gIC8vIHN5bmNocm9ub3VzbHkgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0YXNrIHNvIHRoYXQgdGhlIHJlc3VsdCBpc1xuICAvLyBpbW1lZGlhdGVseSBvYnNlcnZhYmxlLiBPdGhlcndpc2UsIHdlIGFzc3VtZSB0aGF0IHRoZXkgYXJlIG5vdFxuICAvLyBvcmRlci1kZXBlbmRlbnQgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIG9ic2VydmVkIGJ5IGV4dGVybmFsIHN5c3RlbXMsIHNvIHdlXG4gIC8vIGNhbiB3YWl0IHVudGlsIGFmdGVyIHBhaW50LlxuICAvLyBUT0RPOiBXZSBjYW4gb3B0aW1pemUgdGhpcyBieSBub3Qgc2NoZWR1bGluZyB0aGUgY2FsbGJhY2sgZWFybGllci4gU2luY2Ugd2VcbiAgLy8gY3VycmVudGx5IHNjaGVkdWxlIHRoZSBjYWxsYmFjayBpbiBtdWx0aXBsZSBwbGFjZXMsIHdpbGwgd2FpdCB1bnRpbCB0aG9zZVxuICAvLyBhcmUgY29uc29saWRhdGVkLlxuXG5cbiAgaWYgKGluY2x1ZGVzU29tZUxhbmUocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMsIFN5bmNMYW5lKSAmJiByb290LnRhZyAhPT0gTGVnYWN5Um9vdCkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGEgcGFzc2l2ZSBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzLCBTeW5jTGFuZSkpIHtcbiAgICB7XG4gICAgICBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCk7XG4gICAgfSAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4gICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cblxuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9IC8vIElmIGxheW91dCB3b3JrIHdhcyBzY2hlZHVsZWQsIGZsdXNoIGl0IG5vdy5cblxuXG4gIGZsdXNoU3luY0NhbGxiYWNrcygpO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gIC8vIFJldHVybnMgd2hldGhlciBwYXNzaXZlIGVmZmVjdHMgd2VyZSBmbHVzaGVkLlxuICAvLyBUT0RPOiBDb21iaW5lIHRoaXMgY2hlY2sgd2l0aCB0aGUgb25lIGluIGZsdXNoUGFzc2l2ZUVGZmVjdHNJbXBsLiBXZSBzaG91bGRcbiAgLy8gcHJvYmFibHkganVzdCBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zLiBJIGJlbGlldmUgdGhleSB3ZXJlIG9ubHkgc2VwYXJhdGVcbiAgLy8gaW4gdGhlIGZpcnN0IHBsYWNlIGJlY2F1c2Ugd2UgdXNlZCB0byB3cmFwIGl0IHdpdGhcbiAgLy8gYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLCB3aGljaCBhY2NlcHRzIGEgZnVuY3Rpb24uIEJ1dCBub3cgd2UgdHJhY2sgdGhlXG4gIC8vIHByaW9yaXR5IHdpdGhpbiBSZWFjdCBpdHNlbGYsIHNvIHdlIGNhbiBtdXRhdGUgdGhlIHZhcmlhYmxlIGRpcmVjdGx5LlxuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwpIHtcbiAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyk7XG4gICAgdmFyIHByaW9yaXR5ID0gbG93ZXJFdmVudFByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5LCByZW5kZXJQcmlvcml0eSk7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgICB0cnkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uID0gbnVsbDtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgICByZXR1cm4gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMy50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247IC8vIE9uY2UgcGFzc2l2ZSBlZmZlY3RzIGhhdmUgcnVuIGZvciB0aGUgdHJlZSAtIGdpdmluZyBjb21wb25lbnRzIGFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaWJlcikge1xuICB7XG4gICAgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMucHVzaChmaWJlcik7XG5cbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIENhY2hlIGFuZCBjbGVhciB0aGUgdHJhbnNpdGlvbnMgZmxhZ1xuXG5cbiAgdmFyIHRyYW5zaXRpb25zID0gcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucztcbiAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IG51bGw7XG4gIHZhciByb290ID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHM7XG4gIHZhciBsYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzO1xuICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7IC8vIFRPRE86IFRoaXMgaXMgc29tZXRpbWVzIG91dCBvZiBzeW5jIHdpdGggcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMuXG4gIC8vIEZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuIEl0J3Mgbm90IGNhdXNpbmcgYW55IGtub3duIGlzc3VlcyAocHJvYmFibHlcbiAgLy8gYmVjYXVzZSBpdCdzIG9ubHkgdXNlZCBmb3IgcHJvZmlsaW5nKSwgYnV0IGl0J3MgYSByZWZhY3RvciBoYXphcmQuXG5cbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuJyk7XG4gIH1cblxuICB7XG4gICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyhyb290LmN1cnJlbnQpO1xuICBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3QsIHJvb3QuY3VycmVudCwgbGFuZXMsIHRyYW5zaXRpb25zKTsgLy8gVE9ETzogTW92ZSB0byBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzXG5cbiAge1xuICAgIHZhciBwcm9maWxlckVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cztcbiAgICBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9maWxlckVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfZmliZXIgPSBwcm9maWxlckVmZmVjdHNbaV07XG4gICAgICBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKHJvb3QsIF9maWJlcik7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgfVxuXG4gIHtcbiAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdC5jdXJyZW50LCB0cnVlKTtcbiAgfVxuXG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgZmx1c2hTeW5jQ2FsbGJhY2tzKCk7XG5cbiAge1xuICAgIC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gICAgLy8gZXhjZWVkcyB0aGUgbGltaXQsIHdlJ2xsIGZpcmUgYSB3YXJuaW5nLlxuICAgIGlmIChkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBpZiAocm9vdCA9PT0gcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcykge1xuICAgICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSByb290O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgIH1cblxuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgfSAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuXG4gIG9uUG9zdENvbW1pdFJvb3Qocm9vdCk7XG5cbiAge1xuICAgIHZhciBzdGF0ZU5vZGUgPSByb290LmN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuICByZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgIT09IG51bGwgJiYgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yKGVycm9yKSB7XG4gIGlmICghaGFzVW5jYXVnaHRFcnJvcikge1xuICAgIGhhc1VuY2F1Z2h0RXJyb3IgPSB0cnVlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbnZhciBvblVuY2F1Z2h0RXJyb3IgPSBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3I7XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHVwZGF0ZSk7XG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qocm9vdEZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3Ioc291cmNlRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yJDEpIHtcbiAge1xuICAgIHJlcG9ydFVuY2F1Z2h0RXJyb3JJbkRFVihlcnJvciQxKTtcbiAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO1xuICB9XG5cbiAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBFcnJvciB3YXMgdGhyb3duIGF0IHRoZSByb290LiBUaGVyZSBpcyBubyBwYXJlbnQsIHNvIHRoZSByb290XG4gICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IkMSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gbnVsbDtcblxuICB7XG4gICAgZmliZXIgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yO1xuICB9XG5cbiAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KGZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IkMSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciQxLCBzb3VyY2VGaWJlcik7XG4gICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICAgICAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lLCBldmVudFRpbWUpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIC8vIFRPRE86IFVudGlsIHdlIHJlLWxhbmQgc2tpcFVubW91bnRlZEJvdW5kYXJpZXMgKHNlZSAjMjAxNDcpLCB0aGlzIHdhcm5pbmdcbiAgICAvLyB3aWxsIGZpcmUgZm9yIGVycm9ycyB0aGF0IGFyZSB0aHJvd24gYnkgZGVzdHJveSBmdW5jdGlvbnMgaW5zaWRlIGRlbGV0ZWRcbiAgICAvLyB0cmVlcy4gV2hhdCBpdCBzaG91bGQgaW5zdGVhZCBkbyBpcyBwcm9wYWdhdGUgdGhlIGVycm9yIHRvIHRoZSBwYXJlbnQgb2ZcbiAgICAvLyB0aGUgZGVsZXRlZCB0cmVlLiBJbiB0aGUgbWVhbnRpbWUsIGRvIG5vdCBhZGQgdGhpcyB3YXJuaW5nIHRvIHRoZVxuICAgIC8vIGFsbG93bGlzdDsgdGhpcyBpcyBvbmx5IGZvciBvdXIgaW50ZXJuYWwgdXNlLlxuICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQXR0ZW1wdGVkIHRvIGNhcHR1cmUgYSBjb21taXQgcGhhc2UgZXJyb3IgJyArICdpbnNpZGUgYSBkZXRhY2hlZCB0cmVlLiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4gTGlrZWx5ICcgKyAnY2F1c2VzIGluY2x1ZGUgZGVsZXRpbmcgdGhlIHNhbWUgZmliZXIgbW9yZSB0aGFuIG9uY2UsIGNvbW1pdHRpbmcgYW4gJyArICdhbHJlYWR5LWZpbmlzaGVkIHRyZWUsIG9yIGFuIGluY29uc2lzdGVudCByZXR1cm4gcG9pbnRlci5cXG5cXG4nICsgJ0Vycm9yIG1lc3NhZ2U6XFxuXFxuJXMnLCBlcnJvciQxKTtcbiAgfVxufVxuZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCwgd2FrZWFibGUsIHBpbmdlZExhbmVzKSB7XG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcblxuICBpZiAocGluZ0NhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcyk7XG4gIHdhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWKHJvb3QpO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiYgaXNTdWJzZXRPZkxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCBwaW5nZWRMYW5lcykpIHtcbiAgICAvLyBSZWNlaXZlZCBhIHBpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHkgbGV2ZWwgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5XG4gICAgLy8gcmVuZGVyaW5nLiBXZSBtaWdodCB3YW50IHRvIHJlc3RhcnQgdGhpcyByZW5kZXIuIFRoaXMgc2hvdWxkIG1pcnJvclxuICAgIC8vIHRoZSBsb2dpYyBvZiB3aGV0aGVyIG9yIG5vdCBhIHJvb3Qgc3VzcGVuZHMgb25jZSBpdCBjb21wbGV0ZXMuXG4gICAgLy8gVE9ETzogSWYgd2UncmUgcmVuZGVyaW5nIHN5bmMgZWl0aGVyIGR1ZSB0byBTeW5jLCBCYXRjaGVkIG9yIGV4cGlyZWQsXG4gICAgLy8gd2Ugc2hvdWxkIHByb2JhYmx5IG5ldmVyIHJlc3RhcnQuXG4gICAgLy8gSWYgd2UncmUgc3VzcGVuZGVkIHdpdGggZGVsYXksIG9yIGlmIGl0J3MgYSByZXRyeSwgd2UnbGwgYWx3YXlzIHN1c3BlbmRcbiAgICAvLyBzbyB3ZSBjYW4gYWx3YXlzIHJlc3RhcnQuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCAmJiBpbmNsdWRlc09ubHlSZXRyaWVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSAmJiBub3coKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUykge1xuICAgICAgLy8gUmVzdGFydCBmcm9tIHRoZSByb290LlxuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbiAgICAgIC8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICB9XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbn1cblxuZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG4gIC8vIHByZXZpb3VzbHkgd2FzIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0XG4gIC8vIHN1c3BlbmRlZCBpdCBoYXMgcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzXG4gIC8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGxhbmVzLlxuICBpZiAocmV0cnlMYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBUT0RPOiBBc3NpZ24gdGhpcyB0byBgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmVgPyB0byBhdm9pZFxuICAgIC8vIHVubmVjZXNzYXJ5IGVudGFuZ2xlbWVudD9cbiAgICByZXRyeUxhbmUgPSByZXF1ZXN0UmV0cnlMYW5lKGJvdW5kYXJ5RmliZXIpO1xuICB9IC8vIFRPRE86IFNwZWNpYWwgY2FzZSBpZGxlIHByaW9yaXR5P1xuXG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHJldHJ5TGFuZSwgZXZlbnRUaW1lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICByZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJldHJ5V2FrZWFibGUoYm91bmRhcnlGaWJlciwgd2FrZWFibGUpIHtcbiAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTsgLy8gRGVmYXVsdFxuXG4gIHZhciByZXRyeUNhY2hlO1xuXG4gIHN3aXRjaCAoYm91bmRhcnlGaWJlci50YWcpIHtcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiAnICsgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocmV0cnlDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHJldHJ5Q2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufSAvLyBDb21wdXRlcyB0aGUgbmV4dCBKdXN0IE5vdGljZWFibGUgRGlmZmVyZW5jZSAoSk5EKSBib3VuZGFyeS5cbi8vIFRoZSB0aGVvcnkgaXMgdGhhdCBhIHBlcnNvbiBjYW4ndCB0ZWxsIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS5cbi8vIFRoZXJlZm9yZSwgaWYgd2Ugd2FpdCBhIGJpdCBsb25nZXIgdGhhbiBuZWNlc3NhcnkgdGhhdCB3b24ndCB0cmFuc2xhdGUgdG8gYSBub3RpY2VhYmxlXG4vLyBkaWZmZXJlbmNlIGluIHRoZSBleHBlcmllbmNlLiBIb3dldmVyLCB3YWl0aW5nIGZvciBsb25nZXIgbWlnaHQgbWVhbiB0aGF0IHdlIGNhbiBhdm9pZFxuLy8gc2hvd2luZyBhbiBpbnRlcm1lZGlhdGUgbG9hZGluZyBzdGF0ZS4gVGhlIGxvbmdlciB3ZSBoYXZlIGFscmVhZHkgd2FpdGVkLCB0aGUgaGFyZGVyIGl0XG4vLyBpcyB0byB0ZWxsIHNtYWxsIGRpZmZlcmVuY2VzIGluIHRpbWUuIFRoZXJlZm9yZSwgdGhlIGxvbmdlciB3ZSd2ZSBhbHJlYWR5IHdhaXRlZCxcbi8vIHRoZSBsb25nZXIgd2UgY2FuIHdhaXQgYWRkaXRpb25hbGx5LiBBdCBzb21lIHBvaW50IHdlIGhhdmUgdG8gZ2l2ZSB1cCB0aG91Z2guXG4vLyBXZSBwaWNrIGEgdHJhaW4gbW9kZWwgd2hlcmUgdGhlIG5leHQgYm91bmRhcnkgY29tbWl0cyBhdCBhIGNvbnNpc3RlbnQgc2NoZWR1bGUuXG4vLyBUaGVzZSBwYXJ0aWN1bGFyIG51bWJlcnMgYXJlIHZhZ3VlIGVzdGltYXRlcy4gV2UgZXhwZWN0IHRvIGFkanVzdCB0aGVtIGJhc2VkIG9uIHJlc2VhcmNoLlxuXG5mdW5jdGlvbiBqbmQodGltZUVsYXBzZWQpIHtcbiAgcmV0dXJuIHRpbWVFbGFwc2VkIDwgMTIwID8gMTIwIDogdGltZUVsYXBzZWQgPCA0ODAgPyA0ODAgOiB0aW1lRWxhcHNlZCA8IDEwODAgPyAxMDgwIDogdGltZUVsYXBzZWQgPCAxOTIwID8gMTkyMCA6IHRpbWVFbGFwc2VkIDwgMzAwMCA/IDMwMDAgOiB0aW1lRWxhcHNlZCA8IDQzMjAgPyA0MzIwIDogY2VpbCh0aW1lRWxhcHNlZCAvIDE5NjApICogMTk2MDtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCkge1xuICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArICdyZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byAnICsgJ3ByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA+IE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCkge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuXG4gICAgICBlcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcgKyBcImNhbGxzIHNldFN0YXRlIGluc2lkZSB1c2VFZmZlY3QsIGJ1dCB1c2VFZmZlY3QgZWl0aGVyIGRvZXNuJ3QgXCIgKyAnaGF2ZSBhIGRlcGVuZGVuY3kgYXJyYXksIG9yIG9uZSBvZiB0aGUgZGVwZW5kZW5jaWVzIGNoYW5nZXMgb24gJyArICdldmVyeSByZW5kZXIuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFVigpIHtcbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTtcblxuICAgIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihmaWJlciwgaGFzUGFzc2l2ZUVmZmVjdHMpIHtcbiAge1xuICAgIC8vIFRPRE8gKFN0cmljdEVmZmVjdHMpIFNob3VsZCB3ZSBzZXQgYSBtYXJrZXIgb24gdGhlIHJvb3QgaWYgaXQgY29udGFpbnMgc3RyaWN0IGVmZmVjdHNcbiAgICAvLyBzbyB3ZSBkb24ndCB0cmF2ZXJzZSB1bm5lY2Vzc2FyaWx5PyBzaW1pbGFyIHRvIHN1YnRyZWVGbGFncyBidXQganVzdCBhdCB0aGUgcm9vdCBsZXZlbC5cbiAgICAvLyBNYXliZSBub3QgYSBiaWcgZGVhbCBzaW5jZSB0aGlzIGlzIERFViBvbmx5IGJlaGF2aW9yLlxuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudExheW91dERldiwgaW52b2tlTGF5b3V0RWZmZWN0VW5tb3VudEluREVWKTtcblxuICAgIGlmIChoYXNQYXNzaXZlRWZmZWN0cykge1xuICAgICAgaW52b2tlRWZmZWN0c0luRGV2KGZpYmVyLCBNb3VudFBhc3NpdmVEZXYsIGludm9rZVBhc3NpdmVFZmZlY3RVbm1vdW50SW5ERVYpO1xuICAgIH1cblxuICAgIGludm9rZUVmZmVjdHNJbkRldihmaWJlciwgTW91bnRMYXlvdXREZXYsIGludm9rZUxheW91dEVmZmVjdE1vdW50SW5ERVYpO1xuXG4gICAgaWYgKGhhc1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBpbnZva2VFZmZlY3RzSW5EZXYoZmliZXIsIE1vdW50UGFzc2l2ZURldiwgaW52b2tlUGFzc2l2ZUVmZmVjdE1vdW50SW5ERVYpO1xuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlRWZmZWN0c0luRGV2KGZpcnN0Q2hpbGQsIGZpYmVyRmxhZ3MsIGludm9rZUVmZmVjdEZuKSB7XG4gIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlLWNoZWNrIFN0cmljdEVmZmVjdHNNb2RlIGhlcmUuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpZiB0aGF0IGNoZWNrIGhhcyBhbHJlYWR5IHBhc3NlZC5cbiAgICB2YXIgY3VycmVudCA9IGZpcnN0Q2hpbGQ7XG4gICAgdmFyIHN1YnRyZWVSb290ID0gbnVsbDtcblxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJpbWFyeVN1YnRyZWVGbGFnID0gY3VycmVudC5zdWJ0cmVlRmxhZ3MgJiBmaWJlckZsYWdzO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gc3VidHJlZVJvb3QgJiYgY3VycmVudC5jaGlsZCAhPT0gbnVsbCAmJiBwcmltYXJ5U3VidHJlZUZsYWcgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBmaWJlckZsYWdzKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIGludm9rZUVmZmVjdEZuKGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudCA9IHN1YnRyZWVSb290ID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG4gICAgaWYgKHRhZyAhPT0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCAmJiB0YWcgIT09IEhvc3RSb290ICYmIHRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgdGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiB0YWcgIT09IEZvcndhcmRSZWYgJiYgdGFnICE9PSBNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCkge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBiZWdpbldvcmskMTtcblxue1xuICB2YXIgZHVtbXlGaWJlciA9IG51bGw7XG5cbiAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbiAgICAvLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4gICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuICAgIC8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG4gICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgIH0gLy8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTsgLy8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbiAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG4gICAgICAvLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxuXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgdW5pdE9mV29yayk7IC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuXG4gICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cbiAgICAgIGlmICggdW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICB9IC8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5cblxuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGJlZ2luV29yaywgbnVsbCwgY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICB2YXIgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYXlFcnJvciA9PT0gJ29iamVjdCcgJiYgcmVwbGF5RXJyb3IgIT09IG51bGwgJiYgcmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZyAmJiB0eXBlb2Ygb3JpZ2luYWxFcnJvciA9PT0gJ29iamVjdCcgJiYgb3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiAhb3JpZ2luYWxFcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICAgICAgLy8gSWYgc3VwcHJlc3NlZCwgbGV0IHRoZSBmbGFnIGNhcnJ5IG92ZXIgdG8gdGhlIG9yaWdpbmFsIGVycm9yIHdoaWNoIGlzIHRoZSBvbmUgd2UnbGwgcmV0aHJvdy5cbiAgICAgICAgICBvcmlnaW5hbEVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlIGFsd2F5cyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gY2FzZSB0aGUgc2Vjb25kIHJlbmRlciBwYXNzIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIGEgbWVtb2l6ZWQgZnVuY3Rpb24gb3IgQ29tbW9uSlMgbW9kdWxlIGRvZXNuJ3QgdGhyb3cgYWZ0ZXIgZmlyc3QgaW52b2NhdGlvbi5cblxuXG4gICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiAhZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDb21wb25lbnROYW1lID0gd29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgJyArICdkaWZmZXJlbnQgY29tcG9uZW50IChgJXNgKS4gVG8gbG9jYXRlIHRoZSBiYWQgc2V0U3RhdGUoKSBjYWxsIGluc2lkZSBgJXNgLCAnICsgJ2ZvbGxvdyB0aGUgc3RhY2sgdHJhY2UgYXMgZGVzY3JpYmVkIGluIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXInLCBzZXRTdGF0ZUNvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSAnICsgJ2Z1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4nKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcykge1xuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgIG1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBzY2hlZHVsaW5nRmliZXIsIGxhbmVzKTtcbiAgICAgIH0pOyAvLyBUaGlzIGZ1bmN0aW9uIGludGVudGlvbmFsbHkgZG9lcyBub3QgY2xlYXIgbWVtb2l6ZWQgdXBkYXRlcnMuXG4gICAgICAvLyBUaG9zZSBtYXkgc3RpbGwgYmUgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgY29tbWl0XG4gICAgICAvLyBhbmQgYSBmdXR1cmUgb25lIChlLmcuIFN1c3BlbnNlKS5cbiAgICB9XG4gIH1cbn1cbnZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlID0ge307XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2skMShwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICB7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhbiBgYWN0YCBzY29wZSwgYnlwYXNzIFNjaGVkdWxlciBhbmQgcHVzaCB0b1xuICAgIC8vIHRoZSBgYWN0YCBxdWV1ZSBpbnN0ZWFkLlxuICAgIHZhciBhY3RRdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudDtcblxuICAgIGlmIChhY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgYWN0UXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayQxKGNhbGxiYWNrTm9kZSkge1xuICBpZiAoIGNhbGxiYWNrTm9kZSA9PT0gZmFrZUFjdENhbGxiYWNrTm9kZSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBJbiBwcm9kdWN0aW9uLCBhbHdheXMgY2FsbCBTY2hlZHVsZXIuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBzdHJpcHBlZCBvdXQuXG5cblxuICByZXR1cm4gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkge1xuICAvLyBOZXZlciBmb3JjZSBmbHVzaCBpbiBwcm9kdWN0aW9uLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBnZXQgc3RyaXBwZWQgb3V0LlxuICByZXR1cm4gIFJlYWN0Q3VycmVudEFjdFF1ZXVlJDEuY3VycmVudCAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICBpZiAoIWlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkpIHtcbiAgICAgICAgLy8gTm90IGluIGFuIGFjdCBlbnZpcm9ubWVudC4gTm8gbmVlZCB0byB3YXJuLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlZ2FjeSBtb2RlIGhhcyBhZGRpdGlvbmFsIGNhc2VzIHdoZXJlIHdlIHN1cHByZXNzIGEgd2FybmluZy5cbiAgICAgIGlmICghaXNMZWdhY3lBY3RFbnZpcm9ubWVudCgpKSB7XG4gICAgICAgIC8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIExlZ2FjeSBtb2RlIGRvZXNuJ3Qgd2FybiBpZiB0aGUgdXBkYXRlIGlzIGJhdGNoZWQsIGkuZS5cbiAgICAgICAgLy8gYmF0Y2hlZFVwZGF0ZXMgb3IgZmx1c2hTeW5jLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWJlci50YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIGZpYmVyLnRhZyAhPT0gRm9yd2FyZFJlZiAmJiBmaWJlci50YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggcHJlLWhvb2tzIGNvZGUsIGxlZ2FjeSBtb2RlIG9ubHlcbiAgICAgICAgLy8gd2FybnMgZm9yIHVwZGF0ZXMgdGhhdCBvcmlnaW5hdGUgZnJvbSBhIGhvb2suXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSAnICsgJ3dyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0JywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYocm9vdCkge1xuICB7XG4gICAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiYgUmVhY3RDdXJyZW50QWN0UXVldWUkMS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50ICcgKyAnd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgJyArICdpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGlzUnVubmluZykge1xuICB7XG4gICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gaXNSdW5uaW5nO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXMgKi9cbnZhciByZXNvbHZlRmFtaWx5ID0gbnVsbDsgLy8gJEZsb3dGaXhNZSBGbG93IGdldHMgY29uZnVzZWQgYnkgYSBXZWFrU2V0IGZlYXR1cmUgY2hlY2sgYmVsb3cuXG5cbnZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbnZhciBzZXRSZWZyZXNoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gIHtcbiAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIC8vIE5vIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxuICByZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgcmVhbCBmb3J3YXJkUmVmLiBEb24ndCB3YW50IHRvIGNyYXNoIGVhcmx5LlxuICAgICAgaWYgKHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuICAgICAgICAvLyBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIG9ubHkgaGF2ZSBpdHMgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGluIHRoZSBtYXAuXG4gICAgICAgIC8vIElmIHRoYXQgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCwgd2UnbGwgYnVpbGQgYSBuZXcgZm9yd2FyZFJlZiB0eXBlLlxuICAgICAgICB2YXIgY3VycmVudFJlbmRlciA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7XG5cbiAgICAgICAgaWYgKHR5cGUucmVuZGVyICE9PSBjdXJyZW50UmVuZGVyKSB7XG4gICAgICAgICAgdmFyIHN5bnRoZXRpY1R5cGUgPSB7XG4gICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICAgICAgICAgIHJlbmRlcjogY3VycmVudFJlbmRlclxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNUeXBlLmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3ludGhldGljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHByZXZUeXBlID0gZmliZXIuZWxlbWVudFR5cGU7XG4gICAgdmFyIG5leHRUeXBlID0gZWxlbWVudC50eXBlOyAvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxuXG4gICAgdmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gZmFsc2U7XG4gICAgdmFyICQkdHlwZW9mTmV4dFR5cGUgPSB0eXBlb2YgbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIG5leHRUeXBlICE9PSBudWxsID8gbmV4dFR5cGUuJCR0eXBlb2YgOiBudWxsO1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgaW5uZXIgdHlwZSB5ZXQuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBhc3N1bWUgdGhhdCB0aGUgbGF6eSBpbm5lciB0eXBlIGlzIHN0YWJsZSxcbiAgICAgICAgICAgIC8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gdW53cmFwIG9yIGFjdHVhbGx5IHVzZSB0aGUgbmV3IGxhenkgdHlwZS5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgaXQgd2FzIGJ1dCBjYW4gbm8gbG9uZ2VyIGJlIHNpbXBsZSxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBzZXQgdGhpcy5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIGlmIGJvdGggdHlwZXMgaGF2ZSBhIGZhbWlseSBhbmQgaXQncyB0aGUgc2FtZSBvbmUuXG5cblxuICAgIGlmIChuZWVkc0NvbXBhcmVGYW1pbGllcykge1xuICAgICAgLy8gTm90ZTogbWVtbygpIGFuZCBmb3J3YXJkUmVmKCkgd2UnbGwgY29tcGFyZSBvdXRlciByYXRoZXIgdGhhbiBpbm5lciB0eXBlLlxuICAgICAgLy8gVGhpcyBtZWFucyBib3RoIG9mIHRoZW0gbmVlZCB0byBiZSByZWdpc3RlcmVkIHRvIHByZXNlcnZlIHN0YXRlLlxuICAgICAgLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG4gICAgICAvLyB0aGVuIHdlIHdvdWxkIHJpc2sgZmFsc2VseSBzYXlpbmcgdHdvIHNlcGFyYXRlIG1lbW8oRm9vKVxuICAgICAgLy8gY2FsbHMgYXJlIGVxdWl2YWxlbnQgYmVjYXVzZSB0aGV5IHdyYXAgdGhlIHNhbWUgRm9vIGZ1bmN0aW9uLlxuICAgICAgdmFyIHByZXZGYW1pbHkgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKTtcblxuICAgICAgaWYgKHByZXZGYW1pbHkgIT09IHVuZGVmaW5lZCAmJiBwcmV2RmFtaWx5ID09PSByZXNvbHZlRmFtaWx5KG5leHRUeXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFdlYWtTZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpO1xuICB9XG59XG52YXIgc2NoZWR1bGVSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIHVwZGF0ZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcyxcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHNjaGVkdWxlUm9vdCA9IGZ1bmN0aW9uIChyb290LCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdC5jb250ZXh0ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIC8vIFN1cGVyIGVkZ2UgY2FzZTogcm9vdCBoYXMgYSBsZWdhY3kgX3JlbmRlclN1YnRyZWUgY29udGV4dFxuICAgICAgLy8gYnV0IHdlIGRvbid0IGtub3cgdGhlIHBhcmVudENvbXBvbmVudCBzbyB3ZSBjYW4ndCBwYXNzIGl0LlxuICAgICAgLy8gSnVzdCBpZ25vcmUuIFdlJ2xsIGRlbGV0ZSB0aGlzIHdpdGggX3JlbmRlclN1YnRyZWUgY29kZSBwYXRoIGxhdGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGZpYmVyLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGUsXG4gICAgICAgIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRzUmVuZGVyID0gZmFsc2U7XG4gICAgdmFyIG5lZWRzUmVtb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpO1xuXG4gICAgICBpZiAoZmFtaWx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0YWxlRmFtaWxpZXMuaGFzKGZhbWlseSkpIHtcbiAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIGlmICh0YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkc1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwpIHtcbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50KSB7XG4gICAgICBmaWJlci5fZGVidWdOZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQgfHwgbmVlZHNSZW5kZXIpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgIW5lZWRzUmVtb3VudCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShjaGlsZCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShzaWJsaW5nLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIGZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgaG9zdEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdHlwZXMgPSBuZXcgU2V0KGZhbWlsaWVzLm1hcChmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gICAgfSkpO1xuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICByZXR1cm4gaG9zdEluc3RhbmNlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLCB0eXBlcywgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGRpZE1hdGNoID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVzLmhhcyhjYW5kaWRhdGVUeXBlKSkge1xuICAgICAgICBkaWRNYXRjaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZE1hdGNoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoIGRlZXBlciBiZWNhdXNlIGZvciB0aGUgcHVycG9zZSBvZiBnaXZpbmdcbiAgICAgIC8vIHZpc3VhbCBmZWVkYmFjaywgXCJmbGFzaGluZ1wiIG91dGVybW9zdCBwYXJlbnQgcmVjdGFuZ2xlcyBpcyBzdWZmaWNpZW50LlxuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2gsIG1heWJlIHRoZXJlIHdpbGwgYmUgb25lIGZ1cnRoZXIgZG93biBpbiB0aGUgY2hpbGQgdHJlZS5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoY2hpbGQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG5cbiAgICBpZiAoZm91bmRIb3N0SW5zdGFuY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgaG9zdCBjaGlsZHJlbiwgZmFsbGJhY2sgdG8gY2xvc2VzdCBob3N0IHBhcmVudC5cblxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHJlYWNoIHJvb3QgZmlyc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbWF0Y2guXG4gICAgICAgIGZvdW5kSG9zdEluc3RhbmNlcyA9IHRydWU7XG4gICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTsgLy8gVGhlcmUgbWF5IHN0aWxsIGJlIG1vcmUsIHNvIGtlZXAgc2VhcmNoaW5nLlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmVsZW1lbnRUeXBlID0gbnVsbDtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsOyAvLyBGaWJlclxuXG4gIHRoaXMucmV0dXJuID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLnJlZiA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgdGhpcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICB0aGlzLm1vZGUgPSBtb2RlOyAvLyBFZmZlY3RzXG5cbiAgdGhpcy5mbGFncyA9IE5vRmxhZ3M7XG4gIHRoaXMuc3VidHJlZUZsYWdzID0gTm9GbGFncztcbiAgdGhpcy5kZWxldGlvbnMgPSBudWxsO1xuICB0aGlzLmxhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIHtcbiAgICAvLyBOb3RlOiBUaGUgZm9sbG93aW5nIGlzIGRvbmUgdG8gYXZvaWQgYSB2OCBwZXJmb3JtYW5jZSBjbGlmZi5cbiAgICAvL1xuICAgIC8vIEluaXRpYWxpemluZyB0aGUgZmllbGRzIGJlbG93IHRvIHNtaXMgYW5kIGxhdGVyIHVwZGF0aW5nIHRoZW0gd2l0aFxuICAgIC8vIGRvdWJsZSB2YWx1ZXMgd2lsbCBjYXVzZSBGaWJlcnMgdG8gZW5kIHVwIGhhdmluZyBzZXBhcmF0ZSBzaGFwZXMuXG4gICAgLy8gVGhpcyBiZWhhdmlvci9idWcgaGFzIHNvbWV0aGluZyB0byBkbyB3aXRoIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9uKCkuXG4gICAgLy8gRm9ydHVuYXRlbHkgdGhpcyBvbmx5IGltcGFjdHMgREVWIGJ1aWxkcy5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IGl0IG1ha2VzIFJlYWN0IHVudXNhYmx5IHNsb3cgZm9yIHNvbWUgYXBwbGljYXRpb25zLlxuICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIGluaXRpYWxpemUgdGhlIGZpZWxkcyBiZWxvdyB3aXRoIGRvdWJsZXMuXG4gICAgLy9cbiAgICAvLyBMZWFybiBtb3JlIGFib3V0IHRoaXMgaGVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MzY1XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9ODUzOFxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47IC8vIEl0J3Mgb2theSB0byByZXBsYWNlIHRoZSBpbml0aWFsIGRvdWJsZXMgd2l0aCBzbWlzIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICAgIC8vIFRoaXMgd29uJ3QgdHJpZ2dlciB0aGUgcGVyZm9ybWFuY2UgY2xpZmYgbWVudGlvbmVkIGFib3ZlLFxuICAgIC8vIGFuZCBpdCBzaW1wbGlmaWVzIG90aGVyIHByb2ZpbGVyIGNvZGUgKGluY2x1ZGluZyBEZXZUb29scykuXG5cbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHtcbiAgICAvLyBUaGlzIGlzbid0IGRpcmVjdGx5IHVzZWQgYnV0IGlzIGhhbmR5IGZvciBkZWJ1Z2dpbmcgaW50ZXJuYWxzOlxuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2RlYnVnSG9va1R5cGVzID0gbnVsbDtcblxuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufSAvLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cblxuXG52YXIgY3JlYXRlRmliZXIgPSBmdW5jdGlvbiAodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyAkRmxvd0ZpeE1lOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcbiAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmICFzaG91bGRDb25zdHJ1Y3QkMSh0eXBlKSAmJiB0eXBlLmRlZmF1bHRQcm9wcyA9PT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUxhenlDb21wb25lbnRUYWcoQ29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkgPyBDbGFzc0NvbXBvbmVudCA6IEZ1bmN0aW9uQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKENvbXBvbmVudCAhPT0gdW5kZWZpbmVkICYmIENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IENvbXBvbmVudC4kJHR5cGVvZjtcblxuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgcmV0dXJuIEZvcndhcmRSZWY7XG4gICAgfVxuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIHJldHVybiBNZW1vQ29tcG9uZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBJbmRldGVybWluYXRlQ29tcG9uZW50O1xufSAvLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgcGVuZGluZ1Byb3BzLCBjdXJyZW50LmtleSwgY3VycmVudC5tb2RlKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9IGN1cnJlbnQuZWxlbWVudFR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIC8vIERFVi1vbmx5IGZpZWxkc1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlID0gY3VycmVudC5fZGVidWdTb3VyY2U7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcztcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzOyAvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTsgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gTm9GbGFnczsgLy8gVGhlIGVmZmVjdHMgYXJlIG5vIGxvbmdlciB2YWxpZC5cblxuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3M7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgcmVzZXQsIHJhdGhlciB0aGFuIGNvcHksIGFjdHVhbER1cmF0aW9uICYgYWN0dWFsU3RhcnRUaW1lLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aW1lIGZyb20gZW5kbGVzc2x5IGFjY3VtdWxhdGluZyBpbiBuZXcgY29tbWl0cy5cbiAgICAgIC8vIFRoaXMgaGFzIHRoZSBkb3duc2lkZSBvZiByZXNldHRpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgcHJpb3JpdHkgcmVuZGVycyxcbiAgICAgIC8vIEJ1dCB3b3JrcyBmb3IgeWllbGRpbmcgKHRoZSBjb21tb24gY2FzZSkgYW5kIHNob3VsZCBzdXBwb3J0IHJlc3VtaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgfVxuICB9IC8vIFJlc2V0IGFsbCBlZmZlY3RzIGV4Y2VwdCBzdGF0aWMgb25lcy5cbiAgLy8gU3RhdGljIGVmZmVjdHMgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlci5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzID0gY3VycmVudC5mbGFncyAmIFN0YXRpY01hc2s7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcbiAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gIH07IC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG5cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICB9XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGN1cnJlbnQuX2RlYnVnTmVlZHNSZW1vdW50O1xuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn0gLy8gVXNlZCB0byByZXVzZSBhIEZpYmVyIGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIHJlc2V0cyB0aGUgRmliZXIgdG8gd2hhdCBjcmVhdGVGaWJlciBvciBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZFxuICAvLyBoYXZlIHNldCB0aGUgdmFsdWVzIHRvIGJlZm9yZSBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIElkZWFsbHkgdGhpcyB3b3VsZG4ndFxuICAvLyBiZSBuZWNlc3NhcnkgYnV0IHVuZm9ydHVuYXRlbHkgbWFueSBjb2RlIHBhdGhzIHJlYWRzIGZyb20gdGhlIHdvcmtJblByb2dyZXNzXG4gIC8vIHdoZW4gdGhleSBzaG91bGQgYmUgcmVhZGluZyBmcm9tIGN1cnJlbnQgYW5kIHdyaXRpbmcgdG8gd29ya0luUHJvZ3Jlc3MuXG4gIC8vIFdlIGFzc3VtZSBwZW5kaW5nUHJvcHMsIGluZGV4LCBrZXksIHJlZiwgcmV0dXJuIGFyZSBzdGlsbCB1bnRvdWNoZWQgdG9cbiAgLy8gYXZvaWQgZG9pbmcgYW5vdGhlciByZWNvbmNpbGlhdGlvbi5cbiAgLy8gUmVzZXQgdGhlIGVmZmVjdCBmbGFncyBidXQga2VlcCBhbnkgUGxhY2VtZW50IHRhZ3MsIHNpbmNlIHRoYXQncyBzb21ldGhpbmdcbiAgLy8gdGhhdCBjaGlsZCBmaWJlciBpcyBzZXR0aW5nLCBub3QgdGhlIHJlY29uY2lsaWF0aW9uLlxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSBTdGF0aWNNYXNrIHwgUGxhY2VtZW50OyAvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gUmVzZXQgdG8gY3JlYXRlRmliZXIncyBpbml0aWFsIHZhbHVlcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgdG8gdGhlIGNsb25lZCB2YWx1ZXMgdGhhdCBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZCd2ZS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAgIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuICAgIHZhciBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcbiAgICAgIGZpcnN0Q29udGV4dDogY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHRcbiAgICB9O1xuXG4gICAge1xuICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG4gICAgICAvLyBhY3R1YWwgdGltZSBhY3Jvc3MgbXVsdGlwbGUgcmVuZGVyIHBhc3Nlcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIodGFnLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUpIHtcbiAgdmFyIG1vZGU7XG5cbiAgaWYgKHRhZyA9PT0gQ29uY3VycmVudFJvb3QpIHtcbiAgICBtb2RlID0gQ29uY3VycmVudE1vZGU7XG5cbiAgICBpZiAoaXNTdHJpY3RNb2RlID09PSB0cnVlKSB7XG4gICAgICBtb2RlIHw9IFN0cmljdExlZ2FjeU1vZGU7XG5cbiAgICAgIHtcbiAgICAgICAgbW9kZSB8PSBTdHJpY3RFZmZlY3RzTW9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbW9kZSA9IE5vTW9kZTtcbiAgfVxuXG4gIGlmICggaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwgLy8gUmVhY3QkRWxlbWVudFR5cGVcbmtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyVGFnID0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDsgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG5cbiAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHNob3VsZENvbnN0cnVjdCQxKHR5cGUpKSB7XG4gICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlclRhZyA9IEhvc3RDb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IFN0cmljdExlZ2FjeU1vZGU7XG5cbiAgICAgICAgaWYgKCAobW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgLy8gU3RyaWN0IGVmZmVjdHMgc2hvdWxkIG5ldmVyIHJ1biBvbiBsZWdhY3kgcm9vdHNcbiAgICAgICAgICBtb2RlIHw9IFN0cmljdEVmZmVjdHNNb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBjYXNlIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRQcm92aWRlcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbnN1bWVyXG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEZvcndhcmRSZWY7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IE1lbW9Db21wb25lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTGF6eUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvKSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IHR5cGU7XG4gIGZpYmVyLnR5cGUgPSByZXNvbHZlZFR5cGU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG5cbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsIGtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgcGVuZGluZ1Byb3BzLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgb2YgdHlwZSBgc3RyaW5nYCBhcyBhIHByb3AuIFJlY2VpdmVkIHRoZSB0eXBlIGAlc2AgaW5zdGVhZC4nLCB0eXBlb2YgcGVuZGluZ1Byb3BzLmlkKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihQcm9maWxlciwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUgfCBQcm9maWxlTW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgICAgZWZmZWN0RHVyYXRpb246IDAsXG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlTGlzdENvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihPZmZzY3JlZW5Db21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgdmFyIHByaW1hcnlDaGlsZEluc3RhbmNlID0ge307XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoZGVoeWRyYXRlZE5vZGUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRGVoeWRyYXRlZEZyYWdtZW50LCBudWxsLCBudWxsLCBOb01vZGUpO1xuICBmaWJlci5zdGF0ZU5vZGUgPSBkZWh5ZHJhdGVkTm9kZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiAhPT0gbnVsbCA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59IC8vIFVzZWQgZm9yIHN0YXNoaW5nIFdJUCBwcm9wZXJ0aWVzIHRvIHJlcGxheSBmYWlsZWQgd29yayBpbiBERVYuXG5cbmZ1bmN0aW9uIGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHRhcmdldCwgc291cmNlKSB7XG4gIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIEZpYmVyJ3MgaW5pdGlhbCBwcm9wZXJ0aWVzIHdpbGwgYWx3YXlzIGJlIG92ZXJ3cml0dGVuLlxuICAgIC8vIFdlIG9ubHkgdXNlIGEgRmliZXIgdG8gZW5zdXJlIHRoZSBzYW1lIGhpZGRlbiBjbGFzcyBzbyBERVYgaXNuJ3Qgc2xvdy5cbiAgICB0YXJnZXQgPSBjcmVhdGVGaWJlcihJbmRldGVybWluYXRlQ29tcG9uZW50LCBudWxsLCBudWxsLCBOb01vZGUpO1xuICB9IC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIGFzIGEgbGlzdCBvZiBhbGwgcHJvcGVydGllcy5cbiAgLy8gV2UgdHJpZWQgdG8gdXNlIE9iamVjdC5hc3NpZ24oKSBpbnN0ZWFkIGJ1dCB0aGlzIGlzIGNhbGxlZCBpblxuICAvLyB0aGUgaG90dGVzdCBwYXRoLCBhbmQgT2JqZWN0LmFzc2lnbigpIHdhcyB0b28gc2xvdzpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwMlxuICAvLyBUaGlzIGNvZGUgaXMgREVWLW9ubHkgc28gc2l6ZSBpcyBub3QgYSBjb25jZXJuLlxuXG5cbiAgdGFyZ2V0LnRhZyA9IHNvdXJjZS50YWc7XG4gIHRhcmdldC5rZXkgPSBzb3VyY2Uua2V5O1xuICB0YXJnZXQuZWxlbWVudFR5cGUgPSBzb3VyY2UuZWxlbWVudFR5cGU7XG4gIHRhcmdldC50eXBlID0gc291cmNlLnR5cGU7XG4gIHRhcmdldC5zdGF0ZU5vZGUgPSBzb3VyY2Uuc3RhdGVOb2RlO1xuICB0YXJnZXQucmV0dXJuID0gc291cmNlLnJldHVybjtcbiAgdGFyZ2V0LmNoaWxkID0gc291cmNlLmNoaWxkO1xuICB0YXJnZXQuc2libGluZyA9IHNvdXJjZS5zaWJsaW5nO1xuICB0YXJnZXQuaW5kZXggPSBzb3VyY2UuaW5kZXg7XG4gIHRhcmdldC5yZWYgPSBzb3VyY2UucmVmO1xuICB0YXJnZXQucGVuZGluZ1Byb3BzID0gc291cmNlLnBlbmRpbmdQcm9wcztcbiAgdGFyZ2V0Lm1lbW9pemVkUHJvcHMgPSBzb3VyY2UubWVtb2l6ZWRQcm9wcztcbiAgdGFyZ2V0LnVwZGF0ZVF1ZXVlID0gc291cmNlLnVwZGF0ZVF1ZXVlO1xuICB0YXJnZXQubWVtb2l6ZWRTdGF0ZSA9IHNvdXJjZS5tZW1vaXplZFN0YXRlO1xuICB0YXJnZXQuZGVwZW5kZW5jaWVzID0gc291cmNlLmRlcGVuZGVuY2llcztcbiAgdGFyZ2V0Lm1vZGUgPSBzb3VyY2UubW9kZTtcbiAgdGFyZ2V0LmZsYWdzID0gc291cmNlLmZsYWdzO1xuICB0YXJnZXQuc3VidHJlZUZsYWdzID0gc291cmNlLnN1YnRyZWVGbGFncztcbiAgdGFyZ2V0LmRlbGV0aW9ucyA9IHNvdXJjZS5kZWxldGlvbnM7XG4gIHRhcmdldC5sYW5lcyA9IHNvdXJjZS5sYW5lcztcbiAgdGFyZ2V0LmNoaWxkTGFuZXMgPSBzb3VyY2UuY2hpbGRMYW5lcztcbiAgdGFyZ2V0LmFsdGVybmF0ZSA9IHNvdXJjZS5hbHRlcm5hdGU7XG5cbiAge1xuICAgIHRhcmdldC5hY3R1YWxEdXJhdGlvbiA9IHNvdXJjZS5hY3R1YWxEdXJhdGlvbjtcbiAgICB0YXJnZXQuYWN0dWFsU3RhcnRUaW1lID0gc291cmNlLmFjdHVhbFN0YXJ0VGltZTtcbiAgICB0YXJnZXQuc2VsZkJhc2VEdXJhdGlvbiA9IHNvdXJjZS5zZWxmQmFzZUR1cmF0aW9uO1xuICAgIHRhcmdldC50cmVlQmFzZUR1cmF0aW9uID0gc291cmNlLnRyZWVCYXNlRHVyYXRpb247XG4gIH1cblxuICB0YXJnZXQuX2RlYnVnU291cmNlID0gc291cmNlLl9kZWJ1Z1NvdXJjZTtcbiAgdGFyZ2V0Ll9kZWJ1Z093bmVyID0gc291cmNlLl9kZWJ1Z093bmVyO1xuICB0YXJnZXQuX2RlYnVnTmVlZHNSZW1vdW50ID0gc291cmNlLl9kZWJ1Z05lZWRzUmVtb3VudDtcbiAgdGFyZ2V0Ll9kZWJ1Z0hvb2tUeXBlcyA9IHNvdXJjZS5fZGVidWdIb29rVHlwZXM7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IpIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lckluZm87XG4gIHRoaXMucGVuZGluZ0NoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgdGhpcy5waW5nQ2FjaGUgPSBudWxsO1xuICB0aGlzLmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHRoaXMudGltZW91dEhhbmRsZSA9IG5vVGltZW91dDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lO1xuICB0aGlzLmV2ZW50VGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuICB0aGlzLmV4cGlyYXRpb25UaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9UaW1lc3RhbXApO1xuICB0aGlzLnBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5leHBpcmVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLm11dGFibGVSZWFkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVudGFuZ2xlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcbiAgdGhpcy5pZGVudGlmaWVyUHJlZml4ID0gaWRlbnRpZmllclByZWZpeDtcbiAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG5cbiAge1xuICAgIHRoaXMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgdGhpcy5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIHRoaXMubWVtb2l6ZWRVcGRhdGVycyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHRoaXMucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFRvdGFsTGFuZXM7IF9pKyspIHtcbiAgICAgIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAucHVzaChuZXcgU2V0KCkpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDb25jdXJyZW50Um9vdDpcbiAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9IGh5ZHJhdGUgPyAnaHlkcmF0ZVJvb3QoKScgOiAnY3JlYXRlUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTGVnYWN5Um9vdDpcbiAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9IGh5ZHJhdGUgPyAnaHlkcmF0ZSgpJyA6ICdyZW5kZXIoKSc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBpbml0aWFsQ2hpbGRyZW4sIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCAvLyBUT0RPOiBXZSBoYXZlIHNldmVyYWwgb2YgdGhlc2UgYXJndW1lbnRzIHRoYXQgYXJlIGNvbmNlcHR1YWxseSBwYXJ0IG9mIHRoZVxuLy8gaG9zdCBjb25maWcsIGJ1dCBiZWNhdXNlIHRoZXkgYXJlIHBhc3NlZCBpbiBhdCBydW50aW1lLCB3ZSBoYXZlIHRvIHRocmVhZFxuLy8gdGhlbSB0aHJvdWdoIHRoZSByb290IGNvbnN0cnVjdG9yLiBQZXJoYXBzIHdlIHNob3VsZCBwdXQgdGhlbSBhbGwgaW50byBhXG4vLyBzaW5nbGUgdHlwZSwgbGlrZSBhIER5bmFtaWNIb3N0Q29uZmlnIHRoYXQgaXMgZGVmaW5lZCBieSB0aGUgcmVuZGVyZXIuXG5pZGVudGlmaWVyUHJlZml4LCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MpIHtcbiAgdmFyIHJvb3QgPSBuZXcgRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcik7XG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG5cblxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsIGlzU3RyaWN0TW9kZSk7XG4gIHJvb3QuY3VycmVudCA9IHVuaW5pdGlhbGl6ZWRGaWJlcjtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG5cbiAge1xuICAgIHZhciBfaW5pdGlhbFN0YXRlID0ge1xuICAgICAgZWxlbWVudDogaW5pdGlhbENoaWxkcmVuLFxuICAgICAgaXNEZWh5ZHJhdGVkOiBoeWRyYXRlLFxuICAgICAgY2FjaGU6IG51bGwsXG4gICAgICAvLyBub3QgZW5hYmxlZCB5ZXRcbiAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuICAgICAgcGVuZGluZ1N1c3BlbnNlQm91bmRhcmllczogbnVsbFxuICAgIH07XG4gICAgdW5pbml0aWFsaXplZEZpYmVyLm1lbW9pemVkU3RhdGUgPSBfaW5pdGlhbFN0YXRlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHVuaW5pdGlhbGl6ZWRGaWJlcik7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE4LjEuMCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVySW5mbywgLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAge1xuICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oa2V5KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG52YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcztcbnZhciBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZTtcblxue1xuICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0ge307XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gZmliZXIudHlwZTtcblxuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgQ29tcG9uZW50LCBwYXJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBrZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhvc3RGaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciBoeWRyYXRlID0gZmFsc2U7XG4gIHZhciBpbml0aWFsQ2hpbGRyZW4gPSBudWxsO1xuICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sIC8vIFRPRE86IFJlbW92ZSBgY2FsbGJhY2tgIHdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLlxuY2FsbGJhY2ssIGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcykge1xuICB2YXIgaHlkcmF0ZSA9IHRydWU7XG4gIHZhciByb290ID0gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25SZWNvdmVyYWJsZUVycm9yKTsgLy8gVE9ETzogTW92ZSB0aGlzIHRvIEZpYmVyUm9vdCBjb25zdHJ1Y3RvclxuXG4gIHJvb3QuY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpOyAvLyBTY2hlZHVsZSB0aGUgaW5pdGlhbCByZW5kZXIuIEluIGEgaHlkcmF0aW9uIHJvb3QsIHRoaXMgaXMgZGlmZmVyZW50IGZyb21cbiAgLy8gYSByZWd1bGFyIHVwZGF0ZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0IG1hdGNoIHdhcyB3YXMgcmVuZGVyZWRcbiAgLy8gb24gdGhlIHNlcnZlci5cbiAgLy8gTk9URTogVGhpcyB1cGRhdGUgaW50ZW50aW9uYWxseSBkb2Vzbid0IGhhdmUgYSBwYXlsb2FkLiBXZSdyZSBvbmx5IHVzaW5nXG4gIC8vIHRoZSB1cGRhdGUgdG8gc2NoZWR1bGUgd29yayBvbiB0aGUgcm9vdCBmaWJlciAoYW5kLCBmb3IgbGVnYWN5IHJvb3RzLCB0b1xuICAvLyBlbnF1ZXVlIHRoZSBjYWxsYmFjayBpZiBvbmUgaXMgcHJvdmlkZWQpLlxuXG4gIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwgPyBjYWxsYmFjayA6IG51bGw7XG4gIGVucXVldWVVcGRhdGUoY3VycmVudCwgdXBkYXRlKTtcbiAgc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50JDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50JDEpO1xuXG4gIHtcbiAgICBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50XG4gIH07XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcblxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIGVucXVldWVVcGRhdGUoY3VycmVudCQxLCB1cGRhdGUpO1xuICB2YXIgcm9vdCA9IHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGN1cnJlbnQkMSwgbGFuZSk7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGdldFB1YmxpY1Jvb3RJbnN0YW5jZShjb250YWluZXIpIHtcbiAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICB9XG59XG5mdW5jdGlvbiBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24kMShmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB2YXIgcm9vdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKGlzUm9vdERlaHlkcmF0ZWQocm9vdCkpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhlIGZpcnN0IHNjaGVkdWxlZCBcInVwZGF0ZVwiLlxuICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCk7XG4gICAgICAgIGZsdXNoUm9vdChyb290LCBsYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgIH0pOyAvLyBJZiB3ZSdyZSBzdGlsbCBibG9ja2VkIGFmdGVyIHRoaXMsIHdlIG5lZWQgdG8gaW5jcmVhc2VcbiAgICAgIC8vIHRoZSBwcmlvcml0eSBvZiBhbnkgcHJvbWlzZXMgcmVzb2x2aW5nIHdpdGhpbiB0aGlzXG4gICAgICAvLyBib3VuZGFyeSBzbyB0aGF0IHRoZXkgbmV4dCBhdHRlbXB0IGFsc28gaGFzIGhpZ2hlciBwcmkuXG5cbiAgICAgIHZhciByZXRyeUxhbmUgPSBTeW5jTGFuZTtcbiAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBoaWdoZXJQcmlvcml0eUxhbmUoc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUsIHJldHJ5TGFuZSk7XG4gIH1cbn0gLy8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVuYWJsZXMgd2hlbiB0aGV5IHJlc29sdmUgd2l0aGluIHRoaXMgYm91bmRhcnkuXG5cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlKSB7XG4gICAgbWFya1JldHJ5TGFuZUltcGwoYWx0ZXJuYXRlLCByZXRyeUxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2VcbiAgICAvLyB0aGVpciBwcmlvcml0eSBhbmQgdGhleSBzaG91bGQgbm90IHN1c3BlbmQgb24gSS9PLFxuICAgIC8vIHNpbmNlIHlvdSBoYXZlIHRvIHdyYXAgYW55dGhpbmcgdGhhdCBtaWdodCBzdXNwZW5kIGluXG4gICAgLy8gU3VzcGVuc2UuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIGxhbmUgPSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO1xuICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSQxKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2VcbiAgICAvLyB0aGVpciBwcmlvcml0eSBvdGhlciB0aGFuIHN5bmNocm9ub3VzbHkgZmx1c2ggaXQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbnZhciBzaG91bGRFcnJvckltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRFcnJvcihmaWJlcikge1xuICByZXR1cm4gc2hvdWxkRXJyb3JJbXBsKGZpYmVyKTtcbn1cblxudmFyIHNob3VsZFN1c3BlbmRJbXBsID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZFN1c3BlbmQoZmliZXIpIHtcbiAgcmV0dXJuIHNob3VsZFN1c3BlbmRJbXBsKGZpYmVyKTtcbn1cbnZhciBvdmVycmlkZUhvb2tTdGF0ZSA9IG51bGw7XG52YXIgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHMgPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgc2NoZWR1bGVVcGRhdGUgPSBudWxsO1xudmFyIHNldEVycm9ySGFuZGxlciA9IG51bGw7XG52YXIgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcblxue1xuICB2YXIgY29weVdpdGhEZWxldGVJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShrZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cblxuICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhEZWxldGUgPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIDApO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFJlbmFtZUltcGwgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgIHZhciBvbGRLZXkgPSBvbGRQYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gb2xkUGF0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBuZXdLZXkgPSBuZXdQYXRoW2luZGV4XTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgICB1cGRhdGVkW25ld0tleV0gPSB1cGRhdGVkW29sZEtleV07XG5cbiAgICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICAgIHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFtvbGRLZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgICB1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZUltcGwoIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIG9ialtvbGRLZXldLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCArIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFJlbmFtZSA9IGZ1bmN0aW9uIChvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBpZiAob2xkUGF0aC5sZW5ndGggIT09IG5ld1BhdGgubGVuZ3RoKSB7XG4gICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgb2YgdGhlIHNhbWUgbGVuZ3RoJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAob2xkUGF0aFtpXSAhPT0gbmV3UGF0aFtpXSkge1xuICAgICAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyB0byBiZSB0aGUgc2FtZSBleGNlcHQgZm9yIHRoZSBkZWVwZXN0IGtleScpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIDApO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldEltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoaW5kZXggPj0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCAwLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGZpbmRIb29rID0gZnVuY3Rpb24gKGZpYmVyLCBpZCkge1xuICAgIC8vIEZvciBub3csIHRoZSBcImlkXCIgb2Ygc3RhdGVmdWwgaG9va3MgaXMganVzdCB0aGUgc3RhdGVmdWwgaG9vayBpbmRleC5cbiAgICAvLyBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB3aXRoIGUuZy4gbmVzdGVkIGhvb2tzLlxuICAgIHZhciBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoY3VycmVudEhvb2sgIT09IG51bGwgJiYgaWQgPiAwKSB7XG4gICAgICBjdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICBpZC0tO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50SG9vaztcbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxuXG5cbiAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFNldChob29rLm1lbW9pemVkU3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhEZWxldGUoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhSZW5hbWUoaG9vay5tZW1vaXplZFN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cblxuXG4gIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoZmliZXIubWVtb2l6ZWRQcm9wcywgb2xkUGF0aCwgbmV3UGF0aCk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkRXJyb3JJbXBsKSB7XG4gICAgc2hvdWxkRXJyb3JJbXBsID0gbmV3U2hvdWxkRXJyb3JJbXBsO1xuICB9O1xuXG4gIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbmZ1bmN0aW9uIGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuICB2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG4gIHJldHVybiBpbmplY3RJbnRlcm5hbHMoe1xuICAgIGJ1bmRsZVR5cGU6IGRldlRvb2xzQ29uZmlnLmJ1bmRsZVR5cGUsXG4gICAgdmVyc2lvbjogZGV2VG9vbHNDb25maWcudmVyc2lvbixcbiAgICByZW5kZXJlclBhY2thZ2VOYW1lOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgIHJlbmRlcmVyQ29uZmlnOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlckNvbmZpZyxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZTogb3ZlcnJpZGVIb29rU3RhdGUsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wczogb3ZlcnJpZGVQcm9wcyxcbiAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDogb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoLFxuICAgIHNldEVycm9ySGFuZGxlcjogc2V0RXJyb3JIYW5kbGVyLFxuICAgIHNldFN1c3BlbnNlSGFuZGxlcjogc2V0U3VzcGVuc2VIYW5kbGVyLFxuICAgIHNjaGVkdWxlVXBkYXRlOiBzY2hlZHVsZVVwZGF0ZSxcbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIsXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIHx8IGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UsXG4gICAgLy8gUmVhY3QgUmVmcmVzaFxuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDogIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSZWZyZXNoOiAgc2NoZWR1bGVSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJvb3Q6ICBzY2hlZHVsZVJvb3QgLFxuICAgIHNldFJlZnJlc2hIYW5kbGVyOiAgc2V0UmVmcmVzaEhhbmRsZXIgLFxuICAgIC8vIEVuYWJsZXMgRGV2VG9vbHMgdG8gYXBwZW5kIG93bmVyIHN0YWNrcyB0byBlcnJvciBtZXNzYWdlcyBpbiBERVYgbW9kZS5cbiAgICBnZXRDdXJyZW50RmliZXI6ICBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyAsXG4gICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBkZXRlY3QgcmVjb25jaWxlciB2ZXJzaW9uIHJhdGhlciB0aGFuIHJlbmRlcmVyIHZlcnNpb25cbiAgICAvLyB3aGljaCBtYXkgbm90IG1hdGNoIGZvciB0aGlyZCBwYXJ0eSByZW5kZXJlcnMuXG4gICAgcmVjb25jaWxlclZlcnNpb246IFJlYWN0VmVyc2lvblxuICB9KTtcbn1cblxuLyogZ2xvYmFsIHJlcG9ydEVycm9yICovXG5cbnZhciBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID8gLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG5yZXBvcnRFcnJvciA6IGZ1bmN0aW9uIChlcnJvcikge1xuICAvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcbiAgY29uc29sZVsnZXJyb3InXShlcnJvcik7XG59O1xuXG5mdW5jdGlvbiBSZWFjdERPTVJvb3QoaW50ZXJuYWxSb290KSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGludGVybmFsUm9vdDtcbn1cblxuUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS5yZW5kZXIgPSBSZWFjdERPTVJvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcblxuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBhbiB1bm1vdW50ZWQgcm9vdC4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuICcgKyAnVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiBhIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkQ29udGFpbmVyKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIGVycm9yKCdZb3UgcGFzc2VkIGEgY29udGFpbmVyIHRvIHRoZSBzZWNvbmQgYXJndW1lbnQgb2Ygcm9vdC5yZW5kZXIoLi4uKS4gJyArIFwiWW91IGRvbid0IG5lZWQgdG8gcGFzcyBpdCBhZ2FpbiBzaW5jZSB5b3UgYWxyZWFkeSBwYXNzZWQgaXQgdG8gY3JlYXRlIHRoZSByb290LlwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignWW91IHBhc3NlZCBhIHNlY29uZCBhcmd1bWVudCB0byByb290LnJlbmRlciguLi4pIGJ1dCBpdCBvbmx5IGFjY2VwdHMgJyArICdvbmUgYXJndW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKHJvb3QuY3VycmVudCk7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICBlcnJvcigncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhlICcgKyAncm9vdCBjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyBcInJvb3QudW5tb3VudCgpIHRvIGVtcHR5IGEgcm9vdCdzIGNvbnRhaW5lci5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIG51bGwpO1xufTtcblxuUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bm1vdW50ID0gUmVhY3RET01Sb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCd1bm1vdW50KC4uLik6IGRvZXMgbm90IHN1cHBvcnQgYSBjYWxsYmFjayBhcmd1bWVudC4gJyArICdUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHRoaXMuX2ludGVybmFsUm9vdCA9IG51bGw7XG4gICAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcblxuICAgIHtcbiAgICAgIGlmIChpc0FscmVhZHlSZW5kZXJpbmcoKSkge1xuICAgICAgICBlcnJvcignQXR0ZW1wdGVkIHRvIHN5bmNocm9ub3VzbHkgdW5tb3VudCBhIHJvb3Qgd2hpbGUgUmVhY3Qgd2FzIGFscmVhZHkgJyArICdyZW5kZXJpbmcuIFJlYWN0IGNhbm5vdCBmaW5pc2ggdW5tb3VudGluZyB0aGUgcm9vdCB1bnRpbCB0aGUgJyArICdjdXJyZW50IHJlbmRlciBoYXMgY29tcGxldGVkLCB3aGljaCBtYXkgbGVhZCB0byBhIHJhY2UgY29uZGl0aW9uLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gICAgdW5tYXJrQ29udGFpbmVyQXNSb290KGNvbnRhaW5lcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVSb290KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7XG4gIH1cblxuICB3YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWKGNvbnRhaW5lcik7XG4gIHZhciBpc1N0cmljdE1vZGUgPSBmYWxzZTtcbiAgdmFyIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUgPSBmYWxzZTtcbiAgdmFyIGlkZW50aWZpZXJQcmVmaXggPSAnJztcbiAgdmFyIG9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I7XG4gIHZhciB0cmFuc2l0aW9uQ2FsbGJhY2tzID0gbnVsbDtcblxuICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICAgIHdhcm4oJ2h5ZHJhdGUgdGhyb3VnaCBjcmVhdGVSb290IGlzIGRlcHJlY2F0ZWQuIFVzZSBSZWFjdERPTUNsaWVudC5oeWRyYXRlUm9vdChjb250YWluZXIsIDxBcHAgLz4pIGluc3RlYWQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucy4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgZXJyb3IoJ1lvdSBwYXNzZWQgYSBKU1ggZWxlbWVudCB0byBjcmVhdGVSb290LiBZb3UgcHJvYmFibHkgbWVhbnQgdG8gJyArICdjYWxsIHJvb3QucmVuZGVyIGluc3RlYWQuICcgKyAnRXhhbXBsZSB1c2FnZTpcXG5cXG4nICsgJyAgbGV0IHJvb3QgPSBjcmVhdGVSb290KGRvbUNvbnRhaW5lcik7XFxuJyArICcgIHJvb3QucmVuZGVyKDxBcHAgLz4pOycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudW5zdGFibGVfc3RyaWN0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgaXNTdHJpY3RNb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZGVudGlmaWVyUHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvciA9IG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb25DYWxsYmFja3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMudHJhbnNpdGlvbkNhbGxiYWNrcztcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIENvbmN1cnJlbnRSb290LCBudWxsLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcik7XG4gIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuICB2YXIgcm9vdENvbnRhaW5lckVsZW1lbnQgPSBjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IGNvbnRhaW5lci5wYXJlbnROb2RlIDogY29udGFpbmVyO1xuICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHJldHVybiBuZXcgUmVhY3RET01Sb290KHJvb3QpO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTUh5ZHJhdGlvblJvb3QoaW50ZXJuYWxSb290KSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGludGVybmFsUm9vdDtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVIeWRyYXRpb24odGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBxdWV1ZUV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHRhcmdldCk7XG4gIH1cbn1cblxuUmVhY3RET01IeWRyYXRpb25Sb290LnByb3RvdHlwZS51bnN0YWJsZV9zY2hlZHVsZUh5ZHJhdGlvbiA9IHNjaGVkdWxlSHlkcmF0aW9uO1xuZnVuY3Rpb24gaHlkcmF0ZVJvb3QoY29udGFpbmVyLCBpbml0aWFsQ2hpbGRyZW4sIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2h5ZHJhdGVSb290KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7XG4gIH1cblxuICB3YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWKGNvbnRhaW5lcik7XG5cbiAge1xuICAgIGlmIChpbml0aWFsQ2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ011c3QgcHJvdmlkZSBpbml0aWFsIGNoaWxkcmVuIGFzIHNlY29uZCBhcmd1bWVudCB0byBoeWRyYXRlUm9vdC4gJyArICdFeGFtcGxlIHVzYWdlOiBoeWRyYXRlUm9vdChkb21Db250YWluZXIsIDxBcHAgLz4pJyk7XG4gICAgfVxuICB9IC8vIEZvciBub3cgd2UgcmV1c2UgdGhlIHdob2xlIGJhZyBvZiBvcHRpb25zIHNpbmNlIHRoZXkgY29udGFpblxuICAvLyB0aGUgaHlkcmF0aW9uIGNhbGxiYWNrcy5cblxuXG4gIHZhciBoeWRyYXRpb25DYWxsYmFja3MgPSBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDogbnVsbDsgLy8gVE9ETzogRGVsZXRlIHRoaXMgb3B0aW9uXG5cbiAgdmFyIG11dGFibGVTb3VyY2VzID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZWRTb3VyY2VzIHx8IG51bGw7XG4gIHZhciBpc1N0cmljdE1vZGUgPSBmYWxzZTtcbiAgdmFyIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUgPSBmYWxzZTtcbiAgdmFyIGlkZW50aWZpZXJQcmVmaXggPSAnJztcbiAgdmFyIG9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I7XG5cbiAgaWYgKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMudW5zdGFibGVfc3RyaWN0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgaXNTdHJpY3RNb2RlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pZGVudGlmaWVyUHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXg7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvciA9IG9wdGlvbnMub25SZWNvdmVyYWJsZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290ID0gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbiwgbnVsbCwgY29udGFpbmVyLCBDb25jdXJyZW50Um9vdCwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uUmVjb3ZlcmFibGVFcnJvcik7XG4gIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpOyAvLyBUaGlzIGNhbid0IGJlIGEgY29tbWVudCBub2RlIHNpbmNlIGh5ZHJhdGlvbiBkb2Vzbid0IHdvcmsgb24gY29tbWVudCBub2RlcyBhbnl3YXkuXG5cbiAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMoY29udGFpbmVyKTtcblxuICBpZiAobXV0YWJsZVNvdXJjZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGFibGVTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IG11dGFibGVTb3VyY2VzW2ldO1xuICAgICAgcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUmVhY3RET01IeWRyYXRpb25Sb290KHJvb3QpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8ICFkaXNhYmxlQ29tbWVudHNBc0RPTUNvbnRhaW5lcnMgICkpO1xufSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiB3aGljaCBhbHNvIGluY2x1ZGVzIGNvbW1lbnQgbm9kZXMuXG4vLyBXZSBvbmx5IHVzZSBpdCBpbiBwbGFjZXMgdGhhdCBhcmUgY3VycmVudGx5IG1vcmUgcmVsYXhlZC5cblxuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lckxlZ2FjeShub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlJlYWN0RE9NQ29udGFpbmVySW5ERVYoY29udGFpbmVyKSB7XG4gIHtcbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgY29udGFpbmVyLnRhZ05hbWUgJiYgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0JPRFknKSB7XG4gICAgICBlcnJvcignY3JlYXRlUm9vdCgpOiBDcmVhdGluZyByb290cyBkaXJlY3RseSB3aXRoIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSB1c2luZyBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikpIHtcbiAgICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NLnJlbmRlcigpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKSBvbiBhIGNvbnRhaW5lciB0aGF0ICcgKyAnaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gY3JlYXRlUm9vdCgpIGJlZm9yZS4gSW5zdGVhZCwgY2FsbCAnICsgJ3Jvb3QucmVuZGVyKCkgb24gdGhlIGV4aXN0aW5nIHJvb3QgaW5zdGVhZCBpZiB5b3Ugd2FudCB0byB1cGRhdGUgaXQuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQzID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncztcblxue1xuICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJyArICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyAnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG5cbiAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQgJiYgIWlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBjb250YWluZXIudGFnTmFtZSAmJiBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWScpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBub29wT25SZWNvdmVyYWJsZUVycm9yKCkgey8vIFRoaXMgaXNuJ3QgcmVhY2hhYmxlIGJlY2F1c2Ugb25SZWNvdmVyYWJsZUVycm9yIGlzbid0IGNhbGxlZCBpbiB0aGVcbiAgLy8gbGVnYWN5IEFQSS5cbn1cblxuZnVuY3Rpb24gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBpbml0aWFsQ2hpbGRyZW4sIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2ssIGlzSHlkcmF0aW9uQ29udGFpbmVyKSB7XG4gIGlmIChpc0h5ZHJhdGlvbkNvbnRhaW5lcikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciByb290ID0gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbiwgY2FsbGJhY2ssIGNvbnRhaW5lciwgTGVnYWN5Um9vdCwgbnVsbCwgLy8gaHlkcmF0aW9uQ2FsbGJhY2tzXG4gICAgZmFsc2UsIC8vIGlzU3RyaWN0TW9kZVxuICAgIGZhbHNlLCAvLyBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuICAgICcnLCAvLyBpZGVudGlmaWVyUHJlZml4XG4gICAgbm9vcE9uUmVjb3ZlcmFibGVFcnJvcik7XG4gICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSByb290O1xuICAgIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuICAgIHZhciByb290Q29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICAgIGZsdXNoU3luYygpO1xuICAgIHJldHVybiByb290O1xuICB9IGVsc2Uge1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIHZhciByb290U2libGluZztcblxuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9vcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2UoX3Jvb3QpO1xuXG4gICAgICAgIF9vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgX3Jvb3QgPSBjcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBMZWdhY3lSb290LCBudWxsLCAvLyBoeWRyYXRpb25DYWxsYmFja3NcbiAgICBmYWxzZSwgLy8gaXNTdHJpY3RNb2RlXG4gICAgZmFsc2UsIC8vIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsXG4gICAgJycsIC8vIGlkZW50aWZpZXJQcmVmaXhcbiAgICBub29wT25SZWNvdmVyYWJsZUVycm9yKTtcblxuICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gX3Jvb3Q7XG4gICAgbWFya0NvbnRhaW5lckFzUm9vdChfcm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuXG4gICAgdmFyIF9yb290Q29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG5cbiAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhfcm9vdENvbnRhaW5lckVsZW1lbnQpOyAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cblxuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIoaW5pdGlhbENoaWxkcmVuLCBfcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9yb290O1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG5cbiAgdmFyIG1heWJlUm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICB2YXIgcm9vdDtcblxuICBpZiAoIW1heWJlUm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBjaGlsZHJlbiwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaywgZm9yY2VIeWRyYXRlKTtcbiAgfSBlbHNlIHtcbiAgICByb290ID0gbWF5YmVSb290O1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgfSAvLyBVcGRhdGVcblxuXG4gICAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUob3duZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHtcbiAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudE9yRWxlbWVudCwgJ2ZpbmRET01Ob2RlJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICB7XG4gICAgZXJyb3IoJ1JlYWN0RE9NLmh5ZHJhdGUgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBpbiBSZWFjdCAxOC4gVXNlIGh5ZHJhdGVSb290ICcgKyAnaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byB0aGUgbmV3IEFQSSwgeW91ciBhcHAgd2lsbCBiZWhhdmUgYXMgJyArIFwiaWYgaXQncyBydW5uaW5nIFJlYWN0IDE3LiBMZWFybiBcIiArICdtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO1xuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLmh5ZHJhdGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIGh5ZHJhdGVSb290KGNvbnRhaW5lciwgZWxlbWVudCk/Jyk7XG4gICAgfVxuICB9IC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cblxuXG4gIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIHRydWUsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICBlcnJvcignUmVhY3RET00ucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290ICcgKyAnaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byB0aGUgbmV3IEFQSSwgeW91ciBhcHAgd2lsbCBiZWhhdmUgYXMgJyArIFwiaWYgaXQncyBydW5uaW5nIFJlYWN0IDE3LiBMZWFybiBcIiArICdtb3JlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3dpdGNoLXRvLWNyZWF0ZXJvb3QnKTtcbiAgfVxuXG4gIGlmICghaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpO1xuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC5yZW5kZXIoZWxlbWVudCk/Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAge1xuICAgIGVycm9yKCdSZWFjdERPTS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcigpIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgJyArICdpbiBSZWFjdCAxOC4gQ29uc2lkZXIgdXNpbmcgYSBwb3J0YWwgaW5zdGVhZC4gVW50aWwgeW91IHN3aXRjaCB0byAnICsgXCJ0aGUgY3JlYXRlUm9vdCBBUEksIHlvdXIgYXBwIHdpbGwgYmVoYXZlIGFzIGlmIGl0J3MgcnVubmluZyBSZWFjdCBcIiArICcxNy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N3aXRjaC10by1jcmVhdGVyb290Jyk7XG4gIH1cblxuICBpZiAoIWlzVmFsaWRDb250YWluZXJMZWdhY3koY29udGFpbmVyTm9kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7XG4gIH1cblxuICBpZiAocGFyZW50Q29tcG9uZW50ID09IG51bGwgfHwgIWhhcyhwYXJlbnRDb21wb25lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpO1xuICB9XG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKSB7XG4gIGlmICghaXNWYWxpZENvbnRhaW5lckxlZ2FjeShjb250YWluZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJyk7XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET01DbGllbnQuY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QudW5tb3VudCgpPycpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgIHtcbiAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIHZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPSByb290RWwgJiYgIWdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcblxuICAgICAgaWYgKHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCkge1xuICAgICAgICBlcnJvcihcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5cblxuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgVGhpcyBzaG91bGQgcHJvYmFibHkgdXNlIGBkZWxldGUgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXJgXG4gICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdW5tYXJrQ29udGFpbmVyQXNSb290KGNvbnRhaW5lcik7XG4gICAgICB9KTtcbiAgICB9KTsgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZShfcm9vdEVsKSk7IC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuXG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBpc1ZhbGlkQ29udGFpbmVyTGVnYWN5KGNvbnRhaW5lci5wYXJlbnROb2RlKSAmJiAhIWNvbnRhaW5lci5wYXJlbnROb2RlLl9yZWFjdFJvb3RDb250YWluZXI7XG5cbiAgICAgIGlmIChoYXNOb25Sb290UmVhY3RDaGlsZCkge1xuICAgICAgICBlcnJvcihcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5zZXRBdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uJDEpO1xuc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24kMSk7XG5zZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEpO1xuc2V0R2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSk7XG5zZXRBdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShydW5XaXRoUHJpb3JpdHkpO1xuXG57XG4gIGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nIHx8IC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgTWFwIGhhcyBubyBwcm90b3R5cGVcbiAgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fCAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFNldCBoYXMgbm8gcHJvdG90eXBlXG4gIFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZXJyb3IoJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbnNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbihyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMpO1xuc2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbihiYXRjaGVkVXBkYXRlcyQxLCBkaXNjcmV0ZVVwZGF0ZXMsIGZsdXNoU3luYyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKTtcbiAgfSAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICAvLyAkRmxvd0ZpeE1lIFRoZSBGbG93IHR5cGUgaXMgb3BhcXVlIGJ1dCB0aGVyZSdzIG5vIHdheSB0byBhY3R1YWxseSBjcmVhdGUgaXQuXG5cblxuICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spO1xufVxuXG52YXIgSW50ZXJuYWxzID0ge1xuICB1c2luZ0NsaWVudEVudHJ5UG9pbnQ6IGZhbHNlLFxuICAvLyBLZWVwIGluIHN5bmMgd2l0aCBSZWFjdFRlc3RVdGlscy5qcy5cbiAgLy8gVGhpcyBpcyBhbiBhcnJheSBmb3IgYmV0dGVyIG1pbmlmaWNhdGlvbi5cbiAgRXZlbnRzOiBbZ2V0SW5zdGFuY2VGcm9tTm9kZSwgZ2V0Tm9kZUZyb21JbnN0YW5jZSwgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSwgZW5xdWV1ZVN0YXRlUmVzdG9yZSwgcmVzdG9yZVN0YXRlSWZOZWVkZWQsIGJhdGNoZWRVcGRhdGVzJDFdXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSb290JDEoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHtcbiAgICBpZiAoIUludGVybmFscy51c2luZ0NsaWVudEVudHJ5UG9pbnQgJiYgIWZhbHNlKSB7XG4gICAgICBlcnJvcignWW91IGFyZSBpbXBvcnRpbmcgY3JlYXRlUm9vdCBmcm9tIFwicmVhY3QtZG9tXCIgd2hpY2ggaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3Ugc2hvdWxkIGluc3RlYWQgaW1wb3J0IGl0IGZyb20gXCJyZWFjdC1kb20vY2xpZW50XCIuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaHlkcmF0ZVJvb3QkMShjb250YWluZXIsIGluaXRpYWxDaGlsZHJlbiwgb3B0aW9ucykge1xuICB7XG4gICAgaWYgKCFJbnRlcm5hbHMudXNpbmdDbGllbnRFbnRyeVBvaW50ICYmICFmYWxzZSkge1xuICAgICAgZXJyb3IoJ1lvdSBhcmUgaW1wb3J0aW5nIGh5ZHJhdGVSb290IGZyb20gXCJyZWFjdC1kb21cIiB3aGljaCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBzaG91bGQgaW5zdGVhZCBpbXBvcnQgaXQgZnJvbSBcInJlYWN0LWRvbS9jbGllbnRcIi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaHlkcmF0ZVJvb3QoY29udGFpbmVyLCBpbml0aWFsQ2hpbGRyZW4sIG9wdGlvbnMpO1xufSAvLyBPdmVybG9hZCB0aGUgZGVmaW5pdGlvbiB0byB0aGUgdHdvIHZhbGlkIHNpZ25hdHVyZXMuXG4vLyBXYXJuaW5nLCB0aGlzIG9wdHMtb3V0IG9mIGNoZWNraW5nIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmZ1bmN0aW9uIGZsdXNoU3luYyQxKGZuKSB7XG4gIHtcbiAgICBpZiAoaXNBbHJlYWR5UmVuZGVyaW5nKCkpIHtcbiAgICAgIGVycm9yKCdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCAnICsgJ2ZsdXNoIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuIENvbnNpZGVyIG1vdmluZyB0aGlzIGNhbGwgdG8gJyArICdhIHNjaGVkdWxlciB0YXNrIG9yIG1pY3JvIHRhc2suJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZsdXNoU3luYyhmbik7XG59XG52YXIgZm91bmREZXZUb29scyA9IGluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogIDEgLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sOyAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IEludGVybmFscztcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsJDE7XG5leHBvcnRzLmNyZWF0ZVJvb3QgPSBjcmVhdGVSb290JDE7XG5leHBvcnRzLmZpbmRET01Ob2RlID0gZmluZERPTU5vZGU7XG5leHBvcnRzLmZsdXNoU3luYyA9IGZsdXNoU3luYyQxO1xuZXhwb3J0cy5oeWRyYXRlID0gaHlkcmF0ZTtcbmV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBoeWRyYXRlUm9vdCQxO1xuZXhwb3J0cy5yZW5kZXIgPSByZW5kZXI7XG5leHBvcnRzLnVubW91bnRDb21wb25lbnRBdE5vZGUgPSB1bm1vdW50Q29tcG9uZW50QXROb2RlO1xuZXhwb3J0cy51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyA9IGJhdGNoZWRVcGRhdGVzJDE7XG5leHBvcnRzLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG0gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGV4cG9ydHMuY3JlYXRlUm9vdCA9IG0uY3JlYXRlUm9vdDtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IG0uaHlkcmF0ZVJvb3Q7XG59IGVsc2Uge1xuICB2YXIgaSA9IG0uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gIGV4cG9ydHMuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uKGMsIG8pIHtcbiAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtLmNyZWF0ZVJvb3QoYywgbyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBleHBvcnRzLmh5ZHJhdGVSb290ID0gZnVuY3Rpb24oYywgaCwgbykge1xuICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG0uaHlkcmF0ZVJvb3QoYywgaCwgbyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGkudXNpbmdDbGllbnRFbnRyeVBvaW50ID0gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBOT1RFOiBJZiB5b3UgcmVmYWN0b3IgdGhpcyB0byBzcGxpdCB1cCB0aGUgbW9kdWxlcyBpbnRvIHNlcGFyYXRlIGZpbGVzLFxuICogeW91J2xsIG5lZWQgdG8gdXBkYXRlIHRoZSByb2xsdXAgY29uZmlnIGZvciByZWFjdC1yb3V0ZXItZG9tLXY1LWNvbXBhdC5cbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IEJyb3dzZXJIaXN0b3J5LCBIYXNoSGlzdG9yeSwgSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgeyBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnkgfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgZ2VuZXJhdGVQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgbWF0Y2hQYXRoLFxuICBjcmVhdGVQYXRoLFxuICBwYXJzZVBhdGgsXG4gIHJlc29sdmVQYXRoLFxuICByZW5kZXJNYXRjaGVzLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSb3V0ZXMsXG4gIHVzZU91dGxldENvbnRleHQsXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmltcG9ydCB0eXBlIHsgVG8gfSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghY29uZCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgUm91dGVyIVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28geW91IGNhbiBtb3JlIGVhc2lseVxuICAgICAgLy8gZmluZCB0aGUgc291cmNlIGZvciBhIHdhcm5pbmcgdGhhdCBhcHBlYXJzIGluIHRoZSBjb25zb2xlIGJ5XG4gICAgICAvLyBlbmFibGluZyBcInBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIEphdmFTY3JpcHQgZGVidWdnZXIuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSRS1FWFBPUlRTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBOb3RlOiBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yb3V0ZXIgZXhwb3J0cyFcbmV4cG9ydCB7XG4gIE1lbW9yeVJvdXRlcixcbiAgTmF2aWdhdGUsXG4gIE91dGxldCxcbiAgUm91dGUsXG4gIFJvdXRlcixcbiAgUm91dGVzLFxuICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4sXG4gIGdlbmVyYXRlUGF0aCxcbiAgbWF0Y2hSb3V0ZXMsXG4gIG1hdGNoUGF0aCxcbiAgY3JlYXRlUGF0aCxcbiAgcGFyc2VQYXRoLFxuICByZW5kZXJNYXRjaGVzLFxuICByZXNvbHZlUGF0aCxcbiAgdXNlSHJlZixcbiAgdXNlSW5Sb3V0ZXJDb250ZXh0LFxuICB1c2VMb2NhdGlvbixcbiAgdXNlTWF0Y2gsXG4gIHVzZU5hdmlnYXRlLFxuICB1c2VOYXZpZ2F0aW9uVHlwZSxcbiAgdXNlT3V0bGV0LFxuICB1c2VQYXJhbXMsXG4gIHVzZVJlc29sdmVkUGF0aCxcbiAgdXNlUm91dGVzLFxuICB1c2VPdXRsZXRDb250ZXh0LFxufTtcblxuZXhwb3J0IHsgTmF2aWdhdGlvblR5cGUgfSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5leHBvcnQgdHlwZSB7XG4gIEhhc2gsXG4gIExvY2F0aW9uLFxuICBQYXRoLFxuICBUbyxcbiAgTWVtb3J5Um91dGVyUHJvcHMsXG4gIE5hdmlnYXRlRnVuY3Rpb24sXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgTmF2aWdhdGVQcm9wcyxcbiAgTmF2aWdhdG9yLFxuICBPdXRsZXRQcm9wcyxcbiAgUGFyYW1zLFxuICBQYXRoTWF0Y2gsXG4gIFJvdXRlTWF0Y2gsXG4gIFJvdXRlT2JqZWN0LFxuICBSb3V0ZVByb3BzLFxuICBQYXRoUm91dGVQcm9wcyxcbiAgTGF5b3V0Um91dGVQcm9wcyxcbiAgSW5kZXhSb3V0ZVByb3BzLFxuICBSb3V0ZXJQcm9wcyxcbiAgUGF0aG5hbWUsXG4gIFNlYXJjaCxcbiAgUm91dGVzUHJvcHMsXG59IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX0xvY2F0aW9uQ29udGV4dCxcbiAgVU5TQUZFX1JvdXRlQ29udGV4dCxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09NUE9ORU5UU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBCcm93c2VyUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFByb3ZpZGVzIHRoZSBjbGVhbmVzdCBVUkxzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gQnJvd3NlclJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgd2luZG93LFxufTogQnJvd3NlclJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEJyb3dzZXJIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVCcm93c2VySGlzdG9yeSh7IHdpbmRvdyB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIYXNoUm91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHdpbmRvdz86IFdpbmRvdztcbn1cblxuLyoqXG4gKiBBIGA8Um91dGVyPmAgZm9yIHVzZSBpbiB3ZWIgYnJvd3NlcnMuIFN0b3JlcyB0aGUgbG9jYXRpb24gaW4gdGhlIGhhc2hcbiAqIHBvcnRpb24gb2YgdGhlIFVSTCBzbyBpdCBpcyBub3Qgc2VudCB0byB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gSGFzaFJvdXRlcih7IGJhc2VuYW1lLCBjaGlsZHJlbiwgd2luZG93IH06IEhhc2hSb3V0ZXJQcm9wcykge1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZjxIYXNoSGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3RvcnkoeyB3aW5kb3cgfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCBoaXN0b3J5IH06IEhpc3RvcnlSb3V0ZXJQcm9wcykge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5pZiAoX19ERVZfXykge1xuICBIaXN0b3J5Um91dGVyLmRpc3BsYXlOYW1lID0gXCJ1bnN0YWJsZV9IaXN0b3J5Um91dGVyXCI7XG59XG5cbmV4cG9ydCB7IEhpc3RvcnlSb3V0ZXIgYXMgdW5zdGFibGVfSGlzdG9yeVJvdXRlciB9O1xuXG5mdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8UmVhY3QuQW5jaG9ySFRNTEF0dHJpYnV0ZXM8SFRNTEFuY2hvckVsZW1lbnQ+LCBcImhyZWZcIj4ge1xuICByZWxvYWREb2N1bWVudD86IGJvb2xlYW47XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbiAgdG86IFRvO1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuZXhwb3J0IGNvbnN0IExpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBMaW5rV2l0aFJlZihcbiAgICB7IG9uQ2xpY2ssIHJlbG9hZERvY3VtZW50LCByZXBsYWNlID0gZmFsc2UsIHN0YXRlLCB0YXJnZXQsIHRvLCAuLi5yZXN0IH0sXG4gICAgcmVmXG4gICkge1xuICAgIGxldCBocmVmID0gdXNlSHJlZih0byk7XG4gICAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHsgcmVwbGFjZSwgc3RhdGUsIHRhcmdldCB9KTtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhcbiAgICAgIGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxBbmNob3JFbGVtZW50LCBNb3VzZUV2ZW50PlxuICAgICkge1xuICAgICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmICFyZWxvYWREb2N1bWVudCkge1xuICAgICAgICBpbnRlcm5hbE9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICA8YVxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgaHJlZj17aHJlZn1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICB0YXJnZXQ9e3RhcmdldH1cbiAgICAgIC8+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdkxpbmtQcm9wc1xuICBleHRlbmRzIE9taXQ8TGlua1Byb3BzLCBcImNsYXNzTmFtZVwiIHwgXCJzdHlsZVwiIHwgXCJjaGlsZHJlblwiPiB7XG4gIGNoaWxkcmVuPzpcbiAgICB8IFJlYWN0LlJlYWN0Tm9kZVxuICAgIHwgKChwcm9wczogeyBpc0FjdGl2ZTogYm9vbGVhbiB9KSA9PiBSZWFjdC5SZWFjdE5vZGUpO1xuICBjYXNlU2Vuc2l0aXZlPzogYm9vbGVhbjtcbiAgY2xhc3NOYW1lPzogc3RyaW5nIHwgKChwcm9wczogeyBpc0FjdGl2ZTogYm9vbGVhbiB9KSA9PiBzdHJpbmcgfCB1bmRlZmluZWQpO1xuICBlbmQ/OiBib29sZWFuO1xuICBzdHlsZT86XG4gICAgfCBSZWFjdC5DU1NQcm9wZXJ0aWVzXG4gICAgfCAoKHByb3BzOiB7IGlzQWN0aXZlOiBib29sZWFuIH0pID0+IFJlYWN0LkNTU1Byb3BlcnRpZXMpO1xufVxuXG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5leHBvcnQgY29uc3QgTmF2TGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIE5hdkxpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIE5hdkxpbmtXaXRoUmVmKFxuICAgIHtcbiAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50UHJvcCA9IFwicGFnZVwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVQcm9wID0gXCJcIixcbiAgICAgIGVuZCA9IGZhbHNlLFxuICAgICAgc3R5bGU6IHN0eWxlUHJvcCxcbiAgICAgIHRvLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG5cbiAgICBsZXQgbG9jYXRpb25QYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIGxldCB0b1BhdGhuYW1lID0gcGF0aC5wYXRobmFtZTtcbiAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvblBhdGhuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGxldCBpc0FjdGl2ZSA9XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8XG4gICAgICAoIWVuZCAmJlxuICAgICAgICBsb2NhdGlvblBhdGhuYW1lLnN0YXJ0c1dpdGgodG9QYXRobmFtZSkgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG5cbiAgICBsZXQgYXJpYUN1cnJlbnQgPSBpc0FjdGl2ZSA/IGFyaWFDdXJyZW50UHJvcCA6IHVuZGVmaW5lZDtcblxuICAgIGxldCBjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lUHJvcCh7IGlzQWN0aXZlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgY2xhc3NOYW1lIHByb3AgaXMgbm90IGEgZnVuY3Rpb24sIHdlIHVzZSBhIGRlZmF1bHQgYGFjdGl2ZWBcbiAgICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcbiAgICAgIC8vIHZhbHVlIGZvciBgYWN0aXZlQ2xhc3NOYW1lYCwgYnV0IHdlIGFyZSByZW1vdmluZyB0aGF0IEFQSSBhbmQgY2FuIHN0aWxsXG4gICAgICAvLyB1c2UgdGhlIG9sZCBkZWZhdWx0IGJlaGF2aW9yIGZvciBhIGNsZWFuZXIgdXBncmFkZSBwYXRoIGFuZCBrZWVwIHRoZVxuICAgICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cbiAgICAgIGNsYXNzTmFtZSA9IFtjbGFzc05hbWVQcm9wLCBpc0FjdGl2ZSA/IFwiYWN0aXZlXCIgOiBudWxsXVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKFwiIFwiKTtcbiAgICB9XG5cbiAgICBsZXQgc3R5bGUgPVxuICAgICAgdHlwZW9mIHN0eWxlUHJvcCA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVQcm9wKHsgaXNBY3RpdmUgfSkgOiBzdHlsZVByb3A7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPExpbmtcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIGFyaWEtY3VycmVudD17YXJpYUN1cnJlbnR9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICB0bz17dG99XG4gICAgICA+XG4gICAgICAgIHt0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIiA/IGNoaWxkcmVuKHsgaXNBY3RpdmUgfSkgOiBjaGlsZHJlbn1cbiAgICAgIDwvTGluaz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBOYXZMaW5rLmRpc3BsYXlOYW1lID0gXCJOYXZMaW5rXCI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIT09LU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBjbGljayBiZWhhdmlvciBmb3Igcm91dGVyIGA8TGluaz5gIGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsIGlmXG4gKiB5b3UgbmVlZCB0byBjcmVhdGUgY3VzdG9tIGA8TGluaz5gIGNvbXBvbmVudHMgd2l0aCB0aGUgc2FtZSBjbGljayBiZWhhdmlvciB3ZVxuICogdXNlIGluIG91ciBleHBvcnRlZCBgPExpbms+YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXI8RSBleHRlbmRzIEVsZW1lbnQgPSBIVE1MQW5jaG9yRWxlbWVudD4oXG4gIHRvOiBUbyxcbiAge1xuICAgIHRhcmdldCxcbiAgICByZXBsYWNlOiByZXBsYWNlUHJvcCxcbiAgICBzdGF0ZSxcbiAgfToge1xuICAgIHRhcmdldD86IFJlYWN0LkhUTUxBdHRyaWJ1dGVBbmNob3JUYXJnZXQ7XG4gICAgcmVwbGFjZT86IGJvb2xlYW47XG4gICAgc3RhdGU/OiBhbnk7XG4gIH0gPSB7fVxuKTogKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB2b2lkIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8RSwgTW91c2VFdmVudD4pID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICAgICAoIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgLy8gTGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gSWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRoZSBVUkwgaGFzbid0IGNoYW5nZWQsIGEgcmVndWxhciA8YT4gd2lsbCBkbyBhIHJlcGxhY2UgaW5zdGVhZCBvZlxuICAgICAgICAvLyBhIHB1c2gsIHNvIGRvIHRoZSBzYW1lIGhlcmUuXG4gICAgICAgIGxldCByZXBsYWNlID1cbiAgICAgICAgICAhIXJlcGxhY2VQcm9wIHx8IGNyZWF0ZVBhdGgobG9jYXRpb24pID09PSBjcmVhdGVQYXRoKHBhdGgpO1xuXG4gICAgICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2xvY2F0aW9uLCBuYXZpZ2F0ZSwgcGF0aCwgcmVwbGFjZVByb3AsIHN0YXRlLCB0YXJnZXQsIHRvXVxuICApO1xufVxuXG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQ/OiBVUkxTZWFyY2hQYXJhbXNJbml0KSB7XG4gIHdhcm5pbmcoXG4gICAgdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICBgWW91IGNhbm5vdCB1c2UgdGhlIFxcYHVzZVNlYXJjaFBhcmFtc1xcYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IGAgK1xuICAgICAgYHN1cHBvcnQgdGhlIFVSTFNlYXJjaFBhcmFtcyBBUEkuIElmIHlvdSBuZWVkIHRvIHN1cHBvcnQgSW50ZXJuZXQgYCArXG4gICAgICBgRXhwbG9yZXIgMTEsIHdlIHJlY29tbWVuZCB5b3UgbG9hZCBhIHBvbHlmaWxsIHN1Y2ggYXMgYCArXG4gICAgICBgaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuYCArXG4gICAgICBgSWYgeW91J3JlIHVuc3VyZSBob3cgdG8gbG9hZCBwb2x5ZmlsbHMsIHdlIHJlY29tbWVuZCB5b3UgY2hlY2sgb3V0IGAgK1xuICAgICAgYGh0dHBzOi8vcG9seWZpbGwuaW8vdjMvIHdoaWNoIHByb3ZpZGVzIHNvbWUgcmVjb21tZW5kYXRpb25zIGFib3V0IGhvdyBgICtcbiAgICAgIGB0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgYCArXG4gICAgICBgdXNlci5gXG4gICk7XG5cbiAgbGV0IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYgPSBSZWFjdC51c2VSZWYoY3JlYXRlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0KSk7XG5cbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGxldCBzZWFyY2hQYXJhbXMgPSBjcmVhdGVTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKTtcblxuICAgIGZvciAobGV0IGtleSBvZiBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQua2V5cygpKSB7XG4gICAgICBpZiAoIXNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmLmN1cnJlbnQuZ2V0QWxsKGtleSkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VhcmNoUGFyYW1zO1xuICB9LCBbbG9jYXRpb24uc2VhcmNoXSk7XG5cbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChcbiAgICAgIG5leHRJbml0OiBVUkxTZWFyY2hQYXJhbXNJbml0LFxuICAgICAgbmF2aWdhdGVPcHRpb25zPzogeyByZXBsYWNlPzogYm9vbGVhbjsgc3RhdGU/OiBhbnkgfVxuICAgICkgPT4ge1xuICAgICAgbmF2aWdhdGUoXCI/XCIgKyBjcmVhdGVTZWFyY2hQYXJhbXMobmV4dEluaXQpLCBuYXZpZ2F0ZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgW25hdmlnYXRlXVxuICApO1xuXG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdIGFzIGNvbnN0O1xufVxuXG5leHBvcnQgdHlwZSBQYXJhbUtleVZhbHVlUGFpciA9IFtzdHJpbmcsIHN0cmluZ107XG5cbmV4cG9ydCB0eXBlIFVSTFNlYXJjaFBhcmFtc0luaXQgPVxuICB8IHN0cmluZ1xuICB8IFBhcmFtS2V5VmFsdWVQYWlyW11cbiAgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXT5cbiAgfCBVUkxTZWFyY2hQYXJhbXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QgdXNpbmcgdGhlIGdpdmVuIGluaXRpYWxpemVyLlxuICpcbiAqIFRoaXMgaXMgaWRlbnRpY2FsIHRvIGBuZXcgVVJMU2VhcmNoUGFyYW1zKGluaXQpYCBleGNlcHQgaXQgYWxzb1xuICogc3VwcG9ydHMgYXJyYXlzIGFzIHZhbHVlcyBpbiB0aGUgb2JqZWN0IGZvcm0gb2YgdGhlIGluaXRpYWxpemVyXG4gKiBpbnN0ZWFkIG9mIGp1c3Qgc3RyaW5ncy4gVGhpcyBpcyBjb252ZW5pZW50IHdoZW4geW91IG5lZWQgbXVsdGlwbGVcbiAqIHZhbHVlcyBmb3IgYSBnaXZlbiBrZXksIGJ1dCBkb24ndCB3YW50IHRvIHVzZSBhbiBhcnJheSBpbml0aWFsaXplci5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgaW5zdGVhZCBvZjpcbiAqXG4gKiAgIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKFtcbiAqICAgICBbJ3NvcnQnLCAnbmFtZSddLFxuICogICAgIFsnc29ydCcsICdwcmljZSddXG4gKiAgIF0pO1xuICpcbiAqIHlvdSBjYW4gZG86XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKHtcbiAqICAgICBzb3J0OiBbJ25hbWUnLCAncHJpY2UnXVxuICogICB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhcbiAgaW5pdDogVVJMU2VhcmNoUGFyYW1zSW5pdCA9IFwiXCJcbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKFxuICAgIHR5cGVvZiBpbml0ID09PSBcInN0cmluZ1wiIHx8XG4gICAgQXJyYXkuaXNBcnJheShpbml0KSB8fFxuICAgIGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXNcbiAgICAgID8gaW5pdFxuICAgICAgOiBPYmplY3Qua2V5cyhpbml0KS5yZWR1Y2UoKG1lbW8sIGtleSkgPT4ge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGluaXRba2V5XTtcbiAgICAgICAgICByZXR1cm4gbWVtby5jb25jYXQoXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCgodikgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV1cbiAgICAgICAgICApO1xuICAgICAgICB9LCBbXSBhcyBQYXJhbUtleVZhbHVlUGFpcltdKVxuICApO1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IEhpc3RvcnksIExvY2F0aW9uIH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCB7IEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSB9IGZyb20gXCJoaXN0b3J5XCI7XG5cbmltcG9ydCB0eXBlIHsgUm91dGVNYXRjaCB9IGZyb20gXCIuL3JvdXRlclwiO1xuXG4vKipcbiAqIEEgTmF2aWdhdG9yIGlzIGEgXCJsb2NhdGlvbiBjaGFuZ2VyXCI7IGl0J3MgaG93IHlvdSBnZXQgdG8gZGlmZmVyZW50IGxvY2F0aW9ucy5cbiAqXG4gKiBFdmVyeSBoaXN0b3J5IGluc3RhbmNlIGNvbmZvcm1zIHRvIHRoZSBOYXZpZ2F0b3IgaW50ZXJmYWNlLCBidXQgdGhlXG4gKiBkaXN0aW5jdGlvbiBpcyB1c2VmdWwgcHJpbWFyaWx5IHdoZW4gaXQgY29tZXMgdG8gdGhlIGxvdy1sZXZlbCA8Um91dGVyPiBBUElcbiAqIHdoZXJlIGJvdGggdGhlIGxvY2F0aW9uIGFuZCBhIG5hdmlnYXRvciBtdXN0IGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgaW4gb3JkZXJcbiAqIHRvIGF2b2lkIFwidGVhcmluZ1wiIHRoYXQgbWF5IG9jY3VyIGluIGEgc3VzcGVuc2UtZW5hYmxlZCBhcHAgaWYgdGhlIGFjdGlvblxuICogYW5kL29yIGxvY2F0aW9uIHdlcmUgdG8gYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBoaXN0b3J5IGluc3RhbmNlLlxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0b3IgPSBQaWNrPEhpc3RvcnksIFwiZ29cIiB8IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgfCBcImNyZWF0ZUhyZWZcIj47XG5cbmludGVyZmFjZSBOYXZpZ2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGJhc2VuYW1lOiBzdHJpbmc7XG4gIG5hdmlnYXRvcjogTmF2aWdhdG9yO1xuICBzdGF0aWM6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TmF2aWdhdGlvbkNvbnRleHRPYmplY3Q+KFxuICBudWxsIVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2aWdhdGlvbkNvbnRleHQuZGlzcGxheU5hbWUgPSBcIk5hdmlnYXRpb25cIjtcbn1cblxuaW50ZXJmYWNlIExvY2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGxvY2F0aW9uOiBMb2NhdGlvbjtcbiAgbmF2aWdhdGlvblR5cGU6IE5hdmlnYXRpb25UeXBlO1xufVxuXG5leHBvcnQgY29uc3QgTG9jYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxMb2NhdGlvbkNvbnRleHRPYmplY3Q+KFxuICBudWxsIVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTG9jYXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJMb2NhdGlvblwiO1xufVxuXG5pbnRlcmZhY2UgUm91dGVDb250ZXh0T2JqZWN0IHtcbiAgb3V0bGV0OiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsO1xuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW107XG59XG5cbmV4cG9ydCBjb25zdCBSb3V0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFJvdXRlQ29udGV4dE9iamVjdD4oe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdLFxufSk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn1cbiIsImltcG9ydCB0eXBlIHsgTG9jYXRpb24sIFBhdGgsIFRvIH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gXCJoaXN0b3J5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZhcmlhbnQoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpOiBhc3NlcnRzIGNvbmQge1xuICBpZiAoIWNvbmQpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5pbmcoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCBSb3V0ZXIhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuY29uc3QgYWxyZWFkeVdhcm5lZDogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nT25jZShrZXk6IHN0cmluZywgY29uZDogYm9vbGVhbiwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGlmICghY29uZCAmJiAhYWxyZWFkeVdhcm5lZFtrZXldKSB7XG4gICAgYWxyZWFkeVdhcm5lZFtrZXldID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCBtZXNzYWdlKTtcbiAgfVxufVxuXG50eXBlIFBhcmFtUGFyc2VGYWlsZWQgPSB7IGZhaWxlZDogdHJ1ZSB9O1xuXG50eXBlIFBhcmFtUGFyc2VTZWdtZW50PFNlZ21lbnQgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgLy8gQ2hlY2sgaGVyZSBpZiB0aGVyZSBleGlzdHMgYSBmb3J3YXJkIHNsYXNoIGluIHRoZSBzdHJpbmcuXG4gIFNlZ21lbnQgZXh0ZW5kcyBgJHtpbmZlciBMZWZ0U2VnbWVudH0vJHtpbmZlciBSaWdodFNlZ21lbnR9YFxuICAgID8gLy8gSWYgdGhlcmUgaXMgYSBmb3J3YXJkIHNsYXNoLCB0aGVuIGF0dGVtcHQgdG8gcGFyc2UgZWFjaCBzaWRlIG9mIHRoZVxuICAgICAgLy8gZm9yd2FyZCBzbGFzaC5cbiAgICAgIFBhcmFtUGFyc2VTZWdtZW50PExlZnRTZWdtZW50PiBleHRlbmRzIGluZmVyIExlZnRSZXN1bHRcbiAgICAgID8gUGFyYW1QYXJzZVNlZ21lbnQ8UmlnaHRTZWdtZW50PiBleHRlbmRzIGluZmVyIFJpZ2h0UmVzdWx0XG4gICAgICAgID8gTGVmdFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgID8gLy8gSWYgdGhlIGxlZnQgc2lkZSBpcyBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIGEgcGFyYW0sIHRoZW4gY2hlY2sgaWZcbiAgICAgICAgICAgIC8vIHRoZSByaWdodCBzaWRlIGNhbiBiZSBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIHdlbGwuIElmIGJvdGggc2lkZXNcbiAgICAgICAgICAgIC8vIGNhbiBiZSBwYXJzZWQsIHRoZW4gdGhlIHJlc3VsdCBpcyBhIHVuaW9uIG9mIHRoZSB0d28gc2lkZXNcbiAgICAgICAgICAgIC8vIChyZWFkOiBcImZvb1wiIHwgXCJiYXJcIikuXG4gICAgICAgICAgICBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgICAgPyBMZWZ0UmVzdWx0IHwgUmlnaHRSZXN1bHRcbiAgICAgICAgICAgIDogTGVmdFJlc3VsdFxuICAgICAgICAgIDogLy8gSWYgdGhlIGxlZnQgc2lkZSBpcyBub3Qgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBhcyBhIHBhcmFtLCB0aGVuIGNoZWNrXG4gICAgICAgICAgLy8gaWYgb25seSB0aGUgcmlnaHQgc2lkZSBjYW4gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlIGFzIGEgcGFyYW0uIElmIGl0XG4gICAgICAgICAgLy8gY2FuLCB0aGVuIHRoZSByZXN1bHQgaXMganVzdCByaWdodCwgZWxzZSBpdCdzIGEgZmFpbHVyZS5cbiAgICAgICAgICBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICAgID8gUmlnaHRSZXN1bHRcbiAgICAgICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgICA6IC8vIElmIHRoZSBsZWZ0IHNpZGUgZGlkbid0IHBhcnNlIGludG8gYSBwYXJhbSwgdGhlbiBqdXN0IGNoZWNrIHRoZSByaWdodFxuICAgICAgLy8gc2lkZS5cbiAgICAgIFBhcmFtUGFyc2VTZWdtZW50PFJpZ2h0U2VnbWVudD4gZXh0ZW5kcyBpbmZlciBSaWdodFJlc3VsdFxuICAgICAgPyBSaWdodFJlc3VsdCBleHRlbmRzIHN0cmluZ1xuICAgICAgICA/IFJpZ2h0UmVzdWx0XG4gICAgICAgIDogUGFyYW1QYXJzZUZhaWxlZFxuICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgOiAvLyBJZiB0aGVyZSdzIG5vIGZvcndhcmQgc2xhc2gsIHRoZW4gY2hlY2sgaWYgdGhpcyBzZWdtZW50IHN0YXJ0cyB3aXRoIGFcbiAgICAvLyBjb2xvbi4gSWYgaXQgZG9lcywgdGhlbiB0aGlzIGlzIGEgZHluYW1pYyBzZWdtZW50LCBzbyB0aGUgcmVzdWx0IGlzXG4gICAgLy8ganVzdCB0aGUgcmVtYWluZGVyIG9mIHRoZSBzdHJpbmcuIE90aGVyd2lzZSwgaXQncyBhIGZhaWx1cmUuXG4gICAgU2VnbWVudCBleHRlbmRzIGA6JHtpbmZlciBSZW1haW5pbmd9YFxuICAgID8gUmVtYWluaW5nXG4gICAgOiBQYXJhbVBhcnNlRmFpbGVkO1xuXG4vLyBBdHRlbXB0IHRvIHBhcnNlIHRoZSBnaXZlbiBzdHJpbmcgc2VnbWVudC4gSWYgaXQgZmFpbHMsIHRoZW4ganVzdCByZXR1cm4gdGhlXG4vLyBwbGFpbiBzdHJpbmcgdHlwZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2suIE90aGVyd2lzZSByZXR1cm4gdGhlIHVuaW9uIG9mIHRoZVxuLy8gcGFyc2VkIHN0cmluZyBsaXRlcmFscyB0aGF0IHdlcmUgcmVmZXJlbmNlZCBhcyBkeW5hbWljIHNlZ21lbnRzIGluIHRoZSByb3V0ZS5cbmV4cG9ydCB0eXBlIFBhcmFtUGFyc2VLZXk8U2VnbWVudCBleHRlbmRzIHN0cmluZz4gPVxuICBQYXJhbVBhcnNlU2VnbWVudDxTZWdtZW50PiBleHRlbmRzIHN0cmluZ1xuICAgID8gUGFyYW1QYXJzZVNlZ21lbnQ8U2VnbWVudD5cbiAgICA6IHN0cmluZztcblxuLyoqXG4gKiBUaGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFyc2VkIGZyb20gdGhlIFVSTCBwYXRoLlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXM8S2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiA9IHtcbiAgcmVhZG9ubHkgW2tleSBpbiBLZXldOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIEEgcm91dGUgb2JqZWN0IHJlcHJlc2VudHMgYSBsb2dpY2FsIHJvdXRlLCB3aXRoIChvcHRpb25hbGx5KSBpdHMgY2hpbGRcbiAqIHJvdXRlcyBvcmdhbml6ZWQgaW4gYSB0cmVlLWxpa2Ugc3RydWN0dXJlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlT2JqZWN0IHtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNoaWxkcmVuPzogUm91dGVPYmplY3RbXTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5kZXg/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI2dlbmVyYXRlcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKHBhdGg6IHN0cmluZywgcGFyYW1zOiBQYXJhbXMgPSB7fSk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoXG4gICAgLnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGtleSkgPT4ge1xuICAgICAgaW52YXJpYW50KHBhcmFtc1trZXldICE9IG51bGwsIGBNaXNzaW5nIFwiOiR7a2V5fVwiIHBhcmFtYCk7XG4gICAgICByZXR1cm4gcGFyYW1zW2tleV0hO1xuICAgIH0pXG4gICAgLnJlcGxhY2UoL1xcLypcXCokLywgKF8pID0+XG4gICAgICBwYXJhbXNbXCIqXCJdID09IG51bGwgPyBcIlwiIDogcGFyYW1zW1wiKlwiXS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKVxuICAgICk7XG59XG5cbi8qKlxuICogQSBSb3V0ZU1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgcm91dGUgbWF0Y2hlZCBhIFVSTC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZU1hdGNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBkeW5hbWljIHBhcmFtZXRlcnMgaW4gdGhlIFVSTC5cbiAgICovXG4gIHBhcmFtczogUGFyYW1zPFBhcmFtS2V5PjtcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQgYmVmb3JlIGNoaWxkIHJvdXRlcy5cbiAgICovXG4gIHBhdGhuYW1lQmFzZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHJvdXRlIG9iamVjdCB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcm91dGU6IFJvdXRlT2JqZWN0O1xufVxuXG4vKipcbiAqIE1hdGNoZXMgdGhlIGdpdmVuIHJvdXRlcyB0byBhIGxvY2F0aW9uIGFuZCByZXR1cm5zIHRoZSBtYXRjaCBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbWF0Y2hyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUm91dGVzKFxuICByb3V0ZXM6IFJvdXRlT2JqZWN0W10sXG4gIGxvY2F0aW9uQXJnOiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZyxcbiAgYmFzZW5hbWUgPSBcIi9cIlxuKTogUm91dGVNYXRjaFtdIHwgbnVsbCB7XG4gIGxldCBsb2NhdGlvbiA9XG4gICAgdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuXG4gIGxldCBwYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUobG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCIsIGJhc2VuYW1lKTtcblxuICBpZiAocGF0aG5hbWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG5cbiAgbGV0IG1hdGNoZXMgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgbWF0Y2hlcyA9PSBudWxsICYmIGkgPCBicmFuY2hlcy5sZW5ndGg7ICsraSkge1xuICAgIG1hdGNoZXMgPSBtYXRjaFJvdXRlQnJhbmNoKGJyYW5jaGVzW2ldLCBwYXRobmFtZSk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuaW50ZXJmYWNlIFJvdXRlTWV0YSB7XG4gIHJlbGF0aXZlUGF0aDogc3RyaW5nO1xuICBjYXNlU2Vuc2l0aXZlOiBib29sZWFuO1xuICBjaGlsZHJlbkluZGV4OiBudW1iZXI7XG4gIHJvdXRlOiBSb3V0ZU9iamVjdDtcbn1cblxuaW50ZXJmYWNlIFJvdXRlQnJhbmNoIHtcbiAgcGF0aDogc3RyaW5nO1xuICBzY29yZTogbnVtYmVyO1xuICByb3V0ZXNNZXRhOiBSb3V0ZU1ldGFbXTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBicmFuY2hlczogUm91dGVCcmFuY2hbXSA9IFtdLFxuICBwYXJlbnRzTWV0YTogUm91dGVNZXRhW10gPSBbXSxcbiAgcGFyZW50UGF0aCA9IFwiXCJcbik6IFJvdXRlQnJhbmNoW10ge1xuICByb3V0ZXMuZm9yRWFjaCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IG1ldGE6IFJvdXRlTWV0YSA9IHtcbiAgICAgIHJlbGF0aXZlUGF0aDogcm91dGUucGF0aCB8fCBcIlwiLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgIGNoaWxkcmVuSW5kZXg6IGluZGV4LFxuICAgICAgcm91dGUsXG4gICAgfTtcblxuICAgIGlmIChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICBtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLFxuICAgICAgICBgQWJzb2x1dGUgcm91dGUgcGF0aCBcIiR7bWV0YS5yZWxhdGl2ZVBhdGh9XCIgbmVzdGVkIHVuZGVyIHBhdGggYCArXG4gICAgICAgICAgYFwiJHtwYXJlbnRQYXRofVwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBgICtcbiAgICAgICAgICBgbXVzdCBzdGFydCB3aXRoIHRoZSBjb21iaW5lZCBwYXRoIG9mIGFsbCBpdHMgcGFyZW50IHJvdXRlcy5gXG4gICAgICApO1xuXG4gICAgICBtZXRhLnJlbGF0aXZlUGF0aCA9IG1ldGEucmVsYXRpdmVQYXRoLnNsaWNlKHBhcmVudFBhdGgubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IGpvaW5QYXRocyhbcGFyZW50UGF0aCwgbWV0YS5yZWxhdGl2ZVBhdGhdKTtcbiAgICBsZXQgcm91dGVzTWV0YSA9IHBhcmVudHNNZXRhLmNvbmNhdChtZXRhKTtcblxuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSBzbyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyByb3V0ZSB0cmVlIGRlcHRoLWZpcnN0IGFuZCBjaGlsZCByb3V0ZXMgYXBwZWFyIGJlZm9yZSB0aGVpciBwYXJlbnRzIGluXG4gICAgLy8gdGhlIFwiZmxhdHRlbmVkXCIgdmVyc2lvbi5cbiAgICBpZiAocm91dGUuY2hpbGRyZW4gJiYgcm91dGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaW52YXJpYW50KFxuICAgICAgICByb3V0ZS5pbmRleCAhPT0gdHJ1ZSxcbiAgICAgICAgYEluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBgICtcbiAgICAgICAgICBgYWxsIGNoaWxkIHJvdXRlcyBmcm9tIHJvdXRlIHBhdGggXCIke3BhdGh9XCIuYFxuICAgICAgKTtcblxuICAgICAgZmxhdHRlblJvdXRlcyhyb3V0ZS5jaGlsZHJlbiwgYnJhbmNoZXMsIHJvdXRlc01ldGEsIHBhdGgpO1xuICAgIH1cblxuICAgIC8vIFJvdXRlcyB3aXRob3V0IGEgcGF0aCBzaG91bGRuJ3QgZXZlciBtYXRjaCBieSB0aGVtc2VsdmVzIHVubGVzcyB0aGV5IGFyZVxuICAgIC8vIGluZGV4IHJvdXRlcywgc28gZG9uJ3QgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgb2YgcG9zc2libGUgYnJhbmNoZXMuXG4gICAgaWYgKHJvdXRlLnBhdGggPT0gbnVsbCAmJiAhcm91dGUuaW5kZXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBicmFuY2hlcy5wdXNoKHsgcGF0aCwgc2NvcmU6IGNvbXB1dGVTY29yZShwYXRoLCByb3V0ZS5pbmRleCksIHJvdXRlc01ldGEgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2hlcztcbn1cblxuZnVuY3Rpb24gcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10pOiB2b2lkIHtcbiAgYnJhbmNoZXMuc29ydCgoYSwgYikgPT5cbiAgICBhLnNjb3JlICE9PSBiLnNjb3JlXG4gICAgICA/IGIuc2NvcmUgLSBhLnNjb3JlIC8vIEhpZ2hlciBzY29yZSBmaXJzdFxuICAgICAgOiBjb21wYXJlSW5kZXhlcyhcbiAgICAgICAgICBhLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpLFxuICAgICAgICAgIGIucm91dGVzTWV0YS5tYXAoKG1ldGEpID0+IG1ldGEuY2hpbGRyZW5JbmRleClcbiAgICAgICAgKVxuICApO1xufVxuXG5jb25zdCBwYXJhbVJlID0gL146XFx3KyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSAoczogc3RyaW5nKSA9PiBzID09PSBcIipcIjtcblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGg6IHN0cmluZywgaW5kZXg6IGJvb2xlYW4gfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGluaXRpYWxTY29yZSA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgaWYgKHNlZ21lbnRzLnNvbWUoaXNTcGxhdCkpIHtcbiAgICBpbml0aWFsU2NvcmUgKz0gc3BsYXRQZW5hbHR5O1xuICB9XG5cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHMpID0+ICFpc1NwbGF0KHMpKVxuICAgIC5yZWR1Y2UoXG4gICAgICAoc2NvcmUsIHNlZ21lbnQpID0+XG4gICAgICAgIHNjb3JlICtcbiAgICAgICAgKHBhcmFtUmUudGVzdChzZWdtZW50KVxuICAgICAgICAgID8gZHluYW1pY1NlZ21lbnRWYWx1ZVxuICAgICAgICAgIDogc2VnbWVudCA9PT0gXCJcIlxuICAgICAgICAgID8gZW1wdHlTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHN0YXRpY1NlZ21lbnRWYWx1ZSksXG4gICAgICBpbml0aWFsU2NvcmVcbiAgICApO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXhlcyhhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pOiBudW1iZXIge1xuICBsZXQgc2libGluZ3MgPVxuICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLnNsaWNlKDAsIC0xKS5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYltpXSk7XG5cbiAgcmV0dXJuIHNpYmxpbmdzXG4gICAgPyAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gICAgICAvLyBmaXJzdC4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIGhhdmUgZmluZS1ncmFpbmVkIGNvbnRyb2wgb3ZlciB0aGUgbWF0Y2hpbmdcbiAgICAgIC8vIGJlaGF2aW9yIGJ5IHNpbXBseSBwdXR0aW5nIHJvdXRlcyB3aXRoIGlkZW50aWNhbCBwYXRocyBpbiB0aGUgb3JkZXIgdGhleVxuICAgICAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICAgICAgYVthLmxlbmd0aCAtIDFdIC0gYltiLmxlbmd0aCAtIDFdXG4gICAgOiAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gICAgICAvLyBzbyB0aGV5IHNvcnQgZXF1YWxseS5cbiAgICAgIDA7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVCcmFuY2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxuICBicmFuY2g6IFJvdXRlQnJhbmNoLFxuICBwYXRobmFtZTogc3RyaW5nXG4pOiBSb3V0ZU1hdGNoPFBhcmFtS2V5PltdIHwgbnVsbCB7XG4gIGxldCB7IHJvdXRlc01ldGEgfSA9IGJyYW5jaDtcblxuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXNNZXRhLmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IG1ldGEgPSByb3V0ZXNNZXRhW2ldO1xuICAgIGxldCBlbmQgPSBpID09PSByb3V0ZXNNZXRhLmxlbmd0aCAtIDE7XG4gICAgbGV0IHJlbWFpbmluZ1BhdGhuYW1lID1cbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCJcbiAgICAgICAgPyBwYXRobmFtZVxuICAgICAgICA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aChcbiAgICAgIHsgcGF0aDogbWV0YS5yZWxhdGl2ZVBhdGgsIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSwgZW5kIH0sXG4gICAgICByZW1haW5pbmdQYXRobmFtZVxuICAgICk7XG5cbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICAgIE9iamVjdC5hc3NpZ24obWF0Y2hlZFBhcmFtcywgbWF0Y2gucGFyYW1zKTtcblxuICAgIGxldCByb3V0ZSA9IG1ldGEucm91dGU7XG5cbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgcGFyYW1zOiBtYXRjaGVkUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZV0pLFxuICAgICAgcGF0aG5hbWVCYXNlOiBub3JtYWxpemVQYXRobmFtZShcbiAgICAgICAgam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gICAgICApLFxuICAgICAgcm91dGUsXG4gICAgfSk7XG5cbiAgICBpZiAobWF0Y2gucGF0aG5hbWVCYXNlICE9PSBcIi9cIikge1xuICAgICAgbWF0Y2hlZFBhdGhuYW1lID0gam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG4vKipcbiAqIEEgUGF0aFBhdHRlcm4gaXMgdXNlZCB0byBtYXRjaCBvbiBzb21lIHBvcnRpb24gb2YgYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFBhdHRlcm48UGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogQSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdCBhIFVSTCBwYXRobmFtZS4gTWF5IGNvbnRhaW4gYDppZGAtc3R5bGUgc2VnbWVudHNcbiAgICogdG8gaW5kaWNhdGUgcGxhY2Vob2xkZXJzIGZvciBkeW5hbWljIHBhcmFtZXRlcnMuIE1heSBhbHNvIGVuZCB3aXRoIGAvKmAgdG9cbiAgICogaW5kaWNhdGUgbWF0Y2hpbmcgdGhlIHJlc3Qgb2YgdGhlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIHBhdGg6IFBhdGg7XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoZSBzdGF0aWMgcG9ydGlvbnMgb2YgdGhlIGBwYXRoYCBzaG91bGQgYmUgbWF0Y2hlZCBpblxuICAgKiB0aGUgc2FtZSBjYXNlLlxuICAgKi9cbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoaXMgcGF0dGVybiBzaG91bGQgbWF0Y2ggdGhlIGVudGlyZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBlbmQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgUGF0aE1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgUGF0aFBhdHRlcm4gbWF0Y2hlZCBvbiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcGF0dGVybjogUGF0aFBhdHRlcm47XG59XG5cbnR5cGUgTXV0YWJsZTxUPiA9IHtcbiAgLXJlYWRvbmx5IFtQIGluIGtleW9mIFRdOiBUW1BdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtYXRjaHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUGF0aDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KFxuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgsXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHsgcGF0aDogcGF0dGVybiwgY2FzZVNlbnNpdGl2ZTogZmFsc2UsIGVuZDogdHJ1ZSB9O1xuICB9XG5cbiAgbGV0IFttYXRjaGVyLCBwYXJhbU5hbWVzXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcblxuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0gcGFyYW1OYW1lcy5yZWR1Y2U8TXV0YWJsZTxQYXJhbXM+PihcbiAgICAobWVtbywgcGFyYW1OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwYXRobmFtZUJhc2UgaGVyZSB1c2luZyB0aGUgcmF3IHNwbGF0IHZhbHVlXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWVcbiAgICAgICAgICAuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKVxuICAgICAgICAgIC5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgICB9XG5cbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIixcbiAgICAgICAgcGFyYW1OYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm4sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgZW5kID0gdHJ1ZVxuKTogW1JlZ0V4cCwgc3RyaW5nW11dIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcblxuICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9XG4gICAgXCJeXCIgK1xuICAgIHBhdGhcbiAgICAgIC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAgICAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgICAgIC5yZXBsYWNlKC9bXFxcXC4qK14kP3t9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgICAgIC5yZXBsYWNlKC86KFxcdyspL2csIChfOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICByZXR1cm4gXCIoW15cXFxcL10rKVwiO1xuICAgICAgfSk7XG5cbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgcGFyYW1OYW1lcy5wdXNoKFwiKlwiKTtcbiAgICByZWdleHBTb3VyY2UgKz1cbiAgICAgIHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIlxuICAgICAgICA/IFwiKC4qKSRcIiAvLyBBbHJlYWR5IG1hdGNoZWQgdGhlIGluaXRpYWwgLywganVzdCBtYXRjaCB0aGUgcmVzdFxuICAgICAgICA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7IC8vIERvbid0IGluY2x1ZGUgdGhlIC8gaW4gcGFyYW1zW1wiKlwiXVxuICB9IGVsc2Uge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBlbmRcbiAgICAgID8gXCJcXFxcLyokXCIgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgOiAvLyBPdGhlcndpc2UsIG1hdGNoIGEgd29yZCBib3VuZGFyeSBvciBhIHByb2NlZWRpbmcgLy4gVGhlIHdvcmQgYm91bmRhcnkgcmVzdHJpY3RzXG4gICAgICAgIC8vIHBhcmVudCByb3V0ZXMgdG8gbWF0Y2hpbmcgb25seSB0aGVpciBvd24gd29yZHMgYW5kIG5vdGhpbmcgbW9yZSwgZS5nLiBwYXJlbnRcbiAgICAgICAgLy8gcm91dGUgXCIvaG9tZVwiIHNob3VsZCBub3QgbWF0Y2ggXCIvaG9tZTJcIi5cbiAgICAgICAgLy8gQWRkaXRpb25hbGx5LCBhbGxvdyBwYXRocyBzdGFydGluZyB3aXRoIGAuYCwgYC1gLCBgfmAsIGFuZCB1cmwtZW5jb2RlZCBlbnRpdGllcyxcbiAgICAgICAgLy8gYnV0IGRvIG5vdCBjb25zdW1lIHRoZSBjaGFyYWN0ZXIgaW4gdGhlIG1hdGNoZWQgcGF0aCBzbyB0aGV5IGNhbiBtYXRjaCBhZ2FpbnN0XG4gICAgICAgIC8vIG5lc3RlZCBwYXRocy5cbiAgICAgICAgXCIoPzooPz1bLn4tXXwlWzAtOUEtRl17Mn0pfFxcXFxifFxcXFwvfCQpXCI7XG4gIH1cblxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogXCJpXCIpO1xuXG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1OYW1lc107XG59XG5cbmZ1bmN0aW9uIHNhZmVseURlY29kZVVSSUNvbXBvbmVudCh2YWx1ZTogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgdmFsdWUgZm9yIHRoZSBVUkwgcGFyYW0gXCIke3BhcmFtTmFtZX1cIiB3aWxsIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2VgICtcbiAgICAgICAgYCB0aGUgc3RyaW5nIFwiJHt2YWx1ZX1cIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseWAgK1xuICAgICAgICBgIGR1ZSB0byBhIGJhZCBwZXJjZW50IGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcmVzb2x2ZXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvOiBUbywgZnJvbVBhdGhuYW1lID0gXCIvXCIpOiBQYXRoIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuXG4gIGxldCBwYXRobmFtZSA9IHRvUGF0aG5hbWVcbiAgICA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgID8gdG9QYXRobmFtZVxuICAgICAgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKVxuICAgIDogZnJvbVBhdGhuYW1lO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpLFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUocmVsYXRpdmVQYXRoOiBzdHJpbmcsIGZyb21QYXRobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHNlZ21lbnRzID0gZnJvbVBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XG5cbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgLy8gS2VlcCB0aGUgcm9vdCBcIlwiIHNlZ21lbnQgc28gdGhlIHBhdGhuYW1lIHN0YXJ0cyBhdCAvXG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkgc2VnbWVudHMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVUbyhcbiAgdG9Bcmc6IFRvLFxuICByb3V0ZVBhdGhuYW1lczogc3RyaW5nW10sXG4gIGxvY2F0aW9uUGF0aG5hbWU6IHN0cmluZ1xuKTogUGF0aCB7XG4gIGxldCB0byA9IHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0b0FyZykgOiB0b0FyZztcbiAgbGV0IHRvUGF0aG5hbWUgPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIiA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG5cbiAgLy8gSWYgYSBwYXRobmFtZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIGB0b2AsIGl0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGVcbiAgLy8gcm91dGUgY29udGV4dC4gVGhpcyBpcyBleHBsYWluZWQgaW4gYE5vdGUgb24gYDxMaW5rIHRvPmAgdmFsdWVzYCBpbiBvdXJcbiAgLy8gbWlncmF0aW9uIGd1aWRlIGZyb20gdjUgYXMgYSBtZWFucyBvZiBkaXNhbWJpZ3VhdGlvbiBiZXR3ZWVuIGB0b2AgdmFsdWVzXG4gIC8vIHRoYXQgYmVnaW4gd2l0aCBgL2AgYW5kIHRob3NlIHRoYXQgZG8gbm90LiBIb3dldmVyLCB0aGlzIGlzIHByb2JsZW1hdGljIGZvclxuICAvLyBgdG9gIHZhbHVlcyB0aGF0IGRvIG5vdCBwcm92aWRlIGEgcGF0aG5hbWUuIGB0b2AgY2FuIHNpbXBseSBiZSBhIHNlYXJjaCBvclxuICAvLyBoYXNoIHN0cmluZywgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgYXNzdW1lIHRoYXQgdGhlIG5hdmlnYXRpb24gaXMgcmVsYXRpdmVcbiAgLy8gdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24ncyBwYXRobmFtZSBhbmQgKm5vdCogdGhlIHJvdXRlIHBhdGhuYW1lLlxuICBsZXQgZnJvbTogc3RyaW5nO1xuICBpZiAodG9QYXRobmFtZSA9PSBudWxsKSB7XG4gICAgZnJvbSA9IGxvY2F0aW9uUGF0aG5hbWU7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHJvdXRlUGF0aG5hbWVJbmRleCA9IHJvdXRlUGF0aG5hbWVzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAodG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7XG5cbiAgICAgIC8vIEVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zIFwiZ28gdXAgb25lIHJvdXRlXCIgaW5zdGVhZCBvZiBcImdvIHVwIG9uZVxuICAgICAgLy8gVVJMIHNlZ21lbnRcIi4gIFRoaXMgaXMgYSBrZXkgZGlmZmVyZW5jZSBmcm9tIGhvdyA8YSBocmVmPiB3b3JrcyBhbmQgYVxuICAgICAgLy8gbWFqb3IgcmVhc29uIHdlIGNhbGwgdGhpcyBhIFwidG9cIiB2YWx1ZSBpbnN0ZWFkIG9mIGEgXCJocmVmXCIuXG4gICAgICB3aGlsZSAodG9TZWdtZW50c1swXSA9PT0gXCIuLlwiKSB7XG4gICAgICAgIHRvU2VnbWVudHMuc2hpZnQoKTtcbiAgICAgICAgcm91dGVQYXRobmFtZUluZGV4IC09IDE7XG4gICAgICB9XG5cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSBcIi4uXCIgc2VnbWVudHMgdGhhbiBwYXJlbnQgcm91dGVzLCByZXNvbHZlIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHJvb3QgLyBVUkwuXG4gICAgZnJvbSA9IHJvdXRlUGF0aG5hbWVJbmRleCA+PSAwID8gcm91dGVQYXRobmFtZXNbcm91dGVQYXRobmFtZUluZGV4XSA6IFwiL1wiO1xuICB9XG5cbiAgbGV0IHBhdGggPSByZXNvbHZlUGF0aCh0bywgZnJvbSk7XG5cbiAgLy8gRW5zdXJlIHRoZSBwYXRobmFtZSBoYXMgYSB0cmFpbGluZyBzbGFzaCBpZiB0aGUgb3JpZ2luYWwgdG8gdmFsdWUgaGFkIG9uZS5cbiAgaWYgKFxuICAgIHRvUGF0aG5hbWUgJiZcbiAgICB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJlxuICAgIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmXG4gICAgIXBhdGgucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpXG4gICkge1xuICAgIHBhdGgucGF0aG5hbWUgKz0gXCIvXCI7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvUGF0aG5hbWUodG86IFRvKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZSBhcyAvIHBhdGhzXG4gIHJldHVybiB0byA9PT0gXCJcIiB8fCAodG8gYXMgUGF0aCkucGF0aG5hbWUgPT09IFwiXCJcbiAgICA/IFwiL1wiXG4gICAgOiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCJcbiAgICA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWVcbiAgICA6IHRvLnBhdGhuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgYmFzZW5hbWU6IHN0cmluZ1xuKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcblxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KGJhc2VuYW1lLmxlbmd0aCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKGJhc2VuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG59XG5cbmV4cG9ydCBjb25zdCBqb2luUGF0aHMgPSAocGF0aHM6IHN0cmluZ1tdKTogc3RyaW5nID0+XG4gIHBhdGhzLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xuXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplUGF0aG5hbWUgPSAocGF0aG5hbWU6IHN0cmluZyk6IHN0cmluZyA9PlxuICBwYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpO1xuXG5jb25zdCBub3JtYWxpemVTZWFyY2ggPSAoc2VhcmNoOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgIXNlYXJjaCB8fCBzZWFyY2ggPT09IFwiP1wiXG4gICAgPyBcIlwiXG4gICAgOiBzZWFyY2guc3RhcnRzV2l0aChcIj9cIilcbiAgICA/IHNlYXJjaFxuICAgIDogXCI/XCIgKyBzZWFyY2g7XG5cbmNvbnN0IG5vcm1hbGl6ZUhhc2ggPSAoaGFzaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFoYXNoIHx8IGhhc2ggPT09IFwiI1wiID8gXCJcIiA6IGhhc2guc3RhcnRzV2l0aChcIiNcIikgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IExvY2F0aW9uLCBQYXRoLCBUbyB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQgeyBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsIHBhcnNlUGF0aCB9IGZyb20gXCJoaXN0b3J5XCI7XG5cbmltcG9ydCB7IExvY2F0aW9uQ29udGV4dCwgTmF2aWdhdGlvbkNvbnRleHQsIFJvdXRlQ29udGV4dCB9IGZyb20gXCIuL2NvbnRleHRcIjtcbmltcG9ydCB0eXBlIHtcbiAgUGFyYW1QYXJzZUtleSxcbiAgUGFyYW1zLFxuICBQYXRoTWF0Y2gsXG4gIFBhdGhQYXR0ZXJuLFxuICBSb3V0ZU1hdGNoLFxuICBSb3V0ZU9iamVjdCxcbn0gZnJvbSBcIi4vcm91dGVyXCI7XG5pbXBvcnQge1xuICBnZXRUb1BhdGhuYW1lLFxuICBpbnZhcmlhbnQsXG4gIGpvaW5QYXRocyxcbiAgbWF0Y2hQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgcmVzb2x2ZVRvLFxuICB3YXJuaW5nLFxuICB3YXJuaW5nT25jZSxcbn0gZnJvbSBcIi4vcm91dGVyXCI7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBocmVmIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmdcbiAqIGN1c3RvbSBsaW5rcyB0aGF0IGFyZSBhbHNvIGFjY2Vzc2libGUgYW5kIHByZXNlcnZlIHJpZ2h0LWNsaWNrIGJlaGF2aW9yLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlaHJlZlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSHJlZih0bzogVG8pOiBzdHJpbmcge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IGhhc2gsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG5cbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBsZXQgdG9QYXRobmFtZSA9IGdldFRvUGF0aG5hbWUodG8pO1xuICAgIGxldCBlbmRzV2l0aFNsYXNoID0gdG9QYXRobmFtZSAhPSBudWxsICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAgIGpvaW5lZFBhdGhuYW1lID1cbiAgICAgIHBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICA/IGJhc2VuYW1lICsgKGVuZHNXaXRoU2xhc2ggPyBcIi9cIiA6IFwiXCIpXG4gICAgICAgIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7IHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYSA8Um91dGVyPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZWlucm91dGVyY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYXRpb24oKTogTG9jYXRpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xuICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRpb250eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpOiBOYXZpZ2F0aW9uVHlwZSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBVUkwgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUgbWF0Y2hlcyB0aGUgY3VycmVudCBVUkwuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29tcG9uZW50cyB0aGF0IG5lZWQgdG8ga25vdyBcImFjdGl2ZVwiIHN0YXRlLCBlLmcuXG4gKiA8TmF2TGluaz4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VtYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgpOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aDxQYXJhbUtleSwgUGF0aD4ocGF0dGVybiwgcGF0aG5hbWUpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVGdW5jdGlvbiB7XG4gICh0bzogVG8sIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xuICAoZGVsdGE6IG51bWJlcik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVPcHRpb25zIHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSA8TGluaz5zLCBidXRcbiAqIG1heSBhbHNvIGJlIHVzZWQgYnkgb3RoZXIgZWxlbWVudHMgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpOiBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBiYXNlbmFtZSwgbmF2aWdhdG9yIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiBtYXRjaC5wYXRobmFtZUJhc2UpXG4gICk7XG5cbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcblxuICBsZXQgbmF2aWdhdGU6IE5hdmlnYXRlRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodG86IFRvIHwgbnVtYmVyLCBvcHRpb25zOiBOYXZpZ2F0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYWN0aXZlUmVmLmN1cnJlbnQsXG4gICAgICAgIGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiBgICtcbiAgICAgICAgICBgeW91ciBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQuYFxuICAgICAgKTtcblxuICAgICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWVcbiAgICAgICk7XG5cbiAgICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aC5wYXRobmFtZSA9IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9wdGlvbnMuc3RhdGVcbiAgICAgICk7XG4gICAgfSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvciwgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lXVxuICApO1xuXG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cblxuY29uc3QgT3V0bGV0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5rbm93bj4obnVsbCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS5cbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlb3V0bGV0Y29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dDxDb250ZXh0ID0gdW5rbm93bj4oKTogQ29udGV4dCB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KE91dGxldENvbnRleHQpIGFzIENvbnRleHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuIFVzZWQgaW50ZXJuYWxseSBieSA8T3V0bGV0PiB0byByZW5kZXIgY2hpbGQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dD86IHVua25vd24pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPE91dGxldENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHR9PntvdXRsZXR9PC9PdXRsZXRDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG91dGxldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgcGFyYW1zIGZyb20gdGhlIGN1cnJlbnRcbiAqIFVSTCB0aGF0IHdlcmUgbWF0Y2hlZCBieSB0aGUgcm91dGUgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFyYW1zPFxuICBQYXJhbXNPcktleSBleHRlbmRzIHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSBzdHJpbmdcbj4oKTogUmVhZG9ubHk8XG4gIFtQYXJhbXNPcktleV0gZXh0ZW5kcyBbc3RyaW5nXSA/IFBhcmFtczxQYXJhbXNPcktleT4gOiBQYXJ0aWFsPFBhcmFtc09yS2V5PlxuPiB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiByb3V0ZU1hdGNoID8gKHJvdXRlTWF0Y2gucGFyYW1zIGFzIGFueSkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXJlc29sdmVkcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvOiBUbyk6IFBhdGgge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShcbiAgICBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoLnBhdGhuYW1lQmFzZSlcbiAgKTtcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSksXG4gICAgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZz86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgbWF0Y2hlczogcGFyZW50TWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIC8vIFlvdSB3b24ndCBnZXQgYSB3YXJuaW5nIGFib3V0IDIgZGlmZmVyZW50IDxSb3V0ZXM+IHVuZGVyIGEgPFJvdXRlPlxuICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXG4gICAgLy8gY2Fubm90IGV2ZW4gZ2l2ZSB0aGUgd2FybmluZyB1bmxlc3MgdGhleSBsYW5kIGF0IHRoZSBwYXJlbnQgcm91dGUuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vXG4gICAgLy8gPFJvdXRlcz5cbiAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxuICAgIC8vICAgICAgIGl0IHdpbGwgbmV2ZXIgbWF0Y2ggL2Jsb2cvcG9zdC8xMjMgKi99XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2dcIiBlbGVtZW50PXs8QmxvZyAvPn0gLz5cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxuICAgIC8vIDwvUm91dGVzPlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcbiAgICAvLyAgIHJldHVybiAoXG4gICAgLy8gICAgIDxSb3V0ZXM+XG4gICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxuICAgIC8vICAgICA8L1JvdXRlcz5cbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIGxldCBwYXJlbnRQYXRoID0gKHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGgpIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UoXG4gICAgICBwYXJlbnRQYXRobmFtZSxcbiAgICAgICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSxcbiAgICAgIGBZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIFxcYHVzZVJvdXRlcygpXFxgKSBhdCBgICtcbiAgICAgICAgYFwiJHtwYXJlbnRQYXRobmFtZX1cIiAodW5kZXIgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+KSBidXQgdGhlIGAgK1xuICAgICAgICBgcGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFwiKlwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBgICtcbiAgICAgICAgYGRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIGAgK1xuICAgICAgICBgcm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxcblxcbmAgK1xuICAgICAgICBgUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPiB0byA8Um91dGUgYCArXG4gICAgICAgIGBwYXRoPVwiJHtwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogYCR7cGFyZW50UGF0aH0vKmB9XCI+LmBcbiAgICApO1xuICB9XG5cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID1cbiAgICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHxcbiAgICAgICAgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWU/LnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSxcbiAgICAgIGBXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIFxcYDxSb3V0ZXMgbG9jYXRpb24+XFxgIG9yIFxcYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKVxcYCwgYCArXG4gICAgICAgIGB0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgYCArXG4gICAgICAgIGBtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFwiJHtwYXJlbnRQYXRobmFtZUJhc2V9XCIgYCArXG4gICAgICAgIGBidXQgcGF0aG5hbWUgXCIke3BhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lfVwiIHdhcyBnaXZlbiBpbiB0aGUgXFxgbG9jYXRpb25cXGAgcHJvcC5gXG4gICAgKTtcblxuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG5cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgPyBwYXRobmFtZVxuICAgICAgOiBwYXRobmFtZS5zbGljZShwYXJlbnRQYXRobmFtZUJhc2UubGVuZ3RoKSB8fCBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHsgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lIH0pO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybmluZyhcbiAgICAgIHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCxcbiAgICAgIGBObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGBcbiAgICApO1xuXG4gICAgd2FybmluZyhcbiAgICAgIG1hdGNoZXMgPT0gbnVsbCB8fFxuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuICAgICAgYE1hdGNoZWQgbGVhZiByb3V0ZSBhdCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGRvZXMgbm90IGhhdmUgYW4gZWxlbWVudC4gYCArXG4gICAgICAgIGBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXCJlbXB0eVwiIHBhZ2UuYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gX3JlbmRlck1hdGNoZXMoXG4gICAgbWF0Y2hlcyAmJlxuICAgICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UGFyYW1zLCBtYXRjaC5wYXJhbXMpLFxuICAgICAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgICAgICBwYXRobmFtZUJhc2U6XG4gICAgICAgICAgICBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICAgICAgICAgID8gcGFyZW50UGF0aG5hbWVCYXNlXG4gICAgICAgICAgICAgIDogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsIG1hdGNoLnBhdGhuYW1lQmFzZV0pLFxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICBwYXJlbnRNYXRjaGVzXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVuZGVyTWF0Y2hlcyhcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdIHwgbnVsbCxcbiAgcGFyZW50TWF0Y2hlczogUm91dGVNYXRjaFtdID0gW11cbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgPFJvdXRlQ29udGV4dC5Qcm92aWRlclxuICAgICAgICBjaGlsZHJlbj17XG4gICAgICAgICAgbWF0Y2gucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkID8gbWF0Y2gucm91dGUuZWxlbWVudCA6IG91dGxldFxuICAgICAgICB9XG4gICAgICAgIHZhbHVlPXt7XG4gICAgICAgICAgb3V0bGV0LFxuICAgICAgICAgIG1hdGNoZXM6IHBhcmVudE1hdGNoZXMuY29uY2F0KG1hdGNoZXMuc2xpY2UoMCwgaW5kZXggKyAxKSksXG4gICAgICAgIH19XG4gICAgICAvPlxuICAgICk7XG4gIH0sIG51bGwgYXMgUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCk7XG59XG4iLCJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgSW5pdGlhbEVudHJ5LCBMb2NhdGlvbiwgTWVtb3J5SGlzdG9yeSwgVG8gfSBmcm9tIFwiaGlzdG9yeVwiO1xuaW1wb3J0IHtcbiAgQWN0aW9uIGFzIE5hdmlnYXRpb25UeXBlLFxuICBjcmVhdGVNZW1vcnlIaXN0b3J5LFxuICBwYXJzZVBhdGgsXG59IGZyb20gXCJoaXN0b3J5XCI7XG5cbmltcG9ydCB7IExvY2F0aW9uQ29udGV4dCwgTmF2aWdhdGlvbkNvbnRleHQsIE5hdmlnYXRvciB9IGZyb20gXCIuL2NvbnRleHRcIjtcbmltcG9ydCB7XG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUm91dGVzLFxuICBfcmVuZGVyTWF0Y2hlcyxcbn0gZnJvbSBcIi4vaG9va3NcIjtcbmltcG9ydCB0eXBlIHsgUm91dGVNYXRjaCwgUm91dGVPYmplY3QgfSBmcm9tIFwiLi9yb3V0ZXJcIjtcbmltcG9ydCB7IGludmFyaWFudCwgbm9ybWFsaXplUGF0aG5hbWUsIHN0cmlwQmFzZW5hbWUsIHdhcm5pbmcgfSBmcm9tIFwiLi9yb3V0ZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNZW1vcnlSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaW5pdGlhbEVudHJpZXM/OiBJbml0aWFsRW50cnlbXTtcbiAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgYWxsIGVudHJpZXMgaW4gbWVtb3J5LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbWVtb3J5cm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoe1xuICBiYXNlbmFtZSxcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxFbnRyaWVzLFxuICBpbml0aWFsSW5kZXgsXG59OiBNZW1vcnlSb3V0ZXJQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPE1lbW9yeUhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZU1lbW9yeUhpc3RvcnkoeyBpbml0aWFsRW50cmllcywgaW5pdGlhbEluZGV4IH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlUHJvcHMge1xuICB0bzogVG87XG4gIHJlcGxhY2U/OiBib29sZWFuO1xuICBzdGF0ZT86IGFueTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIE5vdGU6IFRoaXMgQVBJIGlzIG1vc3RseSB1c2VmdWwgaW4gUmVhY3QuQ29tcG9uZW50IHN1YmNsYXNzZXMgdGhhdCBhcmUgbm90XG4gKiBhYmxlIHRvIHVzZSBob29rcy4gSW4gZnVuY3Rpb25hbCBjb21wb25lbnRzLCB3ZSByZWNvbW1lbmQgeW91IHVzZSB0aGVcbiAqIGB1c2VOYXZpZ2F0ZWAgaG9vayBpbnN0ZWFkLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjbmF2aWdhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5hdmlnYXRlKHsgdG8sIHJlcGxhY2UsIHN0YXRlIH06IE5hdmlnYXRlUHJvcHMpOiBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gICAgLy8gdGhlIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICB3YXJuaW5nKFxuICAgICFSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KS5zdGF0aWMsXG4gICAgYDxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gYCArXG4gICAgICBgVGhpcyBpcyBhIG5vLW9wLCBidXQgeW91IHNob3VsZCBtb2RpZnkgeW91ciBjb2RlIHNvIHRoZSA8TmF2aWdhdGU+IGlzIGAgK1xuICAgICAgYG9ubHkgZXZlciByZW5kZXJlZCBpbiByZXNwb25zZSB0byBzb21lIHVzZXIgaW50ZXJhY3Rpb24gb3Igc3RhdGUgY2hhbmdlLmBcbiAgKTtcblxuICBsZXQgbmF2aWdhdGUgPSB1c2VOYXZpZ2F0ZSgpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIG5hdmlnYXRlKHRvLCB7IHJlcGxhY2UsIHN0YXRlIH0pO1xuICB9KTtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdXRsZXRQcm9wcyB7XG4gIGNvbnRleHQ/OiB1bmtub3duO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIGNoaWxkIHJvdXRlJ3MgZWxlbWVudCwgaWYgdGhlcmUgaXMgb25lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBPdXRsZXQocHJvcHM6IE91dGxldFByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGluZGV4PzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXRoUm91dGVQcm9wcyB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGluZGV4PzogZmFsc2U7XG4gIHBhdGg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXlvdXRSb3V0ZVByb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4Um91dGVQcm9wcyB7XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGUgfCBudWxsO1xuICBpbmRleDogdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZWNsYXJlcyBhbiBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkIGF0IGEgY2VydGFpbiBVUkwgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZShcbiAgX3Byb3BzOiBQYXRoUm91dGVQcm9wcyB8IExheW91dFJvdXRlUHJvcHMgfCBJbmRleFJvdXRlUHJvcHNcbik6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgZmFsc2UsXG4gICAgYEEgPFJvdXRlPiBpcyBvbmx5IGV2ZXIgdG8gYmUgdXNlZCBhcyB0aGUgY2hpbGQgb2YgPFJvdXRlcz4gZWxlbWVudCwgYCArXG4gICAgICBgbmV2ZXIgcmVuZGVyZWQgZGlyZWN0bHkuIFBsZWFzZSB3cmFwIHlvdXIgPFJvdXRlPiBpbiBhIDxSb3V0ZXM+LmBcbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb246IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nO1xuICBuYXZpZ2F0aW9uVHlwZT86IE5hdmlnYXRpb25UeXBlO1xuICBuYXZpZ2F0b3I6IE5hdmlnYXRvcjtcbiAgc3RhdGljPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIDxSb3V0ZXI+IGRpcmVjdGx5LiBJbnN0ZWFkLCB5b3UnbGwgcmVuZGVyIGFcbiAqIHJvdXRlciB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdG8geW91ciBlbnZpcm9ubWVudCBzdWNoIGFzIGEgPEJyb3dzZXJSb3V0ZXI+XG4gKiBpbiB3ZWIgYnJvd3NlcnMgb3IgYSA8U3RhdGljUm91dGVyPiBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVyKHtcbiAgYmFzZW5hbWU6IGJhc2VuYW1lUHJvcCA9IFwiL1wiLFxuICBjaGlsZHJlbiA9IG51bGwsXG4gIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gIG5hdmlnYXRpb25UeXBlID0gTmF2aWdhdGlvblR5cGUuUG9wLFxuICBuYXZpZ2F0b3IsXG4gIHN0YXRpYzogc3RhdGljUHJvcCA9IGZhbHNlLFxufTogUm91dGVyUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgICF1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICBgWW91IGNhbm5vdCByZW5kZXIgYSA8Um91dGVyPiBpbnNpZGUgYW5vdGhlciA8Um91dGVyPi5gICtcbiAgICAgIGAgWW91IHNob3VsZCBuZXZlciBoYXZlIG1vcmUgdGhhbiBvbmUgaW4geW91ciBhcHAuYFxuICApO1xuXG4gIGxldCBiYXNlbmFtZSA9IG5vcm1hbGl6ZVBhdGhuYW1lKGJhc2VuYW1lUHJvcCk7XG4gIGxldCBuYXZpZ2F0aW9uQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oXG4gICAgKCkgPT4gKHsgYmFzZW5hbWUsIG5hdmlnYXRvciwgc3RhdGljOiBzdGF0aWNQcm9wIH0pLFxuICAgIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXVxuICApO1xuXG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cblxuICBsZXQge1xuICAgIHBhdGhuYW1lID0gXCIvXCIsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIixcbiAgICBzdGF0ZSA9IG51bGwsXG4gICAga2V5ID0gXCJkZWZhdWx0XCIsXG4gIH0gPSBsb2NhdGlvblByb3A7XG5cbiAgbGV0IGxvY2F0aW9uID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHRyYWlsaW5nUGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSk7XG5cbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aG5hbWU6IHRyYWlsaW5nUGF0aG5hbWUsXG4gICAgICBzZWFyY2gsXG4gICAgICBoYXNoLFxuICAgICAgc3RhdGUsXG4gICAgICBrZXksXG4gICAgfTtcbiAgfSwgW2Jhc2VuYW1lLCBwYXRobmFtZSwgc2VhcmNoLCBoYXNoLCBzdGF0ZSwga2V5XSk7XG5cbiAgd2FybmluZyhcbiAgICBsb2NhdGlvbiAhPSBudWxsLFxuICAgIGA8Um91dGVyIGJhc2VuYW1lPVwiJHtiYXNlbmFtZX1cIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBgICtcbiAgICAgIGBcIiR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofVwiIGJlY2F1c2UgaXQgZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgYCArXG4gICAgICBgYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuYFxuICApO1xuXG4gIGlmIChsb2NhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxOYXZpZ2F0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bmF2aWdhdGlvbkNvbnRleHR9PlxuICAgICAgPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICAgIHZhbHVlPXt7IGxvY2F0aW9uLCBuYXZpZ2F0aW9uVHlwZSB9fVxuICAgICAgLz5cbiAgICA8L05hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlc1Byb3BzIHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGxvY2F0aW9uPzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIGEgbmVzdGVkIHRyZWUgb2YgPFJvdXRlPiBlbGVtZW50cyB0aGF0IHJlbmRlcnMgdGhlIGJyYW5jaFxuICogdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlcyh7XG4gIGNoaWxkcmVuLFxuICBsb2NhdGlvbixcbn06IFJvdXRlc1Byb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiB1c2VSb3V0ZXMoY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGNoaWxkcmVuKSwgbG9jYXRpb24pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBVVElMU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb3V0ZSBjb25maWcgZnJvbSBhIFJlYWN0IFwiY2hpbGRyZW5cIiBvYmplY3QsIHdoaWNoIGlzIHVzdWFsbHlcbiAqIGVpdGhlciBhIGA8Um91dGU+YCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZW0uIFVzZWQgaW50ZXJuYWxseSBieVxuICogYDxSb3V0ZXM+YCB0byBjcmVhdGUgYSByb3V0ZSBjb25maWcgZnJvbSBpdHMgY2hpbGRyZW4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNjcmVhdGVyb3V0ZXNmcm9tY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZVxuKTogUm91dGVPYmplY3RbXSB7XG4gIGxldCByb3V0ZXM6IFJvdXRlT2JqZWN0W10gPSBbXTtcblxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoZWxlbWVudCkgPT4ge1xuICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIElnbm9yZSBub24tZWxlbWVudHMuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBtb3JlIGVhc2lseSBpbmxpbmVcbiAgICAgIC8vIGNvbmRpdGlvbmFscyBpbiB0aGVpciByb3V0ZSBjb25maWcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgIC8vIFRyYW5zcGFyZW50bHkgc3VwcG9ydCBSZWFjdC5GcmFnbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAgcm91dGVzLnB1c2guYXBwbHkoXG4gICAgICAgIHJvdXRlcyxcbiAgICAgICAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludmFyaWFudChcbiAgICAgIGVsZW1lbnQudHlwZSA9PT0gUm91dGUsXG4gICAgICBgWyR7XG4gICAgICAgIHR5cGVvZiBlbGVtZW50LnR5cGUgPT09IFwic3RyaW5nXCIgPyBlbGVtZW50LnR5cGUgOiBlbGVtZW50LnR5cGUubmFtZVxuICAgICAgfV0gaXMgbm90IGEgPFJvdXRlPiBjb21wb25lbnQuIEFsbCBjb21wb25lbnQgY2hpbGRyZW4gb2YgPFJvdXRlcz4gbXVzdCBiZSBhIDxSb3V0ZT4gb3IgPFJlYWN0LkZyYWdtZW50PmBcbiAgICApO1xuXG4gICAgbGV0IHJvdXRlOiBSb3V0ZU9iamVjdCA9IHtcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIGluZGV4OiBlbGVtZW50LnByb3BzLmluZGV4LFxuICAgICAgcGF0aDogZWxlbWVudC5wcm9wcy5wYXRoLFxuICAgIH07XG5cbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcm91dGVzLnB1c2gocm91dGUpO1xuICB9KTtcblxuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHJlc3VsdCBvZiBgbWF0Y2hSb3V0ZXMoKWAgaW50byBhIFJlYWN0IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNYXRjaGVzKFxuICBtYXRjaGVzOiBSb3V0ZU1hdGNoW10gfCBudWxsXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgUmVhY3RWZXJzaW9uID0gJzE4LjEuMCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG4vLyBBVFRFTlRJT05cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAgU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gIFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9ICBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSAgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiBudWxsXG59O1xuXG52YXIgUmVhY3RDdXJyZW50QWN0UXVldWUgPSB7XG4gIGN1cnJlbnQ6IG51bGwsXG4gIC8vIFVzZWQgdG8gcmVwcm9kdWNlIGJlaGF2aW9yIG9mIGBiYXRjaGVkVXBkYXRlc2AgaW4gbGVnYWN5IG1vZGUuXG4gIGlzQmF0Y2hpbmdMZWdhY3k6IGZhbHNlLFxuICBkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZTogZmFsc2Vcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lclxufTtcblxue1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QWN0UXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZTtcbn1cblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIHBhcnRpYWxTdGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiBwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICsgJ2Z1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKTtcbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JztcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24sIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIGNvbmZpZy5fX3NlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IGNvbmZpZy5fX3NlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIpO1xuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9IGtleS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGVsZW1lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gZWxlbWVudCBBIGVsZW1lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRLZXkoZWxlbWVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPT0gbnVsbCAmJiBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAge1xuICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihlbGVtZW50LmtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVzY2FwZSgnJyArIGVsZW1lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICB2YXIgX2NoaWxkID0gY2hpbGRyZW47XG4gICAgdmFyIG1hcHBlZENoaWxkID0gY2FsbGJhY2soX2NoaWxkKTsgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzOlxuXG4gICAgdmFyIGNoaWxkS2V5ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldEVsZW1lbnRLZXkoX2NoaWxkLCAwKSA6IG5hbWVTb0ZhcjtcblxuICAgIGlmIChpc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgICAgdmFyIGVzY2FwZWRDaGlsZEtleSA9ICcnO1xuXG4gICAgICBpZiAoY2hpbGRLZXkgIT0gbnVsbCkge1xuICAgICAgICBlc2NhcGVkQ2hpbGRLZXkgPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoY2hpbGRLZXkpICsgJy8nO1xuICAgICAgfVxuXG4gICAgICBtYXBJbnRvQXJyYXkobWFwcGVkQ2hpbGQsIGFycmF5LCBlc2NhcGVkQ2hpbGRLZXksICcnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGBpZmAgc3RhdGVtZW50IGhlcmUgcHJldmVudHMgYXV0by1kaXNhYmxpbmcgb2YgdGhlIHNhZmVcbiAgICAgICAgICAvLyBjb2VyY2lvbiBFU0xpbnQgcnVsZSwgc28gd2UgbXVzdCBtYW51YWxseSBkaXNhYmxlIGl0IGJlbG93LlxuICAgICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgUmVhY3QuUG9ydGFsIGRvZXNuJ3QgaGF2ZSBhIGtleVxuICAgICAgICAgIGlmIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFfY2hpbGQgfHwgX2NoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSkge1xuICAgICAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXBwZWRDaGlsZC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgICAgICAgZXNjYXBlVXNlclByb3ZpZGVkS2V5KCcnICsgbWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICAgIH1cblxuICAgICAgYXJyYXkucHVzaChtYXBwZWRDaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBpdGVyYWJsZUNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBpdGVyYWJsZUNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICAgIHdhcm4oJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChpdGVyYWJsZUNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcblxuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IG1hcEludG9BcnJheShjaGlsZCwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5leHROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICAvLyBUT0RPOiBTZWNvbmQgYXJndW1lbnQgdXNlZCB0byBiZSBhbiBvcHRpb25hbCBgY2FsY3VsYXRlQ2hhbmdlZEJpdHNgXG4gIC8vIGZ1bmN0aW9uLiBXYXJuIHRvIHJlc2VydmUgZm9yIGZ1dHVyZSB1c2U/XG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbCxcbiAgICAvLyBBZGQgdGhlc2UgdG8gdXNlIHNhbWUgaGlkZGVuIGNsYXNzIGluIFZNIGFzIFNlcnZlckNvbnRleHRcbiAgICBfZGVmYXVsdFZhbHVlOiBudWxsLFxuICAgIF9nbG9iYWxOYW1lOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dFxuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgLy8gVGhpcyBtaWdodCB0aHJvdyBlaXRoZXIgYmVjYXVzZSBpdCdzIG1pc3Npbmcgb3IgdGhyb3dzLiBJZiBzbywgd2UgdHJlYXQgaXRcbiAgICAvLyBhcyBzdGlsbCB1bmluaXRpYWxpemVkIGFuZCB0cnkgYWdhaW4gbmV4dCB0aW1lLiBXaGljaCBpcyB0aGUgc2FtZSBhcyB3aGF0XG4gICAgLy8gaGFwcGVucyBpZiB0aGUgY3RvciBvciBhbnkgd3JhcHBlcnMgcHJvY2Vzc2luZyB0aGUgY3RvciB0aHJvd3MuIFRoaXMgbWlnaHRcbiAgICAvLyBlbmQgdXAgZml4aW5nIGl0IGlmIHRoZSByZXNvbHV0aW9uIHdhcyBhIGNvbmN1cnJlbmN5IGJ1Zy5cblxuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlc29sdmVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVzb2x2ZWQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICByZXNvbHZlZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZyB8fCBwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cbiAgICAgICAgdmFyIHJlamVjdGVkID0gcGF5bG9hZDtcbiAgICAgICAgcmVqZWN0ZWQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICByZWplY3RlZC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgICAvLyBJbiBjYXNlLCB3ZSdyZSBzdGlsbCB1bmluaXRpYWxpemVkLCB0aGVuIHdlJ3JlIHdhaXRpbmcgZm9yIHRoZSB0aGVuYWJsZVxuICAgICAgLy8gdG8gcmVzb2x2ZS4gU2V0IGl0IGFzIHBlbmRpbmcgaW4gdGhlIG1lYW50aW1lLlxuICAgICAgdmFyIHBlbmRpbmcgPSBwYXlsb2FkO1xuICAgICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgdmFyIG1vZHVsZU9iamVjdCA9IHBheWxvYWQuX3Jlc3VsdDtcblxuICAgIHtcbiAgICAgIGlmIChtb2R1bGVPYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wJyArICdvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXFxuXFxuXCIgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcHV0IGN1cmx5IGJyYWNlcyBhcm91bmQgdGhlIGltcG9ydD8nLCBtb2R1bGVPYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICghKCdkZWZhdWx0JyBpbiBtb2R1bGVPYmplY3QpKSB7XG4gICAgICAgIGVycm9yKCdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXAnICsgJ29ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9kdWxlT2JqZWN0LmRlZmF1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcGF5bG9hZC5fcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhenkoY3Rvcikge1xuICB2YXIgcGF5bG9hZCA9IHtcbiAgICAvLyBXZSB1c2UgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogVW5pbml0aWFsaXplZCxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7Li4ufSk7XG4gICAgICAgIC8vIFRoaXMga2luZCBvZiBpbm5lciBmdW5jdGlvbiBpcyBub3QgdXNlZCBlbHNld2hlcmUgc28gdGhlIHNpZGUgZWZmZWN0IGlzIG9rYXkuXG5cbiAgICAgICAgaWYgKCFyZW5kZXIubmFtZSAmJiAhcmVuZGVyLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lOyAvLyBUaGUgaW5uZXIgY29tcG9uZW50IHNob3VsZG4ndCBpbmhlcml0IHRoaXMgZGlzcGxheSBuYW1lIGluIG1vc3QgY2FzZXMsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBtYXkgYmUgdXNlZCBlbHNld2hlcmUuXG4gICAgICAgIC8vIEJ1dCBpdCdzIG5pY2UgZm9yIGFub255bW91cyBmdW5jdGlvbnMgdG8gaW5oZXJpdCB0aGUgbmFtZSxcbiAgICAgICAgLy8gc28gdGhhdCBvdXIgY29tcG9uZW50LXN0YWNrIGdlbmVyYXRpb24gbG9naWMgd2lsbCBkaXNwbGF5IHRoZWlyIGZyYW1lcy5cbiAgICAgICAgLy8gQW4gYW5vbnltb3VzIGZ1bmN0aW9uIGdlbmVyYWxseSBzdWdnZXN0cyBhIHBhdHRlcm4gbGlrZTpcbiAgICAgICAgLy8gICBSZWFjdC5tZW1vKChwcm9wcykgPT4gey4uLn0pO1xuICAgICAgICAvLyBUaGlzIGtpbmQgb2YgaW5uZXIgZnVuY3Rpb24gaXMgbm90IHVzZWQgZWxzZXdoZXJlIHNvIHRoZSBzaWRlIGVmZmVjdCBpcyBva2F5LlxuXG4gICAgICAgIGlmICghdHlwZS5uYW1lICYmICF0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoZGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbiAgICB9XG4gIH0gLy8gV2lsbCByZXN1bHQgaW4gYSBudWxsIGFjY2VzcyBlcnJvciBpZiBhY2Nlc3NlZCBvdXRzaWRlIHJlbmRlciBwaGFzZS4gV2VcbiAgLy8gaW50ZW50aW9uYWxseSBkb24ndCB0aHJvdyBvdXIgb3duIGVycm9yIGJlY2F1c2UgdGhpcyBpcyBpbiBhIGhvdCBwYXRoLlxuICAvLyBBbHNvIGhlbHBzIGVuc3VyZSB0aGlzIGlzIGlubGluZWQuXG5cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIC8vIFRPRE86IGFkZCBhIG1vcmUgZ2VuZXJpYyB3YXJuaW5nIGZvciBpbnZhbGlkIHZhbHVlcy5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKCk7XG59XG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VJZCgpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJZCgpO1xufVxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlOyAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuXG4gICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihzY29wZSwgb3B0aW9ucykge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uID0ge307XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIHNjb3BlKCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9IGZhbHNlO1xudmFyIGVucXVldWVUYXNrSW1wbCA9IG51bGw7XG5mdW5jdGlvbiBlbnF1ZXVlVGFzayh0YXNrKSB7XG4gIGlmIChlbnF1ZXVlVGFza0ltcGwgPT09IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgLy8gcmVhZCByZXF1aXJlIG9mZiB0aGUgbW9kdWxlIG9iamVjdCB0byBnZXQgYXJvdW5kIHRoZSBidW5kbGVycy5cbiAgICAgIC8vIHdlIGRvbid0IHdhbnQgdGhlbSB0byBkZXRlY3QgYSByZXF1aXJlIGFuZCBidW5kbGUgYSBOb2RlIHBvbHlmaWxsLlxuICAgICAgdmFyIHJlcXVpcmVTdHJpbmcgPSAoJ3JlcXVpcmUnICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMCwgNyk7XG4gICAgICB2YXIgbm9kZVJlcXVpcmUgPSBtb2R1bGUgJiYgbW9kdWxlW3JlcXVpcmVTdHJpbmddOyAvLyBhc3N1bWluZyB3ZSdyZSBpbiBub2RlLCBsZXQncyB0cnkgdG8gZ2V0IG5vZGUnc1xuICAgICAgLy8gdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUsIGJ5cGFzc2luZyBmYWtlIHRpbWVycyBpZiBhbnkuXG5cbiAgICAgIGVucXVldWVUYXNrSW1wbCA9IG5vZGVSZXF1aXJlLmNhbGwobW9kdWxlLCAndGltZXJzJykuc2V0SW1tZWRpYXRlO1xuICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgIC8vIHdlJ3JlIGluIGEgYnJvd3NlclxuICAgICAgLy8gd2UgY2FuJ3QgdXNlIHJlZ3VsYXIgdGltZXJzIGJlY2F1c2UgdGhleSBtYXkgc3RpbGwgYmUgZmFrZWRcbiAgICAgIC8vIHNvIHdlIHRyeSBNZXNzYWdlQ2hhbm5lbCtwb3N0TWVzc2FnZSBpbnN0ZWFkXG4gICAgICBlbnF1ZXVlVGFza0ltcGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChkaWRXYXJuQWJvdXRNZXNzYWdlQ2hhbm5lbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dE1lc3NhZ2VDaGFubmVsID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBoYXZlIGEgTWVzc2FnZUNoYW5uZWwgaW1wbGVtZW50YXRpb24sICcgKyAnc28gZW5xdWV1aW5nIHRhc2tzIHZpYSBhd2FpdCBhY3QoYXN5bmMgKCkgPT4gLi4uKSB3aWxsIGZhaWwuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3VlcyAnICsgJ2lmIHlvdSBlbmNvdW50ZXIgdGhpcyB3YXJuaW5nLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVucXVldWVUYXNrSW1wbCh0YXNrKTtcbn1cblxudmFyIGFjdFNjb3BlRGVwdGggPSAwO1xudmFyIGRpZFdhcm5Ob0F3YWl0QWN0ID0gZmFsc2U7XG5mdW5jdGlvbiBhY3QoY2FsbGJhY2spIHtcbiAge1xuICAgIC8vIGBhY3RgIGNhbGxzIGNhbiBiZSBuZXN0ZWQsIHNvIHdlIHRyYWNrIHRoZSBkZXB0aC4gVGhpcyByZXByZXNlbnRzIHRoZVxuICAgIC8vIG51bWJlciBvZiBgYWN0YCBzY29wZXMgb24gdGhlIHN0YWNrLlxuICAgIHZhciBwcmV2QWN0U2NvcGVEZXB0aCA9IGFjdFNjb3BlRGVwdGg7XG4gICAgYWN0U2NvcGVEZXB0aCsrO1xuXG4gICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIG91dGVybW9zdCBgYWN0YCBzY29wZS4gSW5pdGlhbGl6ZSB0aGUgcXVldWUuIFRoZSByZWNvbmNpbGVyXG4gICAgICAvLyB3aWxsIGRldGVjdCB0aGUgcXVldWUgYW5kIHVzZSBpdCBpbnN0ZWFkIG9mIFNjaGVkdWxlci5cbiAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgcHJldklzQmF0Y2hpbmdMZWdhY3kgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5pc0JhdGNoaW5nTGVnYWN5O1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlZCB0byByZXByb2R1Y2UgYmVoYXZpb3Igb2YgYGJhdGNoZWRVcGRhdGVzYCBpbiBsZWdhY3kgbW9kZS4gT25seVxuICAgICAgLy8gc2V0IHRvIGB0cnVlYCB3aGlsZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgaXMgZXhlY3V0ZWQsIG5vdCBmb3IgdXBkYXRlc1xuICAgICAgLy8gdHJpZ2dlcmVkIGR1cmluZyBhbiBhc3luYyBldmVudCwgYmVjYXVzZSB0aGlzIGlzIGhvdyB0aGUgbGVnYWN5XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBgYWN0YCBiZWhhdmVkLlxuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHRydWU7XG4gICAgICByZXN1bHQgPSBjYWxsYmFjaygpOyAvLyBSZXBsaWNhdGUgYmVoYXZpb3Igb2Ygb3JpZ2luYWwgYGFjdGAgaW1wbGVtZW50YXRpb24gaW4gbGVnYWN5IG1vZGUsXG4gICAgICAvLyB3aGljaCBmbHVzaGVkIHVwZGF0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHNjb3BlIGZ1bmN0aW9uIGV4aXRzLCBldmVuXG4gICAgICAvLyBpZiBpdCdzIGFuIGFzeW5jIGZ1bmN0aW9uLlxuXG4gICAgICBpZiAoIXByZXZJc0JhdGNoaW5nTGVnYWN5ICYmIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmRpZFNjaGVkdWxlTGVnYWN5VXBkYXRlKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuZGlkU2NoZWR1bGVMZWdhY3lVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICBmbHVzaEFjdFF1ZXVlKHF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuaXNCYXRjaGluZ0xlZ2FjeSA9IHByZXZJc0JhdGNoaW5nTGVnYWN5O1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgIT09IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgdGhlbmFibGVSZXN1bHQgPSByZXN1bHQ7IC8vIFRoZSBjYWxsYmFjayBpcyBhbiBhc3luYyBmdW5jdGlvbiAoaS5lLiByZXR1cm5lZCBhIHByb21pc2UpLiBXYWl0XG4gICAgICAvLyBmb3IgaXQgdG8gcmVzb2x2ZSBiZWZvcmUgZXhpdGluZyB0aGUgY3VycmVudCBzY29wZS5cblxuICAgICAgdmFyIHdhc0F3YWl0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHdhc0F3YWl0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRoZW5hYmxlUmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XG4gICAgICAgICAgICBwb3BBY3RTY29wZShwcmV2QWN0U2NvcGVEZXB0aCk7XG5cbiAgICAgICAgICAgIGlmIChhY3RTY29wZURlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIFdlJ3ZlIGV4aXRlZCB0aGUgb3V0ZXJtb3N0IGFjdCBzY29wZS4gUmVjdXJzaXZlbHkgZmx1c2ggdGhlXG4gICAgICAgICAgICAgIC8vIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHJldHVyblZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayB0aHJldyBhbiBlcnJvci5cbiAgICAgICAgICAgIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuTm9Bd2FpdEFjdCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHt9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghd2FzQXdhaXRlZCkge1xuICAgICAgICAgICAgICBkaWRXYXJuTm9Bd2FpdEFjdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ1lvdSBjYWxsZWQgYWN0KGFzeW5jICgpID0+IC4uLikgd2l0aG91dCBhd2FpdC4gJyArICdUaGlzIGNvdWxkIGxlYWQgdG8gdW5leHBlY3RlZCB0ZXN0aW5nIGJlaGF2aW91ciwgJyArICdpbnRlcmxlYXZpbmcgbXVsdGlwbGUgYWN0IGNhbGxzIGFuZCBtaXhpbmcgdGhlaXIgJyArICdzY29wZXMuICcgKyAnWW91IHNob3VsZCAtIGF3YWl0IGFjdChhc3luYyAoKSA9PiAuLi4pOycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGVuYWJsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gcmVzdWx0OyAvLyBUaGUgY2FsbGJhY2sgaXMgbm90IGFuIGFzeW5jIGZ1bmN0aW9uLiBFeGl0IHRoZSBjdXJyZW50IHNjb3BlXG4gICAgICAvLyBpbW1lZGlhdGVseSwgd2l0aG91dCBhd2FpdGluZy5cblxuICAgICAgcG9wQWN0U2NvcGUocHJldkFjdFNjb3BlRGVwdGgpO1xuXG4gICAgICBpZiAoYWN0U2NvcGVEZXB0aCA9PT0gMCkge1xuICAgICAgICAvLyBFeGl0aW5nIHRoZSBvdXRlcm1vc3QgYWN0IHNjb3BlLiBGbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIHZhciBfcXVldWUgPSBSZWFjdEN1cnJlbnRBY3RRdWV1ZS5jdXJyZW50O1xuXG4gICAgICAgIGlmIChfcXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBmbHVzaEFjdFF1ZXVlKF9xdWV1ZSk7XG4gICAgICAgICAgUmVhY3RDdXJyZW50QWN0UXVldWUuY3VycmVudCA9IG51bGw7XG4gICAgICAgIH0gLy8gUmV0dXJuIGEgdGhlbmFibGUuIElmIHRoZSB1c2VyIGF3YWl0cyBpdCwgd2UnbGwgZmx1c2ggYWdhaW4gaW5cbiAgICAgICAgLy8gY2FzZSBhZGRpdGlvbmFsIHdvcmsgd2FzIHNjaGVkdWxlZCBieSBhIG1pY3JvdGFzay5cblxuXG4gICAgICAgIHZhciBfdGhlbmFibGUgPSB7XG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gQ29uZmlybSB3ZSBoYXZlbid0IHJlLWVudGVyZWQgYW5vdGhlciBgYWN0YCBzY29wZSwgaW4gY2FzZVxuICAgICAgICAgICAgLy8gdGhlIHVzZXIgZG9lcyBzb21ldGhpbmcgd2VpcmQgbGlrZSBhd2FpdCB0aGUgdGhlbmFibGVcbiAgICAgICAgICAgIC8vIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICAgICAgaWYgKFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmx1c2ggdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsuXG4gICAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlGbHVzaEFzeW5jQWN0V29yayhyZXR1cm5WYWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGVuYWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIGluc2lkZSBhIG5lc3RlZCBgYWN0YCBzY29wZSwgdGhlIHJldHVybmVkIHRoZW5hYmxlXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmVzLiBUaGUgb3V0ZXIgc2NvcGUgd2lsbCBmbHVzaCB0aGUgcXVldWUuXG4gICAgICAgIHZhciBfdGhlbmFibGUyID0ge1xuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGVuYWJsZTI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEFjdFNjb3BlKHByZXZBY3RTY29wZURlcHRoKSB7XG4gIHtcbiAgICBpZiAocHJldkFjdFNjb3BlRGVwdGggIT09IGFjdFNjb3BlRGVwdGggLSAxKSB7XG4gICAgICBlcnJvcignWW91IHNlZW0gdG8gaGF2ZSBvdmVybGFwcGluZyBhY3QoKSBjYWxscywgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0JlIHN1cmUgdG8gYXdhaXQgcHJldmlvdXMgYWN0KCkgY2FsbHMgYmVmb3JlIG1ha2luZyBhIG5ldyBvbmUuICcpO1xuICAgIH1cblxuICAgIGFjdFNjb3BlRGVwdGggPSBwcmV2QWN0U2NvcGVEZXB0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseUZsdXNoQXN5bmNBY3RXb3JrKHJldHVyblZhbHVlLCByZXNvbHZlLCByZWplY3QpIHtcbiAge1xuICAgIHZhciBxdWV1ZSA9IFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQ7XG5cbiAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZsdXNoQWN0UXVldWUocXVldWUpO1xuICAgICAgICBlbnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm8gYWRkaXRpb25hbCB3b3JrIHdhcyBzY2hlZHVsZWQuIEZpbmlzaC5cbiAgICAgICAgICAgIFJlYWN0Q3VycmVudEFjdFF1ZXVlLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZShyZXR1cm5WYWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEtlZXAgZmx1c2hpbmcgd29yayB1bnRpbCB0aGVyZSdzIG5vbmUgbGVmdC5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsocmV0dXJuVmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNGbHVzaGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaEFjdFF1ZXVlKHF1ZXVlKSB7XG4gIHtcbiAgICBpZiAoIWlzRmx1c2hpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY2UuXG4gICAgICBpc0ZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IHF1ZXVlW2ldO1xuXG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgc29tZXRoaW5nIHRocm93cywgbGVhdmUgdGhlIHJlbWFpbmluZyBjYWxsYmFja3Mgb24gdGhlIHF1ZXVlLlxuICAgICAgICBxdWV1ZSA9IHF1ZXVlLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLlByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMuc3RhcnRUcmFuc2l0aW9uID0gc3RhcnRUcmFuc2l0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9hY3QgPSBhY3Q7XG5leHBvcnRzLnVzZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s7XG5leHBvcnRzLnVzZUNvbnRleHQgPSB1c2VDb250ZXh0O1xuZXhwb3J0cy51c2VEZWJ1Z1ZhbHVlID0gdXNlRGVidWdWYWx1ZTtcbmV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IHVzZURlZmVycmVkVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSWQgPSB1c2VJZDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUluc2VydGlvbkVmZmVjdCA9IHVzZUluc2VydGlvbkVmZmVjdDtcbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0O1xuZXhwb3J0cy51c2VNZW1vID0gdXNlTWVtbztcbmV4cG9ydHMudXNlUmVkdWNlciA9IHVzZVJlZHVjZXI7XG5leHBvcnRzLnVzZVJlZiA9IHVzZVJlZjtcbmV4cG9ydHMudXNlU3RhdGUgPSB1c2VTdGF0ZTtcbmV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTtcbmV4cG9ydHMudXNlVHJhbnNpdGlvbiA9IHVzZVRyYW5zaXRpb247XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgICAgdmFyIGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyA9IGZhbHNlO1xudmFyIGVuYWJsZVByb2ZpbGluZyA9IGZhbHNlO1xudmFyIGZyYW1lWWllbGRNcyA9IDU7XG5cbmZ1bmN0aW9uIHB1c2goaGVhcCwgbm9kZSkge1xuICB2YXIgaW5kZXggPSBoZWFwLmxlbmd0aDtcbiAgaGVhcC5wdXNoKG5vZGUpO1xuICBzaWZ0VXAoaGVhcCwgbm9kZSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gIHJldHVybiBoZWFwLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBoZWFwWzBdO1xufVxuZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgaWYgKGhlYXAubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG5cbiAgaWYgKGxhc3QgIT09IGZpcnN0KSB7XG4gICAgaGVhcFswXSA9IGxhc3Q7XG4gICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG4gIH1cblxuICByZXR1cm4gZmlyc3Q7XG59XG5cbmZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG5cbiAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgIHZhciBwYXJlbnRJbmRleCA9IGluZGV4IC0gMSA+Pj4gMTtcbiAgICB2YXIgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XG5cbiAgICBpZiAoY29tcGFyZShwYXJlbnQsIG5vZGUpID4gMCkge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBsYXJnZXIuIFN3YXAgcG9zaXRpb25zLlxuICAgICAgaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlO1xuICAgICAgaGVhcFtpbmRleF0gPSBwYXJlbnQ7XG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNpZnREb3duKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcbiAgdmFyIGxlbmd0aCA9IGhlYXAubGVuZ3RoO1xuICB2YXIgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcblxuICB3aGlsZSAoaW5kZXggPCBoYWxmTGVuZ3RoKSB7XG4gICAgdmFyIGxlZnRJbmRleCA9IChpbmRleCArIDEpICogMiAtIDE7XG4gICAgdmFyIGxlZnQgPSBoZWFwW2xlZnRJbmRleF07XG4gICAgdmFyIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxO1xuICAgIHZhciByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07IC8vIElmIHRoZSBsZWZ0IG9yIHJpZ2h0IG5vZGUgaXMgc21hbGxlciwgc3dhcCB3aXRoIHRoZSBzbWFsbGVyIG9mIHRob3NlLlxuXG4gICAgaWYgKGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSBsZWZ0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAvLyBDb21wYXJlIHNvcnQgaW5kZXggZmlyc3QsIHRoZW4gdGFzayBpZC5cbiAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbn1cblxuLy8gVE9ETzogVXNlIHN5bWJvbHM/XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbnZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG52YXIgTG93UHJpb3JpdHkgPSA0O1xudmFyIElkbGVQcmlvcml0eSA9IDU7XG5cbmZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cblxudmFyIGhhc1BlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG5pZiAoaGFzUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBsb2NhbERhdGUgPSBEYXRlO1xuICB2YXIgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKSAtIGluaXRpYWxUaW1lO1xuICB9O1xufSAvLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG5cblxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG5cbnZhciBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCA9IC0xOyAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuXG52YXIgVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUID0gMjUwO1xudmFyIE5PUk1BTF9QUklPUklUWV9USU1FT1VUID0gNTAwMDtcbnZhciBMT1dfUFJJT1JJVFlfVElNRU9VVCA9IDEwMDAwOyAvLyBOZXZlciB0aW1lcyBvdXRcblxudmFyIElETEVfUFJJT1JJVFlfVElNRU9VVCA9IG1heFNpZ25lZDMxQml0SW50OyAvLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcblxudmFyIHRhc2tRdWV1ZSA9IFtdO1xudmFyIHRpbWVyUXVldWUgPSBbXTsgLy8gSW5jcmVtZW50aW5nIGlkIGNvdW50ZXIuIFVzZWQgdG8gbWFpbnRhaW4gaW5zZXJ0aW9uIG9yZGVyLlxuXG52YXIgdGFza0lkQ291bnRlciA9IDE7IC8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbnZhciBjdXJyZW50VGFzayA9IG51bGw7XG52YXIgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTsgLy8gVGhpcyBpcyBzZXQgd2hpbGUgcGVyZm9ybWluZyB3b3JrLCB0byBwcmV2ZW50IHJlLWVudHJhbmNlLlxuXG52YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG52YXIgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlOyAvLyBDYXB0dXJlIGxvY2FsIHJlZmVyZW5jZXMgdG8gbmF0aXZlIEFQSXMsIGluIGNhc2UgYSBwb2x5ZmlsbCBvdmVycmlkZXMgdGhlbS5cblxudmFyIGxvY2FsU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IG51bGw7XG52YXIgbG9jYWxDbGVhclRpbWVvdXQgPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gY2xlYXJUaW1lb3V0IDogbnVsbDtcbnZhciBsb2NhbFNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnID8gc2V0SW1tZWRpYXRlIDogbnVsbDsgLy8gSUUgYW5kIE5vZGUuanMgKyBqc2RvbVxuXG52YXIgaXNJbnB1dFBlbmRpbmcgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3Iuc2NoZWR1bGluZyAhPT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nICE9PSB1bmRlZmluZWQgPyBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZy5iaW5kKG5hdmlnYXRvci5zY2hlZHVsaW5nKSA6IG51bGw7XG5cbmZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgLy8gQ2hlY2sgZm9yIHRhc2tzIHRoYXQgYXJlIG5vIGxvbmdlciBkZWxheWVkIGFuZCBhZGQgdGhlbSB0byB0aGUgcXVldWUuXG4gIHZhciB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgd2hpbGUgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgaWYgKHRpbWVyLmNhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICAvLyBUaW1lciB3YXMgY2FuY2VsbGVkLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgIH0gZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaW1lciBmaXJlZC4gVHJhbnNmZXIgdG8gdGhlIHRhc2sgcXVldWUuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgICB0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZTtcbiAgICAgIHB1c2godGFza1F1ZXVlLCB0aW1lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbWFpbmluZyB0aW1lcnMgYXJlIHBlbmRpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcblxuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKSB7XG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSAhPT0gbnVsbCkge1xuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hXb3JrKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG5cblxuICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgLy8gV2Ugc2NoZWR1bGVkIGEgdGltZW91dCBidXQgaXQncyBubyBsb25nZXIgbmVlZGVkLiBDYW5jZWwgaXQuXG4gICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gIH1cblxuICBpc1BlcmZvcm1pbmdXb3JrID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZVByb2ZpbGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgICAgbWFya1Rhc2tFcnJvcmVkKGN1cnJlbnRUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgY3VycmVudFRhc2suaXNRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjYXRjaCBpbiBwcm9kIGNvZGUgcGF0aC5cbiAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRUYXNrID0gbnVsbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gaW5pdGlhbFRpbWU7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcblxuICB3aGlsZSAoY3VycmVudFRhc2sgIT09IG51bGwgJiYgIShlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgKSkge1xuICAgIGlmIChjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmICghaGFzVGltZVJlbWFpbmluZyB8fCBzaG91bGRZaWVsZFRvSG9zdCgpKSkge1xuICAgICAgLy8gVGhpcyBjdXJyZW50VGFzayBoYXNuJ3QgZXhwaXJlZCwgYW5kIHdlJ3ZlIHJlYWNoZWQgdGhlIGRlYWRsaW5lLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICB2YXIgZGlkVXNlckNhbGxiYWNrVGltZW91dCA9IGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuXG4gICAgICB2YXIgY29udGludWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjayhkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSkge1xuICAgICAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgfSAvLyBSZXR1cm4gd2hldGhlciB0aGVyZSdzIGFkZGl0aW9uYWwgd29ya1xuXG5cbiAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfbmV4dChldmVudEhhbmRsZXIpIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWw7XG5cbiAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgLy8gU2hpZnQgZG93biB0byBub3JtYWwgcHJpb3JpdHlcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEFueXRoaW5nIGxvd2VyIHRoYW4gbm9ybWFsIHByaW9yaXR5IHNob3VsZCByZW1haW4gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuICB2YXIgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gIHZhciBzdGFydFRpbWU7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5kZWxheTtcblxuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQ7XG5cbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElETEVfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBMT1dfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBkZWZhdWx0OlxuICAgICAgdGltZW91dCA9IE5PUk1BTF9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyB0aW1lb3V0O1xuICB2YXIgbmV3VGFzayA9IHtcbiAgICBpZDogdGFza0lkQ291bnRlcisrLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICBzb3J0SW5kZXg6IC0xXG4gIH07XG5cbiAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGRlbGF5ZWQgdGFzay5cbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuXG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSA9PT0gbnVsbCAmJiBuZXdUYXNrID09PSBwZWVrKHRpbWVyUXVldWUpKSB7XG4gICAgICAvLyBBbGwgdGFza3MgYXJlIGRlbGF5ZWQsIGFuZCB0aGlzIGlzIHRoZSB0YXNrIHdpdGggdGhlIGVhcmxpZXN0IGRlbGF5LlxuICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFuIGV4aXN0aW5nIHRpbWVvdXQuXG4gICAgICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gU2NoZWR1bGUgYSB0aW1lb3V0LlxuXG5cbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG4gICAgcHVzaCh0YXNrUXVldWUsIG5ld1Rhc2spO1xuICAgIC8vIHdhaXQgdW50aWwgdGhlIG5leHQgdGltZSB3ZSB5aWVsZC5cblxuXG4gICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdUYXNrO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbigpIHtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY29udGludWVFeGVjdXRpb24oKSB7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUoKSB7XG4gIHJldHVybiBwZWVrKHRhc2tRdWV1ZSk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKHRhc2spIHtcbiAgLy8gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlIGJlY2F1c2UgeW91IGNhbid0IHJlbW92ZSBhcmJpdHJhcnkgbm9kZXMgZnJvbSBhblxuICAvLyBhcnJheSBiYXNlZCBoZWFwLCBvbmx5IHRoZSBmaXJzdCBvbmUuKVxuXG5cbiAgdGFzay5jYWxsYmFjayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsKCkge1xuICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG59XG5cbnZhciBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xudmFyIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG52YXIgdGFza1RpbWVvdXRJRCA9IC0xOyAvLyBTY2hlZHVsZXIgcGVyaW9kaWNhbGx5IHlpZWxkcyBpbiBjYXNlIHRoZXJlIGlzIG90aGVyIHdvcmsgb24gdGhlIG1haW5cbi8vIHRocmVhZCwgbGlrZSB1c2VyIGV2ZW50cy4gQnkgZGVmYXVsdCwgaXQgeWllbGRzIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZS5cbi8vIEl0IGRvZXMgbm90IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCBmcmFtZSBib3VuZGFyaWVzLCBzaW5jZSBtb3N0IHRhc2tzIGRvbid0XG4vLyBuZWVkIHRvIGJlIGZyYW1lIGFsaWduZWQ7IGZvciB0aG9zZSB0aGF0IGRvLCB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuXG52YXIgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbnZhciBzdGFydFRpbWUgPSAtMTtcblxuZnVuY3Rpb24gc2hvdWxkWWllbGRUb0hvc3QoKSB7XG4gIHZhciB0aW1lRWxhcHNlZCA9IGV4cG9ydHMudW5zdGFibGVfbm93KCkgLSBzdGFydFRpbWU7XG5cbiAgaWYgKHRpbWVFbGFwc2VkIDwgZnJhbWVJbnRlcnZhbCkge1xuICAgIC8vIFRoZSBtYWluIHRocmVhZCBoYXMgb25seSBiZWVuIGJsb2NrZWQgZm9yIGEgcmVhbGx5IHNob3J0IGFtb3VudCBvZiB0aW1lO1xuICAgIC8vIHNtYWxsZXIgdGhhbiBhIHNpbmdsZSBmcmFtZS4gRG9uJ3QgeWllbGQgeWV0LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIGJlZW4gYmxvY2tlZCBmb3IgYSBub24tbmVnbGlnaWJsZSBhbW91bnQgb2YgdGltZS4gV2VcblxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0UGFpbnQoKSB7XG5cbn1cblxuZnVuY3Rpb24gZm9yY2VGcmFtZVJhdGUoZnBzKSB7XG4gIGlmIChmcHMgPCAwIHx8IGZwcyA+IDEyNSkge1xuICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgIGNvbnNvbGVbJ2Vycm9yJ10oJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICsgJ2ZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGZwcyA+IDApIHtcbiAgICBmcmFtZUludGVydmFsID0gTWF0aC5mbG9vcigxMDAwIC8gZnBzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXG4gICAgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbiAgfVxufVxuXG52YXIgcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICBpZiAoc2NoZWR1bGVkSG9zdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgc3RhcnQgdGltZSBzbyB3ZSBjYW4gbWVhc3VyZSBob3cgbG9uZyB0aGUgbWFpbiB0aHJlYWRcbiAgICAvLyBoYXMgYmVlbiBibG9ja2VkLlxuXG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdmFyIGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlOyAvLyBJZiBhIHNjaGVkdWxlciB0YXNrIHRocm93cywgZXhpdCB0aGUgY3VycmVudCBicm93c2VyIHRhc2sgc28gdGhlXG4gICAgLy8gZXJyb3IgY2FuIGJlIG9ic2VydmVkLlxuICAgIC8vXG4gICAgLy8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYSB0cnktY2F0Y2gsIHNpbmNlIHRoYXQgbWFrZXMgc29tZSBkZWJ1Z2dpbmdcbiAgICAvLyB0ZWNobmlxdWVzIGhhcmRlci4gSW5zdGVhZCwgaWYgYHNjaGVkdWxlZEhvc3RDYWxsYmFja2AgZXJyb3JzLCB0aGVuXG4gICAgLy8gYGhhc01vcmVXb3JrYCB3aWxsIHJlbWFpbiB0cnVlLCBhbmQgd2UnbGwgY29udGludWUgdGhlIHdvcmsgbG9vcC5cblxuICAgIHZhciBoYXNNb3JlV29yayA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2soaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoaGFzTW9yZVdvcmspIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHdvcmssIHNjaGVkdWxlIHRoZSBuZXh0IG1lc3NhZ2UgZXZlbnQgYXQgdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgcHJlY2VkaW5nIG9uZS5cbiAgICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gIH0gLy8gWWllbGRpbmcgdG8gdGhlIGJyb3dzZXIgd2lsbCBnaXZlIGl0IGEgY2hhbmNlIHRvIHBhaW50LCBzbyB3ZSBjYW5cbn07XG5cbnZhciBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcblxuaWYgKHR5cGVvZiBsb2NhbFNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBOb2RlLmpzIGFuZCBvbGQgSUUuXG4gIC8vIFRoZXJlJ3MgYSBmZXcgcmVhc29ucyBmb3Igd2h5IHdlIHByZWZlciBzZXRJbW1lZGlhdGUuXG4gIC8vXG4gIC8vIFVubGlrZSBNZXNzYWdlQ2hhbm5lbCwgaXQgZG9lc24ndCBwcmV2ZW50IGEgTm9kZS5qcyBwcm9jZXNzIGZyb20gZXhpdGluZy5cbiAgLy8gKEV2ZW4gdGhvdWdoIHRoaXMgaXMgYSBET00gZm9yayBvZiB0aGUgU2NoZWR1bGVyLCB5b3UgY291bGQgZ2V0IGhlcmVcbiAgLy8gd2l0aCBhIG1peCBvZiBOb2RlLmpzIDE1Kywgd2hpY2ggaGFzIGEgTWVzc2FnZUNoYW5uZWwsIGFuZCBqc2RvbS4pXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjA3NTZcbiAgLy9cbiAgLy8gQnV0IGFsc28sIGl0IHJ1bnMgZWFybGllciB3aGljaCBpcyB0aGUgc2VtYW50aWMgd2Ugd2FudC5cbiAgLy8gSWYgb3RoZXIgYnJvd3NlcnMgZXZlciBpbXBsZW1lbnQgaXQsIGl0J3MgYmV0dGVyIHRvIHVzZSBpdC5cbiAgLy8gQWx0aG91Z2ggYm90aCBvZiB0aGVzZSB3b3VsZCBiZSBpbmZlcmlvciB0byBuYXRpdmUgc2NoZWR1bGluZy5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRJbW1lZGlhdGUocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBET00gYW5kIFdvcmtlciBlbnZpcm9ubWVudHMuXG4gIC8vIFdlIHByZWZlciBNZXNzYWdlQ2hhbm5lbCBiZWNhdXNlIG9mIHRoZSA0bXMgc2V0VGltZW91dCBjbGFtcGluZy5cbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcblxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gV2Ugc2hvdWxkIG9ubHkgZmFsbGJhY2sgaGVyZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU2V0VGltZW91dChwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUsIDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0SG9zdENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIGlmICghaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IHRydWU7XG4gICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0SG9zdFRpbWVvdXQoY2FsbGJhY2ssIG1zKSB7XG4gIHRhc2tUaW1lb3V0SUQgPSBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICB9LCBtcyk7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbEhvc3RUaW1lb3V0KCkge1xuICBsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKTtcbiAgdGFza1RpbWVvdXRJRCA9IC0xO1xufVxuXG52YXIgdW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xudmFyIHVuc3RhYmxlX1Byb2ZpbGluZyA9ICBudWxsO1xuXG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSBMb3dQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gdW5zdGFibGVfUHJvZmlsaW5nO1xuZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZSA9IGZvcmNlRnJhbWVSYXRlO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gdW5zdGFibGVfbmV4dDtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gdW5zdGFibGVfcmVxdWVzdFBhaW50O1xuZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgPSB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IHNob3VsZFlpZWxkVG9Ib3N0O1xuZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSB1bnN0YWJsZV93cmFwQ2FsbGJhY2s7XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKHN0cmluZywgc2VwYXJhdG9yKSA9PiB7XG5cdGlmICghKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzZXBhcmF0b3IgPT09ICdzdHJpbmcnKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHRoZSBhcmd1bWVudHMgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYCcpO1xuXHR9XG5cblx0aWYgKHNlcGFyYXRvciA9PT0gJycpIHtcblx0XHRyZXR1cm4gW3N0cmluZ107XG5cdH1cblxuXHRjb25zdCBzZXBhcmF0b3JJbmRleCA9IHN0cmluZy5pbmRleE9mKHNlcGFyYXRvcik7XG5cblx0aWYgKHNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuXHRcdHJldHVybiBbc3RyaW5nXTtcblx0fVxuXG5cdHJldHVybiBbXG5cdFx0c3RyaW5nLnNsaWNlKDAsIHNlcGFyYXRvckluZGV4KSxcblx0XHRzdHJpbmcuc2xpY2Uoc2VwYXJhdG9ySW5kZXggKyBzZXBhcmF0b3IubGVuZ3RoKVxuXHRdO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gc3RyID0+IGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgeCA9PiBgJSR7eC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfWApO1xuIiwidmFyIGUsdCxuLGkscj1mdW5jdGlvbihlLHQpe3JldHVybntuYW1lOmUsdmFsdWU6dm9pZCAwPT09dD8tMTp0LGRlbHRhOjAsZW50cmllczpbXSxpZDpcInYyLVwiLmNvbmNhdChEYXRlLm5vdygpLFwiLVwiKS5jb25jYXQoTWF0aC5mbG9vcig4OTk5OTk5OTk5OTk5Kk1hdGgucmFuZG9tKCkpKzFlMTIpfX0sYT1mdW5jdGlvbihlLHQpe3RyeXtpZihQZXJmb3JtYW5jZU9ic2VydmVyLnN1cHBvcnRlZEVudHJ5VHlwZXMuaW5jbHVkZXMoZSkpe2lmKFwiZmlyc3QtaW5wdXRcIj09PWUmJiEoXCJQZXJmb3JtYW5jZUV2ZW50VGltaW5nXCJpbiBzZWxmKSlyZXR1cm47dmFyIG49bmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBlLmdldEVudHJpZXMoKS5tYXAodCl9KSk7cmV0dXJuIG4ub2JzZXJ2ZSh7dHlwZTplLGJ1ZmZlcmVkOiEwfSksbn19Y2F0Y2goZSl7fX0sbz1mdW5jdGlvbihlLHQpe3ZhciBuPWZ1bmN0aW9uIG4oaSl7XCJwYWdlaGlkZVwiIT09aS50eXBlJiZcImhpZGRlblwiIT09ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlfHwoZShpKSx0JiYocmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixuLCEwKSxyZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIixuLCEwKSkpfTthZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLG4sITApLGFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLG4sITApfSx1PWZ1bmN0aW9uKGUpe2FkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLChmdW5jdGlvbih0KXt0LnBlcnNpc3RlZCYmZSh0KX0pLCEwKX0sYz1mdW5jdGlvbihlLHQsbil7dmFyIGk7cmV0dXJuIGZ1bmN0aW9uKHIpe3QudmFsdWU+PTAmJihyfHxuKSYmKHQuZGVsdGE9dC52YWx1ZS0oaXx8MCksKHQuZGVsdGF8fHZvaWQgMD09PWkpJiYoaT10LnZhbHVlLGUodCkpKX19LGY9LTEscz1mdW5jdGlvbigpe3JldHVyblwiaGlkZGVuXCI9PT1kb2N1bWVudC52aXNpYmlsaXR5U3RhdGU/MDoxLzB9LG09ZnVuY3Rpb24oKXtvKChmdW5jdGlvbihlKXt2YXIgdD1lLnRpbWVTdGFtcDtmPXR9KSwhMCl9LHY9ZnVuY3Rpb24oKXtyZXR1cm4gZjwwJiYoZj1zKCksbSgpLHUoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtmPXMoKSxtKCl9KSwwKX0pKSkse2dldCBmaXJzdEhpZGRlblRpbWUoKXtyZXR1cm4gZn19fSxkPWZ1bmN0aW9uKGUsdCl7dmFyIG4saT12KCksbz1yKFwiRkNQXCIpLGY9ZnVuY3Rpb24oZSl7XCJmaXJzdC1jb250ZW50ZnVsLXBhaW50XCI9PT1lLm5hbWUmJihtJiZtLmRpc2Nvbm5lY3QoKSxlLnN0YXJ0VGltZTxpLmZpcnN0SGlkZGVuVGltZSYmKG8udmFsdWU9ZS5zdGFydFRpbWUsby5lbnRyaWVzLnB1c2goZSksbighMCkpKX0scz13aW5kb3cucGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUmJnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXCJmaXJzdC1jb250ZW50ZnVsLXBhaW50XCIpWzBdLG09cz9udWxsOmEoXCJwYWludFwiLGYpOyhzfHxtKSYmKG49YyhlLG8sdCkscyYmZihzKSx1KChmdW5jdGlvbihpKXtvPXIoXCJGQ1BcIiksbj1jKGUsbyx0KSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe28udmFsdWU9cGVyZm9ybWFuY2Uubm93KCktaS50aW1lU3RhbXAsbighMCl9KSl9KSl9KSkpfSxwPSExLGw9LTEsaD1mdW5jdGlvbihlLHQpe3B8fChkKChmdW5jdGlvbihlKXtsPWUudmFsdWV9KSkscD0hMCk7dmFyIG4saT1mdW5jdGlvbih0KXtsPi0xJiZlKHQpfSxmPXIoXCJDTFNcIiwwKSxzPTAsbT1bXSx2PWZ1bmN0aW9uKGUpe2lmKCFlLmhhZFJlY2VudElucHV0KXt2YXIgdD1tWzBdLGk9bVttLmxlbmd0aC0xXTtzJiZlLnN0YXJ0VGltZS1pLnN0YXJ0VGltZTwxZTMmJmUuc3RhcnRUaW1lLXQuc3RhcnRUaW1lPDVlMz8ocys9ZS52YWx1ZSxtLnB1c2goZSkpOihzPWUudmFsdWUsbT1bZV0pLHM+Zi52YWx1ZSYmKGYudmFsdWU9cyxmLmVudHJpZXM9bSxuKCkpfX0saD1hKFwibGF5b3V0LXNoaWZ0XCIsdik7aCYmKG49YyhpLGYsdCksbygoZnVuY3Rpb24oKXtoLnRha2VSZWNvcmRzKCkubWFwKHYpLG4oITApfSkpLHUoKGZ1bmN0aW9uKCl7cz0wLGw9LTEsZj1yKFwiQ0xTXCIsMCksbj1jKGksZix0KX0pKSl9LFQ9e3Bhc3NpdmU6ITAsY2FwdHVyZTohMH0seT1uZXcgRGF0ZSxnPWZ1bmN0aW9uKGkscil7ZXx8KGU9cix0PWksbj1uZXcgRGF0ZSx3KHJlbW92ZUV2ZW50TGlzdGVuZXIpLEUoKSl9LEU9ZnVuY3Rpb24oKXtpZih0Pj0wJiZ0PG4teSl7dmFyIHI9e2VudHJ5VHlwZTpcImZpcnN0LWlucHV0XCIsbmFtZTplLnR5cGUsdGFyZ2V0OmUudGFyZ2V0LGNhbmNlbGFibGU6ZS5jYW5jZWxhYmxlLHN0YXJ0VGltZTplLnRpbWVTdGFtcCxwcm9jZXNzaW5nU3RhcnQ6ZS50aW1lU3RhbXArdH07aS5mb3JFYWNoKChmdW5jdGlvbihlKXtlKHIpfSkpLGk9W119fSxTPWZ1bmN0aW9uKGUpe2lmKGUuY2FuY2VsYWJsZSl7dmFyIHQ9KGUudGltZVN0YW1wPjFlMTI/bmV3IERhdGU6cGVyZm9ybWFuY2Uubm93KCkpLWUudGltZVN0YW1wO1wicG9pbnRlcmRvd25cIj09ZS50eXBlP2Z1bmN0aW9uKGUsdCl7dmFyIG49ZnVuY3Rpb24oKXtnKGUsdCkscigpfSxpPWZ1bmN0aW9uKCl7cigpfSxyPWZ1bmN0aW9uKCl7cmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLG4sVCkscmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIixpLFQpfTthZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsbixUKSxhZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLGksVCl9KHQsZSk6Zyh0LGUpfX0sdz1mdW5jdGlvbihlKXtbXCJtb3VzZWRvd25cIixcImtleWRvd25cIixcInRvdWNoc3RhcnRcIixcInBvaW50ZXJkb3duXCJdLmZvckVhY2goKGZ1bmN0aW9uKHQpe3JldHVybiBlKHQsUyxUKX0pKX0sTD1mdW5jdGlvbihuLGYpe3ZhciBzLG09digpLGQ9cihcIkZJRFwiKSxwPWZ1bmN0aW9uKGUpe2Uuc3RhcnRUaW1lPG0uZmlyc3RIaWRkZW5UaW1lJiYoZC52YWx1ZT1lLnByb2Nlc3NpbmdTdGFydC1lLnN0YXJ0VGltZSxkLmVudHJpZXMucHVzaChlKSxzKCEwKSl9LGw9YShcImZpcnN0LWlucHV0XCIscCk7cz1jKG4sZCxmKSxsJiZvKChmdW5jdGlvbigpe2wudGFrZVJlY29yZHMoKS5tYXAocCksbC5kaXNjb25uZWN0KCl9KSwhMCksbCYmdSgoZnVuY3Rpb24oKXt2YXIgYTtkPXIoXCJGSURcIikscz1jKG4sZCxmKSxpPVtdLHQ9LTEsZT1udWxsLHcoYWRkRXZlbnRMaXN0ZW5lciksYT1wLGkucHVzaChhKSxFKCl9KSl9LGI9e30sRj1mdW5jdGlvbihlLHQpe3ZhciBuLGk9digpLGY9cihcIkxDUFwiKSxzPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3RhcnRUaW1lO3Q8aS5maXJzdEhpZGRlblRpbWUmJihmLnZhbHVlPXQsZi5lbnRyaWVzLnB1c2goZSksbigpKX0sbT1hKFwibGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50XCIscyk7aWYobSl7bj1jKGUsZix0KTt2YXIgZD1mdW5jdGlvbigpe2JbZi5pZF18fChtLnRha2VSZWNvcmRzKCkubWFwKHMpLG0uZGlzY29ubmVjdCgpLGJbZi5pZF09ITAsbighMCkpfTtbXCJrZXlkb3duXCIsXCJjbGlja1wiXS5mb3JFYWNoKChmdW5jdGlvbihlKXthZGRFdmVudExpc3RlbmVyKGUsZCx7b25jZTohMCxjYXB0dXJlOiEwfSl9KSksbyhkLCEwKSx1KChmdW5jdGlvbihpKXtmPXIoXCJMQ1BcIiksbj1jKGUsZix0KSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe2YudmFsdWU9cGVyZm9ybWFuY2Uubm93KCktaS50aW1lU3RhbXAsYltmLmlkXT0hMCxuKCEwKX0pKX0pKX0pKX19LFA9ZnVuY3Rpb24oZSl7dmFyIHQsbj1yKFwiVFRGQlwiKTt0PWZ1bmN0aW9uKCl7dHJ5e3ZhciB0PXBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoXCJuYXZpZ2F0aW9uXCIpWzBdfHxmdW5jdGlvbigpe3ZhciBlPXBlcmZvcm1hbmNlLnRpbWluZyx0PXtlbnRyeVR5cGU6XCJuYXZpZ2F0aW9uXCIsc3RhcnRUaW1lOjB9O2Zvcih2YXIgbiBpbiBlKVwibmF2aWdhdGlvblN0YXJ0XCIhPT1uJiZcInRvSlNPTlwiIT09biYmKHRbbl09TWF0aC5tYXgoZVtuXS1lLm5hdmlnYXRpb25TdGFydCwwKSk7cmV0dXJuIHR9KCk7aWYobi52YWx1ZT1uLmRlbHRhPXQucmVzcG9uc2VTdGFydCxuLnZhbHVlPDB8fG4udmFsdWU+cGVyZm9ybWFuY2Uubm93KCkpcmV0dXJuO24uZW50cmllcz1bdF0sZShuKX1jYXRjaChlKXt9fSxcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlP3NldFRpbWVvdXQodCwwKTphZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLChmdW5jdGlvbigpe3JldHVybiBzZXRUaW1lb3V0KHQsMCl9KSl9O2V4cG9ydHtoIGFzIGdldENMUyxkIGFzIGdldEZDUCxMIGFzIGdldEZJRCxGIGFzIGdldExDUCxQIGFzIGdldFRURkJ9O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSJdLCJuYW1lcyI6WyJ0b2tlbiIsInNpbmdsZU1hdGNoZXIiLCJSZWdFeHAiLCJtdWx0aU1hdGNoZXIiLCJkZWNvZGVDb21wb25lbnRzIiwiY29tcG9uZW50cyIsInNwbGl0IiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsImVyciIsImxlbmd0aCIsImxlZnQiLCJzbGljZSIsInJpZ2h0IiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjb25jYXQiLCJjYWxsIiwiZGVjb2RlIiwiaW5wdXQiLCJ0b2tlbnMiLCJtYXRjaCIsImkiLCJjdXN0b21EZWNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlTWFwIiwiZXhlYyIsInJlc3VsdCIsImVudHJpZXMiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwicmVwbGFjZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJlbmNvZGVkVVJJIiwiVHlwZUVycm9yIiwib2JqIiwicHJlZGljYXRlIiwicmV0IiwiaXNBcnIiLCJpc0FycmF5IiwidmFsIiwiaW5kZXhPZiIsInN0cmljdFVyaUVuY29kZSIsInJlcXVpcmUiLCJkZWNvZGVDb21wb25lbnQiLCJzcGxpdE9uRmlyc3QiLCJmaWx0ZXJPYmplY3QiLCJpc051bGxPclVuZGVmaW5lZCIsInZhbHVlIiwidW5kZWZpbmVkIiwiZW5jb2RlRnJhZ21lbnRJZGVudGlmaWVyIiwiU3ltYm9sIiwiZW5jb2RlckZvckFycmF5Rm9ybWF0Iiwib3B0aW9ucyIsImFycmF5Rm9ybWF0IiwiaW5kZXgiLCJza2lwTnVsbCIsInNraXBFbXB0eVN0cmluZyIsImVuY29kZSIsImtleVZhbHVlU2VwIiwiYXJyYXlGb3JtYXRTZXBhcmF0b3IiLCJwYXJzZXJGb3JBcnJheUZvcm1hdCIsImFjY3VtdWxhdG9yIiwiaW5jbHVkZXMiLCJpc0VuY29kZWRBcnJheSIsIm5ld1ZhbHVlIiwibWFwIiwiaXRlbSIsInRlc3QiLCJhcnJheVZhbHVlIiwidmFsaWRhdGVBcnJheUZvcm1hdFNlcGFyYXRvciIsInN0cmljdCIsImVuY29kZVVSSUNvbXBvbmVudCIsImtleXNTb3J0ZXIiLCJzb3J0IiwiYSIsImIiLCJOdW1iZXIiLCJyZW1vdmVIYXNoIiwiaGFzaFN0YXJ0IiwiZ2V0SGFzaCIsInVybCIsImhhc2giLCJleHRyYWN0IiwicXVlcnlTdGFydCIsInBhcnNlVmFsdWUiLCJwYXJzZU51bWJlcnMiLCJpc05hTiIsInRyaW0iLCJwYXJzZUJvb2xlYW5zIiwidG9Mb3dlckNhc2UiLCJwYXJzZSIsInF1ZXJ5IiwiYXNzaWduIiwiZm9ybWF0dGVyIiwiY3JlYXRlIiwicGFyYW0iLCJrIiwicmVkdWNlIiwiQm9vbGVhbiIsInN0cmluZ2lmeSIsIm9iamVjdCIsInNob3VsZEZpbHRlciIsIm9iamVjdENvcHkiLCJmaWx0ZXIiLCJ4IiwicGFyc2VVcmwiLCJ1cmxfIiwicGFyc2VGcmFnbWVudElkZW50aWZpZXIiLCJmcmFnbWVudElkZW50aWZpZXIiLCJzdHJpbmdpZnlVcmwiLCJxdWVyeUZyb21VcmwiLCJwYXJzZWRRdWVyeUZyb21VcmwiLCJxdWVyeVN0cmluZyIsInBpY2siLCJleGNsdWRlIiwiZXhjbHVzaW9uRmlsdGVyIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0IiwiRXJyb3IiLCJSZWFjdCIsIlNjaGVkdWxlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJzdXBwcmVzc1dhcm5pbmciLCJzZXRTdXBwcmVzc1dhcm5pbmciLCJuZXdTdXBwcmVzc1dhcm5pbmciLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImFyZ3MiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiYXJnc1dpdGhGb3JtYXQiLCJTdHJpbmciLCJ1bnNoaWZ0IiwiRnVuY3Rpb24iLCJhcHBseSIsImNvbnNvbGUiLCJGdW5jdGlvbkNvbXBvbmVudCIsIkNsYXNzQ29tcG9uZW50IiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkZyYWdtZW50IiwiTW9kZSIsIkNvbnRleHRDb25zdW1lciIsIkNvbnRleHRQcm92aWRlciIsIkZvcndhcmRSZWYiLCJQcm9maWxlciIsIlN1c3BlbnNlQ29tcG9uZW50IiwiTWVtb0NvbXBvbmVudCIsIlNpbXBsZU1lbW9Db21wb25lbnQiLCJMYXp5Q29tcG9uZW50IiwiSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50IiwiRGVoeWRyYXRlZEZyYWdtZW50IiwiU3VzcGVuc2VMaXN0Q29tcG9uZW50IiwiU2NvcGVDb21wb25lbnQiLCJPZmZzY3JlZW5Db21wb25lbnQiLCJMZWdhY3lIaWRkZW5Db21wb25lbnQiLCJDYWNoZUNvbXBvbmVudCIsIlRyYWNpbmdNYXJrZXJDb21wb25lbnQiLCJlbmFibGVDbGllbnRSZW5kZXJGYWxsYmFja09uVGV4dE1pc21hdGNoIiwiZW5hYmxlTmV3UmVjb25jaWxlciIsImVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24iLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVTdXNwZW5zZUF2b2lkVGhpc0ZhbGxiYWNrIiwiZGlzYWJsZUNvbW1lbnRzQXNET01Db250YWluZXJzIiwiZW5hYmxlQ3VzdG9tRWxlbWVudFByb3BlcnR5U3VwcG9ydCIsIndhcm5BYm91dFN0cmluZ1JlZnMiLCJlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIiLCJlbmFibGVQcm9maWxlclRpbWVyIiwiZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyIsImFsbE5hdGl2ZUV2ZW50cyIsIlNldCIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIiwicmVnaXN0ZXJUd29QaGFzZUV2ZW50IiwicmVnaXN0cmF0aW9uTmFtZSIsImRlcGVuZGVuY2llcyIsInJlZ2lzdGVyRGlyZWN0RXZlbnQiLCJsb3dlckNhc2VkTmFtZSIsIm9uZGJsY2xpY2siLCJhZGQiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsInR5cGVOYW1lIiwiaGFzVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsInR5cGUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0F0dHJpYnV0ZVN0cmluZ0NvZXJjaW9uIiwiYXR0cmlidXRlTmFtZSIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJjaGVja1Byb3BTdHJpbmdDb2VyY2lvbiIsInByb3BOYW1lIiwiY2hlY2tDU1NQcm9wZXJ0eVN0cmluZ0NvZXJjaW9uIiwiY2hlY2tIdG1sU3RyaW5nQ29lcmNpb24iLCJjaGVja0Zvcm1GaWVsZFZhbHVlU3RyaW5nQ29lcmNpb24iLCJSRVNFUlZFRCIsIlNUUklORyIsIkJPT0xFQU5JU0hfU1RSSU5HIiwiQk9PTEVBTiIsIk9WRVJMT0FERURfQk9PTEVBTiIsIk5VTUVSSUMiLCJQT1NJVElWRV9OVU1FUklDIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCIsImlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJ2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJpc0F0dHJpYnV0ZU5hbWVTYWZlIiwic2hvdWxkSWdub3JlQXR0cmlidXRlIiwicHJvcGVydHlJbmZvIiwiaXNDdXN0b21Db21wb25lbnRUYWciLCJzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyIsImFjY2VwdHNCb29sZWFucyIsInByZWZpeCIsInNob3VsZFJlbW92ZUF0dHJpYnV0ZSIsImdldFByb3BlcnR5SW5mbyIsInByb3BlcnRpZXMiLCJQcm9wZXJ0eUluZm9SZWNvcmQiLCJtdXN0VXNlUHJvcGVydHkiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJzYW5pdGl6ZVVSTCIsInJlbW92ZUVtcHR5U3RyaW5nIiwicHJvcGVydHlOYW1lIiwicmVzZXJ2ZWRQcm9wcyIsImZvckVhY2giLCJfcmVmIiwiQ0FNRUxJWkUiLCJjYXBpdGFsaXplIiwidG9VcHBlckNhc2UiLCJ4bGlua0hyZWYiLCJpc0phdmFTY3JpcHRQcm90b2NvbCIsImRpZFdhcm4iLCJKU09OIiwiZ2V0VmFsdWVGb3JQcm9wZXJ0eSIsIm5vZGUiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiX2F0dHJpYnV0ZU5hbWUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJfdHlwZSIsImF0dHJpYnV0ZVZhbHVlIiwidG9TdHJpbmciLCJzZXRBdHRyaWJ1dGVOUyIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsImZvciIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfU0NPUEVfVFlQRSIsIlJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUiLCJSRUFDVF9DQUNIRV9UWVBFIiwiUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJyZWVudHJ5IiwiY29tcG9uZW50RnJhbWVDYWNoZSIsIlBvc3NpYmx5V2Vha01hcCIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsImdldCIsImNvbnRyb2wiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJjdXJyZW50IiwiRmFrZSIsImRlZmluZVByb3BlcnR5Iiwic2V0IiwiUmVmbGVjdCIsInNhbXBsZSIsInNhbXBsZUxpbmVzIiwiY29udHJvbExpbmVzIiwicyIsImMiLCJfZnJhbWUiLCJkaXNwbGF5TmFtZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lIiwiY3RvciIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsInNob3VsZENvbnN0cnVjdCIsIkNvbXBvbmVudCIsImlzUmVhY3RDb21wb25lbnQiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCIkJHR5cGVvZiIsInJlbmRlciIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJkZXNjcmliZUZpYmVyIiwiZmliZXIiLCJvd25lciIsIl9kZWJ1Z093bmVyIiwiX2RlYnVnU291cmNlIiwidGFnIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJyZXR1cm4iLCJtZXNzYWdlIiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImZ1bmN0aW9uTmFtZSIsImdldENvbnRleHROYW1lIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwiY29udGV4dCIsInByb3ZpZGVyIiwiX2NvbnRleHQiLCJvdXRlck5hbWUiLCJnZXRXcmFwcGVkTmFtZSQxIiwiZ2V0Q29udGV4dE5hbWUkMSIsImdldENvbXBvbmVudE5hbWVGcm9tRmliZXIiLCJpc1JlbmRlcmluZyIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldiIsInJlc2V0Q3VycmVudEZpYmVyIiwiZ2V0Q3VycmVudFN0YWNrIiwic2V0Q3VycmVudEZpYmVyIiwiZ2V0Q3VycmVudEZpYmVyIiwic2V0SXNSZW5kZXJpbmciLCJyZW5kZXJpbmciLCJnZXRUb1N0cmluZ1ZhbHVlIiwiaGFzUmVhZE9ubHlWYWx1ZSIsImJ1dHRvbiIsImNoZWNrYm94IiwiaW1hZ2UiLCJoaWRkZW4iLCJyYWRpbyIsInJlc2V0Iiwic3VibWl0IiwiY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyIsInRhZ05hbWUiLCJvbkNoYW5nZSIsIm9uSW5wdXQiLCJyZWFkT25seSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImlzQ2hlY2thYmxlIiwiZWxlbSIsIm5vZGVOYW1lIiwiZ2V0VHJhY2tlciIsIl92YWx1ZVRyYWNrZXIiLCJkZXRhY2hUcmFja2VyIiwiZ2V0VmFsdWVGcm9tTm9kZSIsInRyYWNrVmFsdWVPbk5vZGUiLCJ2YWx1ZUZpZWxkIiwiZGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImN1cnJlbnRWYWx1ZSIsInRyYWNrZXIiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwic3RvcFRyYWNraW5nIiwidHJhY2siLCJ1cGRhdGVWYWx1ZUlmQ2hhbmdlZCIsImxhc3RWYWx1ZSIsIm5leHRWYWx1ZSIsImdldEFjdGl2ZUVsZW1lbnQiLCJkb2MiLCJhY3RpdmVFbGVtZW50IiwiYm9keSIsImRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSIsImRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQiLCJkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkIiwiZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCIsImlzQ29udHJvbGxlZCIsInVzZXNDaGVja2VkIiwiZ2V0SG9zdFByb3BzIiwiZWxlbWVudCIsImhvc3RQcm9wcyIsImRlZmF1bHRDaGVja2VkIiwiZGVmYXVsdFZhbHVlIiwiX3dyYXBwZXJTdGF0ZSIsImluaXRpYWxDaGVja2VkIiwiaW5pdFdyYXBwZXJTdGF0ZSIsImluaXRpYWxWYWx1ZSIsImNvbnRyb2xsZWQiLCJ1cGRhdGVDaGVja2VkIiwidXBkYXRlV3JhcHBlciIsInNldERlZmF1bHRWYWx1ZSIsInBvc3RNb3VudFdyYXBwZXIiLCJpc0h5ZHJhdGluZyIsImlzQnV0dG9uIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSIsInVwZGF0ZU5hbWVkQ291c2lucyIsInJvb3ROb2RlIiwicXVlcnlSb290IiwicGFyZW50Tm9kZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJmb3JtIiwib3RoZXJQcm9wcyIsImdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUiLCJvd25lckRvY3VtZW50IiwiZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24iLCJkaWRXYXJuSW52YWxpZENoaWxkIiwiZGlkV2FybkludmFsaWRJbm5lckhUTUwiLCJ2YWxpZGF0ZVByb3BzIiwiY2hpbGRyZW4iLCJDaGlsZHJlbiIsImNoaWxkIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJzZWxlY3RlZCIsInBvc3RNb3VudFdyYXBwZXIkMSIsImlzQXJyYXlJbXBsIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJvd25lck5hbWUiLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwicHJvcE5hbWVJc0FycmF5IiwibXVsdGlwbGUiLCJ1cGRhdGVPcHRpb25zIiwicHJvcFZhbHVlIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiX2kiLCJkZWZhdWx0U2VsZWN0ZWQiLCJfc2VsZWN0ZWRWYWx1ZSIsIl9pMiIsImdldEhvc3RQcm9wcyQxIiwiaW5pdFdyYXBwZXJTdGF0ZSQxIiwid2FzTXVsdGlwbGUiLCJwb3N0TW91bnRXcmFwcGVyJDIiLCJwb3N0VXBkYXRlV3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMSIsImRpZFdhcm5WYWxEZWZhdWx0VmFsIiwiZ2V0SG9zdFByb3BzJDIiLCJpbml0V3JhcHBlclN0YXRlJDIiLCJ1cGRhdGVXcmFwcGVyJDEiLCJwb3N0TW91bnRXcmFwcGVyJDMiLCJ0ZXh0Q29udGVudCIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMiIsIkhUTUxfTkFNRVNQQUNFIiwiTUFUSF9OQU1FU1BBQ0UiLCJTVkdfTkFNRVNQQUNFIiwiZ2V0SW50cmluc2ljTmFtZXNwYWNlIiwiZ2V0Q2hpbGROYW1lc3BhY2UiLCJwYXJlbnROYW1lc3BhY2UiLCJjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uIiwiZnVuYyIsIk1TQXBwIiwiZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24iLCJhcmcwIiwiYXJnMSIsImFyZzIiLCJhcmczIiwicmV1c2FibGVTVkdDb250YWluZXIiLCJzZXRJbm5lckhUTUwiLCJodG1sIiwibmFtZXNwYWNlVVJJIiwiaW5uZXJIVE1MIiwidmFsdWVPZiIsInN2Z05vZGUiLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkNPTU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0IiwibGFzdENoaWxkIiwibm9kZVR5cGUiLCJub2RlVmFsdWUiLCJzaG9ydGhhbmRUb0xvbmdoYW5kIiwiYW5pbWF0aW9uIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRQb3NpdGlvbiIsImJvcmRlciIsImJvcmRlckJsb2NrRW5kIiwiYm9yZGVyQmxvY2tTdGFydCIsImJvcmRlckJvdHRvbSIsImJvcmRlckNvbG9yIiwiYm9yZGVySW1hZ2UiLCJib3JkZXJJbmxpbmVFbmQiLCJib3JkZXJJbmxpbmVTdGFydCIsImJvcmRlckxlZnQiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJSaWdodCIsImJvcmRlclN0eWxlIiwiYm9yZGVyVG9wIiwiYm9yZGVyV2lkdGgiLCJjb2x1bW5SdWxlIiwiY29sdW1ucyIsImZsZXgiLCJmbGV4RmxvdyIsImZvbnQiLCJmb250VmFyaWFudCIsImdhcCIsImdyaWQiLCJncmlkQXJlYSIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uR2FwIiwiZ3JpZEdhcCIsImdyaWRSb3ciLCJncmlkUm93R2FwIiwiZ3JpZFRlbXBsYXRlIiwibGlzdFN0eWxlIiwibWFyZ2luIiwibWFya2VyIiwibWFzayIsIm1hc2tQb3NpdGlvbiIsIm91dGxpbmUiLCJvdmVyZmxvdyIsInBhZGRpbmciLCJwbGFjZUNvbnRlbnQiLCJwbGFjZUl0ZW1zIiwicGxhY2VTZWxmIiwidGV4dERlY29yYXRpb24iLCJ0ZXh0RW1waGFzaXMiLCJ0cmFuc2l0aW9uIiwid29yZFdyYXAiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJhc3BlY3RSYXRpbyIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4R3JvdyIsImZsZXhQb3NpdGl2ZSIsImZsZXhTaHJpbmsiLCJmbGV4TmVnYXRpdmUiLCJmbGV4T3JkZXIiLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsImNoYXJBdCIsInN1YnN0cmluZyIsInByZWZpeGVzIiwicHJvcCIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJpc0N1c3RvbVByb3BlcnR5IiwiaXNFbXB0eSIsInVwcGVyY2FzZVBhdHRlcm4iLCJtc1BhdHRlcm4iLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJ3YXJuVmFsaWRTdHlsZSIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsIm1zUGF0dGVybiQxIiwiaHlwaGVuUGF0dGVybiIsImJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiIsIndhcm5lZFN0eWxlTmFtZXMiLCJ3YXJuZWRTdHlsZVZhbHVlcyIsIndhcm5lZEZvck5hTlZhbHVlIiwid2FybmVkRm9ySW5maW5pdHlWYWx1ZSIsImNhbWVsaXplIiwic3RyaW5nIiwiXyIsImNoYXJhY3RlciIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblN0eWxlVmFsdWVJc05hTiIsIndhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSIsImlzRmluaXRlIiwid2FyblZhbGlkU3R5bGUkMSIsImNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyIsInN0eWxlcyIsInNlcmlhbGl6ZWQiLCJkZWxpbWl0ZXIiLCJzdHlsZU5hbWUiLCJzdHlsZVZhbHVlIiwic2V0VmFsdWVGb3JTdHlsZXMiLCJzdHlsZSIsInNldFByb3BlcnR5IiwiaXNWYWx1ZUVtcHR5IiwiZXhwYW5kU2hvcnRoYW5kTWFwIiwiZXhwYW5kZWQiLCJsb25naGFuZHMiLCJ2YWxpZGF0ZVNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uSW5EZXYiLCJzdHlsZVVwZGF0ZXMiLCJuZXh0U3R5bGVzIiwiZXhwYW5kZWRVcGRhdGVzIiwiZXhwYW5kZWRTdHlsZXMiLCJ3YXJuZWRBYm91dCIsIm9yaWdpbmFsS2V5IiwiY29ycmVjdE9yaWdpbmFsS2V5Iiwid2FybmluZ0tleSIsIm9taXR0ZWRDbG9zZVRhZ3MiLCJhcmVhIiwiYmFzZSIsImJyIiwiY29sIiwiZW1iZWQiLCJociIsImltZyIsImtleWdlbiIsImxpbmsiLCJtZXRhIiwid2JyIiwidm9pZEVsZW1lbnRUYWdzIiwibWVudWl0ZW0iLCJIVE1MIiwiYXNzZXJ0VmFsaWRQcm9wcyIsInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIsImNvbnRlbnRFZGl0YWJsZSIsImlzQ3VzdG9tQ29tcG9uZW50IiwiaXMiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWN0aW9uIiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhc3luYyIsImF1dG9jYXBpdGFsaXplIiwiYXV0b2NvbXBsZXRlIiwiYXV0b2NvcnJlY3QiLCJhdXRvZm9jdXMiLCJhdXRvcGxheSIsImF1dG9zYXZlIiwiY2FwdHVyZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2l0ZSIsImNsYXNzIiwiY2xhc3NpZCIsImNsYXNzbmFtZSIsImNvbHMiLCJjb2xzcGFuIiwiY29udGVudCIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHMiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGF0YSIsImRhdGV0aW1lIiwiZGVmYXVsdCIsImRlZmF1bHRjaGVja2VkIiwiZGVmYXVsdHZhbHVlIiwiZGVmZXIiLCJkaXIiLCJkaXNhYmxlcGljdHVyZWlucGljdHVyZSIsImRpc2FibGVyZW1vdGVwbGF5YmFjayIsImRvd25sb2FkIiwiZHJhZ2dhYmxlIiwiZW5jdHlwZSIsImVudGVya2V5aGludCIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlYWRlcnMiLCJoZWlnaHQiLCJoaWdoIiwiaHJlZiIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpZCIsImltYWdlc2l6ZXMiLCJpbWFnZXNyY3NldCIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsIml0ZW1pZCIsIml0ZW1wcm9wIiwiaXRlbXJlZiIsIml0ZW1zY29wZSIsIml0ZW10eXBlIiwia2V5cGFyYW1zIiwia2V5dHlwZSIsImtpbmQiLCJsYWJlbCIsImxhbmciLCJsaXN0IiwibG9vcCIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJtYXgiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1lZGlhZ3JvdXAiLCJtZXRob2QiLCJtaW4iLCJtaW5sZW5ndGgiLCJtdXRlZCIsIm5vbW9kdWxlIiwibm9uY2UiLCJub3ZhbGlkYXRlIiwib3BlbiIsIm9wdGltdW0iLCJwYXR0ZXJuIiwicGxhY2Vob2xkZXIiLCJwbGF5c2lubGluZSIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9ncm91cCIsInJlYWRvbmx5IiwicmVmZXJyZXJwb2xpY3kiLCJyZWwiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm9sZSIsInJvd3MiLCJyb3dzcGFuIiwic2FuZGJveCIsInNjb3BlIiwic2NvcGVkIiwic2Nyb2xsaW5nIiwic2VhbWxlc3MiLCJzaGFwZSIsInNpemUiLCJzaXplcyIsInNwYW4iLCJzcGVsbGNoZWNrIiwic3JjIiwic3JjZG9jIiwic3JjbGFuZyIsInNyY3NldCIsInN0YXJ0Iiwic3RlcCIsInN1bW1hcnkiLCJ0YWJpbmRleCIsInRhcmdldCIsInRpdGxlIiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsIndyYXAiLCJhYm91dCIsImFjY2VudGhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudGJhc2VsaW5lIiwiYWxsb3dyZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY2Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVuYW1lIiwiYXR0cmlidXRldHlwZSIsImF1dG9yZXZlcnNlIiwiYXppbXV0aCIsImJhc2VmcmVxdWVuY3kiLCJiYXNlbGluZXNoaWZ0IiwiYmFzZXByb2ZpbGUiLCJiYm94IiwiYmVnaW4iLCJiaWFzIiwiYnkiLCJjYWxjbW9kZSIsImNhcGhlaWdodCIsImNsaXAiLCJjbGlwcGF0aCIsImNsaXBwYXRodW5pdHMiLCJjbGlwcnVsZSIsImNvbG9yIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3Vyc29yIiwiY3giLCJjeSIsImQiLCJkYXRhdHlwZSIsImRlY2VsZXJhdGUiLCJkZXNjZW50IiwiZGlmZnVzZWNvbnN0YW50IiwiZGlyZWN0aW9uIiwiZGlzcGxheSIsImRpdmlzb3IiLCJkb21pbmFudGJhc2VsaW5lIiwiZHVyIiwiZHgiLCJkeSIsImVkZ2Vtb2RlIiwiZWxldmF0aW9uIiwiZW5hYmxlYmFja2dyb3VuZCIsImVuZCIsImV4cG9uZW50IiwiZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZCIsImZpbGwiLCJmaWxsb3BhY2l0eSIsImZpbGxydWxlIiwiZmlsdGVycmVzIiwiZmlsdGVydW5pdHMiLCJmbG9vZG9wYWNpdHkiLCJmbG9vZGNvbG9yIiwiZm9jdXNhYmxlIiwiZm9udGZhbWlseSIsImZvbnRzaXplIiwiZm9udHNpemVhZGp1c3QiLCJmb250c3RyZXRjaCIsImZvbnRzdHlsZSIsImZvbnR2YXJpYW50IiwiZm9udHdlaWdodCIsImZyb20iLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrZXJuZWxtYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIiwia2VybmluZyIsImtleXBvaW50cyIsImtleXNwbGluZXMiLCJrZXl0aW1lcyIsImxlbmd0aGFkanVzdCIsImxldHRlcnNwYWNpbmciLCJsaWdodGluZ2NvbG9yIiwibGltaXRpbmdjb25lYW5nbGUiLCJsb2NhbCIsIm1hcmtlcmVuZCIsIm1hcmtlcmhlaWdodCIsIm1hcmtlcm1pZCIsIm1hcmtlcnN0YXJ0IiwibWFya2VydW5pdHMiLCJtYXJrZXJ3aWR0aCIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9mZnNldCIsIm9wZXJhdG9yIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVybGluZXBvc2l0aW9uIiwib3ZlcmxpbmV0aGlja25lc3MiLCJwYWludG9yZGVyIiwicGFub3NlMSIsInBhdGhsZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIiwicGF0dGVybnRyYW5zZm9ybSIsInBhdHRlcm51bml0cyIsInBvaW50ZXJldmVudHMiLCJwb2ludHMiLCJwb2ludHNhdHgiLCJwb2ludHNhdHkiLCJwb2ludHNhdHoiLCJwcmVzZXJ2ZWFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyIsInByaW1pdGl2ZXVuaXRzIiwicHJvcGVydHkiLCJyIiwicmFkaXVzIiwicmVmeCIsInJlZnkiLCJyZW5kZXJpbmdpbnRlbnQiLCJyZXBlYXRjb3VudCIsInJlcGVhdGR1ciIsInJlcXVpcmVkZXh0ZW5zaW9ucyIsInJlcXVpcmVkZmVhdHVyZXMiLCJyZXNvdXJjZSIsInJlc3RhcnQiLCJyZXN1bHRzIiwicm90YXRlIiwicngiLCJyeSIsInNjYWxlIiwic2VjdXJpdHkiLCJzZWVkIiwic2hhcGVyZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhcmNvbnN0YW50Iiwic3BlY3VsYXJleHBvbmVudCIsInNwZWVkIiwic3ByZWFkbWV0aG9kIiwic3RhcnRvZmZzZXQiLCJzdGRkZXZpYXRpb24iLCJzdGVtaCIsInN0ZW12Iiwic3RpdGNodGlsZXMiLCJzdG9wY29sb3IiLCJzdG9wb3BhY2l0eSIsInN0cmlrZXRocm91Z2hwb3NpdGlvbiIsInN0cmlrZXRocm91Z2h0aGlja25lc3MiLCJzdHJva2UiLCJzdHJva2VkYXNoYXJyYXkiLCJzdHJva2VkYXNob2Zmc2V0Iiwic3Ryb2tlbGluZWNhcCIsInN0cm9rZWxpbmVqb2luIiwic3Ryb2tlbWl0ZXJsaW1pdCIsInN0cm9rZXdpZHRoIiwic3Ryb2tlb3BhY2l0eSIsInN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZyIsInN1cHByZXNzaHlkcmF0aW9ud2FybmluZyIsInN1cmZhY2VzY2FsZSIsInN5c3RlbWxhbmd1YWdlIiwidGFibGV2YWx1ZXMiLCJ0YXJnZXR4IiwidGFyZ2V0eSIsInRleHRhbmNob3IiLCJ0ZXh0ZGVjb3JhdGlvbiIsInRleHRsZW5ndGgiLCJ0ZXh0cmVuZGVyaW5nIiwidG8iLCJ0cmFuc2Zvcm0iLCJ0eXBlb2YiLCJ1MSIsInUyIiwidW5kZXJsaW5lcG9zaXRpb24iLCJ1bmRlcmxpbmV0aGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZWJpZGkiLCJ1bmljb2RlcmFuZ2UiLCJ1bml0c3BlcmVtIiwidW5zZWxlY3RhYmxlIiwidmFscGhhYmV0aWMiLCJ2YWx1ZXMiLCJ2ZWN0b3JlZmZlY3QiLCJ2ZXJzaW9uIiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieSIsInljaGFubmVsc2VsZWN0b3IiLCJ6Iiwiem9vbWFuZHBhbiIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwic3RhbmRhcmROYW1lIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwicHVzaCIsInVua25vd25Qcm9wU3RyaW5nIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiZGlkV2FyblZhbHVlTnVsbCIsInZhbGlkYXRlUHJvcGVydGllcyQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwid2FybmVkUHJvcGVydGllcyQxIiwiRVZFTlRfTkFNRV9SRUdFWCIsIklOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCIsInJBUklBJDEiLCJyQVJJQUNhbWVsJDEiLCJldmVudFJlZ2lzdHJ5IiwiaXNSZXNlcnZlZCIsIndhcm5Vbmtub3duUHJvcGVydGllcyIsInVua25vd25Qcm9wcyIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUiLCJJU19OT05fREVMRUdBVEVEIiwiSVNfQ0FQVFVSRV9QSEFTRSIsIlNIT1VMRF9OT1RfUFJPQ0VTU19QT0xZRklMTF9FVkVOVF9QTFVHSU5TIiwiY3VycmVudFJlcGxheWluZ0V2ZW50Iiwic2V0UmVwbGF5aW5nRXZlbnQiLCJldmVudCIsInJlc2V0UmVwbGF5aW5nRXZlbnQiLCJpc1JlcGxheWluZ0V2ZW50IiwiZ2V0RXZlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsInNyY0VsZW1lbnQiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsInJlc3RvcmVJbXBsIiwicmVzdG9yZVRhcmdldCIsInJlc3RvcmVRdWV1ZSIsInJlc3RvcmVTdGF0ZU9mVGFyZ2V0IiwiaW50ZXJuYWxJbnN0YW5jZSIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJzdGF0ZU5vZGUiLCJfcHJvcHMiLCJzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24iLCJpbXBsIiwiZW5xdWV1ZVN0YXRlUmVzdG9yZSIsIm5lZWRzU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJxdWV1ZWRUYXJnZXRzIiwiYmF0Y2hlZFVwZGF0ZXNJbXBsIiwiYm9va2tlZXBpbmciLCJmbHVzaFN5bmNJbXBsIiwiaXNJbnNpZGVFdmVudEhhbmRsZXIiLCJmaW5pc2hFdmVudEhhbmRsZXIiLCJjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwic2V0QmF0Y2hpbmdJbXBsZW1lbnRhdGlvbiIsIl9iYXRjaGVkVXBkYXRlc0ltcGwiLCJfZGlzY3JldGVVcGRhdGVzSW1wbCIsIl9mbHVzaFN5bmNJbXBsIiwiaXNJbnRlcmFjdGl2ZSIsInNob3VsZFByZXZlbnRNb3VzZUV2ZW50IiwiZ2V0TGlzdGVuZXIiLCJpbnN0IiwibGlzdGVuZXIiLCJwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZCIsImYiLCJmdW5jQXJncyIsIm9uRXJyb3IiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsIiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJldnQiLCJkaWRDYWxsIiwiZGlkRXJyb3IiLCJ3aW5kb3dFdmVudCIsIndpbmRvd0V2ZW50RGVzY3JpcHRvciIsInJlc3RvcmVBZnRlckRpc3BhdGNoIiwiZXZ0VHlwZSIsImNhbGxDYWxsYmFjayIsImRpZFNldEVycm9yIiwiaXNDcm9zc09yaWdpbkVycm9yIiwiaGFuZGxlV2luZG93RXJyb3IiLCJjb2xubyIsImxpbmVubyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJfc3VwcHJlc3NMb2dnaW5nIiwiaW5uZXIiLCJpbml0RXZlbnQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEiLCJoYXNFcnJvciIsImNhdWdodEVycm9yIiwiaGFzUmV0aHJvd0Vycm9yIiwicmV0aHJvd0Vycm9yIiwicmVwb3J0ZXIiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IiLCJjbGVhckNhdWdodEVycm9yIiwicmV0aHJvd0NhdWdodEVycm9yIiwiaGFzQ2F1Z2h0RXJyb3IiLCJfcmVhY3RJbnRlcm5hbHMiLCJoYXMiLCJOb0ZsYWdzIiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIlVwZGF0ZSIsIkNoaWxkRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkRpZENhcHR1cmUiLCJGb3JjZUNsaWVudFJlbmRlciIsIlJlZiIsIlNuYXBzaG90IiwiUGFzc2l2ZSIsIkh5ZHJhdGluZyIsIlZpc2liaWxpdHkiLCJTdG9yZUNvbnNpc3RlbmN5IiwiTGlmZWN5Y2xlRWZmZWN0TWFzayIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlIiwiRm9ya2VkIiwiUmVmU3RhdGljIiwiTGF5b3V0U3RhdGljIiwiUGFzc2l2ZVN0YXRpYyIsIk1vdW50TGF5b3V0RGV2IiwiTW91bnRQYXNzaXZlRGV2IiwiQmVmb3JlTXV0YXRpb25NYXNrIiwiTXV0YXRpb25NYXNrIiwiTGF5b3V0TWFzayIsIlBhc3NpdmVNYXNrIiwiU3RhdGljTWFzayIsIlJlYWN0Q3VycmVudE93bmVyIiwiZ2V0TmVhcmVzdE1vdW50ZWRGaWJlciIsIm5lYXJlc3RNb3VudGVkIiwiYWx0ZXJuYXRlIiwibmV4dE5vZGUiLCJmbGFncyIsImdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIiLCJzdXNwZW5zZVN0YXRlIiwibWVtb2l6ZWRTdGF0ZSIsImRlaHlkcmF0ZWQiLCJnZXRDb250YWluZXJGcm9tRmliZXIiLCJjb250YWluZXJJbmZvIiwiaXNGaWJlck1vdW50ZWQiLCJpc01vdW50ZWQiLCJjb21wb25lbnQiLCJvd25lckZpYmVyIiwiaW5zdGFuY2UiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJhc3NlcnRJc01vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsInBhcmVudEEiLCJwYXJlbnRCIiwibmV4dFBhcmVudCIsInNpYmxpbmciLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsInBhcmVudCIsImN1cnJlbnRQYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlckltcGwiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsIiwic2NoZWR1bGVDYWxsYmFjayIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJjYW5jZWxDYWxsYmFjayIsInVuc3RhYmxlX2NhbmNlbENhbGxiYWNrIiwic2hvdWxkWWllbGQiLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInJlcXVlc3RQYWludCIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsIm5vdyIsInVuc3RhYmxlX25vdyIsImdldEN1cnJlbnRQcmlvcml0eUxldmVsIiwidW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwiLCJJbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsIk5vcm1hbFByaW9yaXR5IiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJMb3dQcmlvcml0eSIsInVuc3RhYmxlX0xvd1ByaW9yaXR5IiwiSWRsZVByaW9yaXR5IiwidW5zdGFibGVfSWRsZVByaW9yaXR5IiwidW5zdGFibGVfeWllbGRWYWx1ZSIsInVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlIiwicmVuZGVyZXJJRCIsImluamVjdGVkSG9vayIsImluamVjdGVkUHJvZmlsaW5nSG9va3MiLCJoYXNMb2dnZWRFcnJvciIsImlzRGV2VG9vbHNQcmVzZW50IiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwiZ2V0TGFuZUxhYmVsTWFwIiwiaW5qZWN0UHJvZmlsaW5nSG9va3MiLCJpbmplY3QiLCJjaGVja0RDRSIsIm9uU2NoZWR1bGVSb290Iiwicm9vdCIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJvbkNvbW1pdFJvb3QiLCJldmVudFByaW9yaXR5Iiwib25Db21taXRGaWJlclJvb3QiLCJzY2hlZHVsZXJQcmlvcml0eSIsIkRpc2NyZXRlRXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGVmYXVsdEV2ZW50UHJpb3JpdHkiLCJJZGxlRXZlbnRQcmlvcml0eSIsIm9uUG9zdENvbW1pdFJvb3QiLCJvblBvc3RDb21taXRGaWJlclJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzIiwibmV3SXNTdHJpY3RNb2RlIiwic2V0U3RyaWN0TW9kZSIsInByb2ZpbGluZ0hvb2tzIiwibGFuZSIsIlRvdGFsTGFuZXMiLCJnZXRMYWJlbEZvckxhbmUiLCJtYXJrQ29tbWl0U3RhcnRlZCIsImxhbmVzIiwibWFya0NvbW1pdFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50RXJyb3JlZCIsInRocm93blZhbHVlIiwibWFya0NvbXBvbmVudFN1c3BlbmRlZCIsIndha2VhYmxlIiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQiLCJtYXJrUmVuZGVyU3RhcnRlZCIsIm1hcmtSZW5kZXJZaWVsZGVkIiwibWFya1JlbmRlclN0b3BwZWQiLCJtYXJrUmVuZGVyU2NoZWR1bGVkIiwibWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwiTm9Nb2RlIiwiQ29uY3VycmVudE1vZGUiLCJQcm9maWxlTW9kZSIsIlN0cmljdExlZ2FjeU1vZGUiLCJTdHJpY3RFZmZlY3RzTW9kZSIsImNsejMyIiwiTWF0aCIsImNsejMyRmFsbGJhY2siLCJMTjIiLCJhc1VpbnQiLCJOb0xhbmVzIiwiTm9MYW5lIiwiU3luY0xhbmUiLCJJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIiwiSW5wdXRDb250aW51b3VzTGFuZSIsIkRlZmF1bHRIeWRyYXRpb25MYW5lIiwiRGVmYXVsdExhbmUiLCJUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSIsIlRyYW5zaXRpb25MYW5lcyIsIlRyYW5zaXRpb25MYW5lMSIsIlRyYW5zaXRpb25MYW5lMiIsIlRyYW5zaXRpb25MYW5lMyIsIlRyYW5zaXRpb25MYW5lNCIsIlRyYW5zaXRpb25MYW5lNSIsIlRyYW5zaXRpb25MYW5lNiIsIlRyYW5zaXRpb25MYW5lNyIsIlRyYW5zaXRpb25MYW5lOCIsIlRyYW5zaXRpb25MYW5lOSIsIlRyYW5zaXRpb25MYW5lMTAiLCJUcmFuc2l0aW9uTGFuZTExIiwiVHJhbnNpdGlvbkxhbmUxMiIsIlRyYW5zaXRpb25MYW5lMTMiLCJUcmFuc2l0aW9uTGFuZTE0IiwiVHJhbnNpdGlvbkxhbmUxNSIsIlRyYW5zaXRpb25MYW5lMTYiLCJSZXRyeUxhbmVzIiwiUmV0cnlMYW5lMSIsIlJldHJ5TGFuZTIiLCJSZXRyeUxhbmUzIiwiUmV0cnlMYW5lNCIsIlJldHJ5TGFuZTUiLCJTb21lUmV0cnlMYW5lIiwiU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSIsIk5vbklkbGVMYW5lcyIsIklkbGVIeWRyYXRpb25MYW5lIiwiSWRsZUxhbmUiLCJPZmZzY3JlZW5MYW5lIiwiTm9UaW1lc3RhbXAiLCJuZXh0VHJhbnNpdGlvbkxhbmUiLCJuZXh0UmV0cnlMYW5lIiwiZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lIiwiZ2V0TmV4dExhbmVzIiwid2lwTGFuZXMiLCJwZW5kaW5nTGFuZXMiLCJuZXh0TGFuZXMiLCJzdXNwZW5kZWRMYW5lcyIsInBpbmdlZExhbmVzIiwibm9uSWRsZVBlbmRpbmdMYW5lcyIsIm5vbklkbGVVbmJsb2NrZWRMYW5lcyIsIm5vbklkbGVQaW5nZWRMYW5lcyIsInVuYmxvY2tlZExhbmVzIiwibmV4dExhbmUiLCJ3aXBMYW5lIiwiZW50YW5nbGVkTGFuZXMiLCJlbnRhbmdsZW1lbnRzIiwicGlja0FyYml0cmFyeUxhbmVJbmRleCIsImdldE1vc3RSZWNlbnRFdmVudFRpbWUiLCJldmVudFRpbWVzIiwibW9zdFJlY2VudEV2ZW50VGltZSIsImV2ZW50VGltZSIsImNvbXB1dGVFeHBpcmF0aW9uVGltZSIsImN1cnJlbnRUaW1lIiwibWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZCIsImV4cGlyYXRpb25UaW1lcyIsImV4cGlyYXRpb25UaW1lIiwiZXhwaXJlZExhbmVzIiwiZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzIiwiZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3IiLCJldmVyeXRoaW5nQnV0T2Zmc2NyZWVuIiwiaW5jbHVkZXNTeW5jTGFuZSIsImluY2x1ZGVzTm9uSWRsZVdvcmsiLCJpbmNsdWRlc09ubHlSZXRyaWVzIiwiaW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMiLCJVcmdlbnRMYW5lcyIsImluY2x1ZGVzT25seVRyYW5zaXRpb25zIiwiaW5jbHVkZXNCbG9ja2luZ0xhbmUiLCJTeW5jRGVmYXVsdExhbmVzIiwiaW5jbHVkZXNFeHBpcmVkTGFuZSIsImlzVHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFJldHJ5TGFuZSIsInBpY2tBcmJpdHJhcnlMYW5lIiwibGFuZVRvSW5kZXgiLCJpbmNsdWRlc1NvbWVMYW5lIiwiaXNTdWJzZXRPZkxhbmVzIiwic3Vic2V0IiwibWVyZ2VMYW5lcyIsInJlbW92ZUxhbmVzIiwiaW50ZXJzZWN0TGFuZXMiLCJsYW5lVG9MYW5lcyIsImhpZ2hlclByaW9yaXR5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsIm1hcmtSb290VXBkYXRlZCIsInVwZGF0ZUxhbmUiLCJtYXJrUm9vdFN1c3BlbmRlZCIsIm1hcmtSb290UGluZ2VkIiwibWFya1Jvb3RGaW5pc2hlZCIsInJlbWFpbmluZ0xhbmVzIiwibm9Mb25nZXJQZW5kaW5nTGFuZXMiLCJtdXRhYmxlUmVhZExhbmVzIiwibWFya1Jvb3RFbnRhbmdsZWQiLCJyb290RW50YW5nbGVkTGFuZXMiLCJnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uIiwicmVuZGVyTGFuZXMiLCJyZW5kZXJMYW5lIiwiYWRkRmliZXJUb0xhbmVzTWFwIiwicGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCIsInVwZGF0ZXJzIiwibW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkIiwibWVtb2l6ZWRVcGRhdGVycyIsImNsZWFyIiwiZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcyIsImN1cnJlbnRVcGRhdGVQcmlvcml0eSIsImdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsInNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsIm5ld1ByaW9yaXR5IiwicnVuV2l0aFByaW9yaXR5IiwicHJpb3JpdHkiLCJwcmV2aW91c1ByaW9yaXR5IiwiaGlnaGVyRXZlbnRQcmlvcml0eSIsImxvd2VyRXZlbnRQcmlvcml0eSIsImlzSGlnaGVyRXZlbnRQcmlvcml0eSIsImxhbmVzVG9FdmVudFByaW9yaXR5IiwiaXNSb290RGVoeWRyYXRlZCIsImN1cnJlbnRTdGF0ZSIsImlzRGVoeWRyYXRlZCIsIl9hdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJzZXRBdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24iLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiIsInNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5Iiwic2V0QXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5IiwiZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5JDEiLCJzZXRHZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJhdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eSIsInNldEF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5IiwiaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCIsInF1ZXVlZERpc2NyZXRlRXZlbnRzIiwicXVldWVkRm9jdXMiLCJxdWV1ZWREcmFnIiwicXVldWVkTW91c2UiLCJxdWV1ZWRQb2ludGVycyIsInF1ZXVlZFBvaW50ZXJDYXB0dXJlcyIsInF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cyIsImRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cyIsImlzRGlzY3JldGVFdmVudFRoYXRSZXF1aXJlc0h5ZHJhdGlvbiIsImV2ZW50VHlwZSIsImNyZWF0ZVF1ZXVlZFJlcGxheWFibGVFdmVudCIsImJsb2NrZWRPbiIsImRvbUV2ZW50TmFtZSIsImV2ZW50U3lzdGVtRmxhZ3MiLCJ0YXJnZXRDb250YWluZXIiLCJ0YXJnZXRDb250YWluZXJzIiwiY2xlYXJJZkNvbnRpbnVvdXNFdmVudCIsInBvaW50ZXJJZCIsImRlbGV0ZSIsIl9wb2ludGVySWQiLCJhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50IiwiZXhpc3RpbmdRdWV1ZWRFdmVudCIsInF1ZXVlZEV2ZW50IiwiX2ZpYmVyMiIsInF1ZXVlSWZDb250aW51b3VzRXZlbnQiLCJmb2N1c0V2ZW50IiwiZHJhZ0V2ZW50IiwibW91c2VFdmVudCIsInBvaW50ZXJFdmVudCIsIl9wb2ludGVyRXZlbnQiLCJfcG9pbnRlcklkMiIsImF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldCIsInF1ZXVlZFRhcmdldCIsInRhcmdldEluc3QiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsInF1ZXVlRXhwbGljaXRIeWRyYXRpb25UYXJnZXQiLCJ1cGRhdGVQcmlvcml0eSIsInNwbGljZSIsImF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQiLCJuZXh0QmxvY2tlZE9uIiwiZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudCIsIm5hdGl2ZUV2ZW50Q2xvbmUiLCJfZmliZXIzIiwic2hpZnQiLCJhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXAiLCJyZXBsYXlVbmJsb2NrZWRFdmVudHMiLCJzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQiLCJ1bmJsb2NrZWQiLCJyZXRyeUlmQmxvY2tlZE9uIiwidW5ibG9jayIsIm5leHRFeHBsaWNpdFRhcmdldCIsIlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnIiwiX2VuYWJsZWQiLCJzZXRFbmFibGVkIiwiZW5hYmxlZCIsImlzRW5hYmxlZCIsImNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5IiwiZ2V0RXZlbnRQcmlvcml0eSIsImxpc3RlbmVyV3JhcHBlciIsImRpc3BhdGNoRGlzY3JldGVFdmVudCIsImRpc3BhdGNoQ29udGludW91c0V2ZW50IiwiYmluZCIsImNvbnRhaW5lciIsInByZXZUcmFuc2l0aW9uIiwiZGlzcGF0Y2hFdmVudFdpdGhFbmFibGVDYXB0dXJlUGhhc2VTZWxlY3RpdmVIeWRyYXRpb25XaXRob3V0RGlzY3JldGVFdmVudFJlcGxheSIsImRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbSIsInJldHVybl90YXJnZXRJbnN0Iiwic3RvcFByb3BhZ2F0aW9uIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJhZGRFdmVudEJ1YmJsZUxpc3RlbmVyIiwiYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIiLCJhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyIsInBhc3NpdmUiLCJhZGRFdmVudEJ1YmJsZUxpc3RlbmVyV2l0aFBhc3NpdmVGbGFnIiwic3RhcnRUZXh0IiwiZmFsbGJhY2tUZXh0IiwiaW5pdGlhbGl6ZSIsImdldFRleHQiLCJnZXREYXRhIiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJnZXRFdmVudENoYXJDb2RlIiwiY2hhckNvZGUiLCJrZXlDb2RlIiwiZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUiLCJmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UiLCJjcmVhdGVTeW50aGV0aWNFdmVudCIsIkludGVyZmFjZSIsIlN5bnRoZXRpY0Jhc2VFdmVudCIsInJlYWN0TmFtZSIsInJlYWN0RXZlbnRUeXBlIiwiX3JlYWN0TmFtZSIsIl90YXJnZXRJbnN0IiwiY3VycmVudFRhcmdldCIsIl9wcm9wTmFtZSIsIm5vcm1hbGl6ZSIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50RGVmYXVsdCIsImNhbmNlbEJ1YmJsZSIsInBlcnNpc3QiLCJpc1BlcnNpc3RlbnQiLCJFdmVudEludGVyZmFjZSIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsIkRhdGUiLCJpc1RydXN0ZWQiLCJTeW50aGV0aWNFdmVudCIsIlVJRXZlbnRJbnRlcmZhY2UiLCJ2aWV3IiwiZGV0YWlsIiwiU3ludGhldGljVUlFdmVudCIsImxhc3RNb3ZlbWVudFgiLCJsYXN0TW92ZW1lbnRZIiwibGFzdE1vdXNlRXZlbnQiLCJ1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiTW91c2VFdmVudEludGVyZmFjZSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJnZXRNb2RpZmllclN0YXRlIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJkYXRhVHJhbnNmZXIiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsIkFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJub3JtYWxpemVLZXkiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsImZyb21DaGFyQ29kZSIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJLZXlib2FyZEV2ZW50SW50ZXJmYWNlIiwiY29kZSIsImxvY2F0aW9uIiwicmVwZWF0IiwibG9jYWxlIiwid2hpY2giLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiUG9pbnRlckV2ZW50SW50ZXJmYWNlIiwicHJlc3N1cmUiLCJ0YW5nZW50aWFsUHJlc3N1cmUiLCJ0aWx0WCIsInRpbHRZIiwidHdpc3QiLCJwb2ludGVyVHlwZSIsImlzUHJpbWFyeSIsIlN5bnRoZXRpY1BvaW50ZXJFdmVudCIsIlRvdWNoRXZlbnRJbnRlcmZhY2UiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiU3ludGhldGljVG91Y2hFdmVudCIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImRvY3VtZW50TW9kZSIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwidXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsInJlZ2lzdGVyRXZlbnRzIiwiaGFzU3BhY2VLZXlwcmVzcyIsImlzS2V5cHJlc3NDb21tYW5kIiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJpc1VzaW5nS29yZWFuSU1FIiwiaXNDb21wb3NpbmciLCJleHRyYWN0Q29tcG9zaXRpb25FdmVudCIsImRpc3BhdGNoUXVldWUiLCJmYWxsYmFja0RhdGEiLCJsaXN0ZW5lcnMiLCJhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiY2hhciIsImV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50IiwiZXh0cmFjdEV2ZW50cyIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJkYXRlIiwiZW1haWwiLCJtb250aCIsIm51bWJlciIsInBhc3N3b3JkIiwicmFuZ2UiLCJzZWFyY2giLCJ0ZWwiLCJ0aW1lIiwid2VlayIsImlzVGV4dElucHV0RWxlbWVudCIsImlzRXZlbnRTdXBwb3J0ZWQiLCJldmVudE5hbWVTdWZmaXgiLCJldmVudE5hbWUiLCJpc1N1cHBvcnRlZCIsInJlZ2lzdGVyRXZlbnRzJDEiLCJjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsInByb2Nlc3NEaXNwYXRjaFF1ZXVlIiwiZ2V0SW5zdElmVmFsdWVDaGFuZ2VkIiwidGFyZ2V0Tm9kZSIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJhdHRhY2hFdmVudCIsImhhbmRsZVByb3BlcnR5Q2hhbmdlIiwic3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJkZXRhY2hFdmVudCIsImhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCIsImdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJzaG91bGRVc2VDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50IiwiaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1ciIsInN0YXRlIiwiZXh0cmFjdEV2ZW50cyQxIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJyZWdpc3RlckV2ZW50cyQyIiwiZXh0cmFjdEV2ZW50cyQyIiwiaXNPdmVyRXZlbnQiLCJpc091dEV2ZW50IiwicmVsYXRlZCIsImlzQ29udGFpbmVyTWFya2VkQXNSb290Iiwid2luIiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJfcmVsYXRlZCIsIlN5bnRoZXRpY0V2ZW50Q3RvciIsImxlYXZlRXZlbnRUeXBlIiwiZW50ZXJFdmVudFR5cGUiLCJldmVudFR5cGVQcmVmaXgiLCJmcm9tTm9kZSIsInRvTm9kZSIsImxlYXZlIiwiZW50ZXIiLCJuYXRpdmVUYXJnZXRJbnN0IiwiZW50ZXJFdmVudCIsImFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMiLCJvYmplY3RJcyIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsImN1cnJlbnRLZXkiLCJnZXRMZWFmTm9kZSIsImdldFNpYmxpbmdOb2RlIiwibmV4dFNpYmxpbmciLCJnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0Iiwibm9kZVN0YXJ0Iiwibm9kZUVuZCIsImdldE9mZnNldHMiLCJvdXRlck5vZGUiLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJyYW5nZUNvdW50IiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMiLCJpbmRleFdpdGhpbkFuY2hvciIsImluZGV4V2l0aGluRm9jdXMiLCJvdXRlciIsIm5leHQiLCJzZXRPZmZzZXRzIiwib2Zmc2V0cyIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJyZW1vdmVBbGxSYW5nZXMiLCJhZGRSYW5nZSIsInNldEVuZCIsImlzVGV4dE5vZGUiLCJjb250YWluc05vZGUiLCJpbm5lck5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiaXNJbkRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiaXNTYW1lT3JpZ2luRnJhbWUiLCJpZnJhbWUiLCJjb250ZW50V2luZG93IiwiZ2V0QWN0aXZlRWxlbWVudERlZXAiLCJIVE1MSUZyYW1lRWxlbWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwiZm9jdXNlZEVsZW0iLCJzZWxlY3Rpb25SYW5nZSIsInJlc3RvcmVTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsImFuY2VzdG9ycyIsImFuY2VzdG9yIiwic2Nyb2xsTGVmdCIsInRvcCIsInNjcm9sbFRvcCIsImZvY3VzIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJyZWdpc3RlckV2ZW50cyQzIiwiYWN0aXZlRWxlbWVudCQxIiwiYWN0aXZlRWxlbWVudEluc3QkMSIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJnZXRTZWxlY3Rpb24kMSIsImdldEV2ZW50VGFyZ2V0RG9jdW1lbnQiLCJldmVudFRhcmdldCIsImNvbnN0cnVjdFNlbGVjdEV2ZW50IiwiY3VycmVudFNlbGVjdGlvbiIsImV4dHJhY3RFdmVudHMkMyIsIm1ha2VQcmVmaXhNYXAiLCJzdHlsZVByb3AiLCJ2ZW5kb3JQcmVmaXhlcyIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsInByZWZpeGVkRXZlbnROYW1lcyIsImdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lIiwicHJlZml4TWFwIiwiQU5JTUFUSU9OX0VORCIsIkFOSU1BVElPTl9JVEVSQVRJT04iLCJBTklNQVRJT05fU1RBUlQiLCJUUkFOU0lUSU9OX0VORCIsInRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzIiwic2ltcGxlRXZlbnRQbHVnaW5FdmVudHMiLCJyZWdpc3RlclNpbXBsZUV2ZW50IiwicmVnaXN0ZXJTaW1wbGVFdmVudHMiLCJjYXBpdGFsaXplZEV2ZW50IiwiZXh0cmFjdEV2ZW50cyQ0IiwiaW5DYXB0dXJlUGhhc2UiLCJhY2N1bXVsYXRlVGFyZ2V0T25seSIsIl9saXN0ZW5lcnMiLCJhY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnMiLCJfZXZlbnQiLCJleHRyYWN0RXZlbnRzJDUiLCJzaG91bGRQcm9jZXNzUG9seWZpbGxQbHVnaW5zIiwibWVkaWFFdmVudFR5cGVzIiwibm9uRGVsZWdhdGVkRXZlbnRzIiwiZXhlY3V0ZURpc3BhdGNoIiwicHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIiLCJkaXNwYXRjaExpc3RlbmVycyIsInByZXZpb3VzSW5zdGFuY2UiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMkaSIsIl9kaXNwYXRjaExpc3RlbmVycyRfaSIsIl9pbnN0YW5jZSIsIl9jdXJyZW50VGFyZ2V0IiwiX2xpc3RlbmVyIiwiX2Rpc3BhdGNoUXVldWUkaSIsImRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyIsImxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQiLCJ0YXJnZXRFbGVtZW50IiwiaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciIsImxpc3RlbmVyU2V0IiwiZ2V0RXZlbnRMaXN0ZW5lclNldCIsImxpc3RlbmVyU2V0S2V5IiwiZ2V0TGlzdGVuZXJTZXRLZXkiLCJhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lciIsImxpc3RlblRvTmF0aXZlRXZlbnQiLCJsaXN0ZW5pbmdNYXJrZXIiLCJyYW5kb20iLCJsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyIsInJvb3RDb250YWluZXJFbGVtZW50IiwiaXNEZWZlcnJlZExpc3RlbmVyRm9yTGVnYWN5RkJTdXBwb3J0IiwiaXNQYXNzaXZlTGlzdGVuZXIiLCJ1bnN1YnNjcmliZUxpc3RlbmVyIiwiaXNNYXRjaGluZ1Jvb3RDb250YWluZXIiLCJncmFuZENvbnRhaW5lciIsImFuY2VzdG9ySW5zdCIsInRhcmdldENvbnRhaW5lck5vZGUiLCJtYWluTG9vcCIsIm5vZGVUYWciLCJncmFuZE5vZGUiLCJncmFuZFRhZyIsInBhcmVudFRhZyIsImNyZWF0ZURpc3BhdGNoTGlzdGVuZXIiLCJ0YXJnZXRGaWJlciIsIm5hdGl2ZUV2ZW50VHlwZSIsImNhcHR1cmVOYW1lIiwicmVhY3RFdmVudE5hbWUiLCJsYXN0SG9zdENvbXBvbmVudCIsIl9pbnN0YW5jZTIiLCJfaW5zdGFuY2UzIiwiY2FwdHVyZUxpc3RlbmVyIiwiYnViYmxlTGlzdGVuZXIiLCJnZXRQYXJlbnQiLCJnZXRMb3dlc3RDb21tb25BbmNlc3RvciIsImluc3RBIiwiaW5zdEIiLCJub2RlQSIsIm5vZGVCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudCIsImNvbW1vbiIsIl9pbnN0YW5jZTQiLCJsZWF2ZUV2ZW50IiwiZGlkV2FybkludmFsaWRIeWRyYXRpb24iLCJEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCIsIlNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIiwiQVVUT0ZPQ1VTIiwiQ0hJTERSRU4iLCJTVFlMRSIsIkhUTUwkMSIsIndhcm5lZFVua25vd25UYWdzIiwidmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCIsIndhcm5Gb3JQcm9wRGlmZmVyZW5jZSIsIndhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMiLCJ3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIiLCJjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nIiwibm9ybWFsaXplSFRNTCIsImRpYWxvZyIsIndlYnZpZXciLCJzZXJ2ZXJWYWx1ZSIsImNsaWVudFZhbHVlIiwibm9ybWFsaXplZENsaWVudFZhbHVlIiwibm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlIiwibm9ybWFsaXplZFNlcnZlclZhbHVlIiwiYXR0cmlidXRlTmFtZXMiLCJuYW1lcyIsInRlc3RFbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwiTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYIiwiTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYIiwibWFya3VwIiwibWFya3VwU3RyaW5nIiwiY2hlY2tGb3JVbm1hdGNoZWRUZXh0Iiwic2VydmVyVGV4dCIsImNsaWVudFRleHQiLCJpc0NvbmN1cnJlbnRNb2RlIiwic2hvdWxkV2FybkRldiIsIm5vcm1hbGl6ZWRDbGllbnRUZXh0Iiwibm9ybWFsaXplZFNlcnZlclRleHQiLCJnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIiLCJub29wIiwidHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQiLCJvbmNsaWNrIiwic2V0SW5pdGlhbERPTVByb3BlcnRpZXMiLCJkb21FbGVtZW50IiwibmV4dFByb3BzIiwicHJvcEtleSIsIm5leHRQcm9wIiwiZnJlZXplIiwibmV4dEh0bWwiLCJjYW5TZXRUZXh0Q29udGVudCIsInVwZGF0ZURPTVByb3BlcnRpZXMiLCJ1cGRhdGVQYXlsb2FkIiwid2FzQ3VzdG9tQ29tcG9uZW50VGFnIiwiZGl2IiwiY3JlYXRlVGV4dE5vZGUiLCJzZXRJbml0aWFsUHJvcGVydGllcyIsInJhd1Byb3BzIiwib25DbGljayIsImRpZmZQcm9wZXJ0aWVzIiwibGFzdFJhd1Byb3BzIiwibmV4dFJhd1Byb3BzIiwibGFzdFByb3BzIiwibGFzdFN0eWxlIiwibGFzdFByb3AiLCJsYXN0SHRtbCIsInVwZGF0ZVByb3BlcnRpZXMiLCJnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZSIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMiLCJleHRyYUF0dHJpYnV0ZU5hbWVzIiwiYXR0cmlidXRlcyIsInNlcnZlckhUTUwiLCJleHBlY3RlZEhUTUwiLCJleHBlY3RlZFN0eWxlIiwiaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nIiwib3duTmFtZXNwYWNlIiwiZG9udFdhcm5DdXN0b21FbGVtZW50IiwiZGlmZkh5ZHJhdGVkVGV4dCIsInRleHROb2RlIiwiaXNEaWZmZXJlbnQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyIsInZhbGlkYXRlRE9NTmVzdGluZyIsInVwZGF0ZWRBbmNlc3RvckluZm8iLCJzcGVjaWFsVGFncyIsImluU2NvcGVUYWdzIiwiYnV0dG9uU2NvcGVUYWdzIiwiaW1wbGllZEVuZFRhZ3MiLCJlbXB0eUFuY2VzdG9ySW5mbyIsImZvcm1UYWciLCJhVGFnSW5TY29wZSIsImJ1dHRvblRhZ0luU2NvcGUiLCJub2JyVGFnSW5TY29wZSIsInBUYWdJbkJ1dHRvblNjb3BlIiwibGlzdEl0ZW1UYWdBdXRvY2xvc2luZyIsImRsSXRlbVRhZ0F1dG9jbG9zaW5nIiwib2xkSW5mbyIsImFuY2VzdG9ySW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImRpZFdhcm4kMSIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwicGFyZW50SW5mbyIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJpbnZhbGlkUGFyZW50T3JBbmNlc3RvciIsImFuY2VzdG9yVGFnIiwid2FybktleSIsInRhZ0Rpc3BsYXlOYW1lIiwid2hpdGVzcGFjZUluZm8iLCJTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxIiwiU1VTUEVOU0VfU1RBUlRfREFUQSIsIlNVU1BFTlNFX0VORF9EQVRBIiwiU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBIiwiU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSIsIlNUWUxFJDEiLCJldmVudHNFbmFibGVkIiwic2VsZWN0aW9uSW5mb3JtYXRpb24iLCJnZXRSb290SG9zdENvbnRleHQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJuYW1lc3BhY2UiLCJ2YWxpZGF0ZWRUYWciLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwicGFyZW50SG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dERldiIsImdldFB1YmxpY0luc3RhbmNlIiwicHJlcGFyZUZvckNvbW1pdCIsImFjdGl2ZUluc3RhbmNlIiwicmVzZXRBZnRlckNvbW1pdCIsImNyZWF0ZUluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaG9zdENvbnRleHREZXYiLCJvd25BbmNlc3RvckluZm8iLCJwcmVjYWNoZUZpYmVyTm9kZSIsInVwZGF0ZUZpYmVyUHJvcHMiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJwYXJlbnRJbnN0YW5jZSIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwiYXV0b0ZvY3VzIiwicHJlcGFyZVVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsIl9faHRtbCIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImdldEN1cnJlbnRFdmVudFByaW9yaXR5IiwiY3VycmVudEV2ZW50Iiwic2NoZWR1bGVUaW1lb3V0Iiwic2V0VGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJub1RpbWVvdXQiLCJsb2NhbFByb21pc2UiLCJQcm9taXNlIiwic2NoZWR1bGVNaWNyb3Rhc2siLCJxdWV1ZU1pY3JvdGFzayIsImNhbGxiYWNrIiwicmVzb2x2ZSIsInRoZW4iLCJjYXRjaCIsImhhbmRsZUVycm9ySW5OZXh0VGljayIsImNvbW1pdE1vdW50IiwiY29tbWl0VXBkYXRlIiwicmVzZXRUZXh0Q29udGVudCIsImNvbW1pdFRleHRVcGRhdGUiLCJ0ZXh0SW5zdGFuY2UiLCJvbGRUZXh0IiwibmV3VGV4dCIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJpbnNlcnRCZWZvcmUiLCJyZWFjdFJvb3RDb250YWluZXIiLCJfcmVhY3RSb290Q29udGFpbmVyIiwiYmVmb3JlQ2hpbGQiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeSIsInN1c3BlbnNlSW5zdGFuY2UiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwiaGlkZUluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZUluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwiY2xlYXJDb250YWluZXIiLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJyZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSIsIl9yZWFjdFJldHJ5IiwiZ2V0TmV4dEh5ZHJhdGFibGUiLCJub2RlRGF0YSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJwYXJlbnRDb250YWluZXIiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlIiwiZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSIsInRhcmdldEluc3RhbmNlIiwicHJldmlvdXNTaWJsaW5nIiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyIsInBhcmVudFR5cGUiLCJkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSIsInBhcmVudFByb3BzIiwiZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluQ29udGFpbmVyIiwiZGlkTm90SHlkcmF0ZUluc3RhbmNlV2l0aGluU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5Db250YWluZXIiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZVdpdGhpbkNvbnRhaW5lciIsImRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2VXaXRoaW5TdXNwZW5zZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwiZXJyb3JIeWRyYXRpbmdDb250YWluZXIiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJwb3J0YWxJbnN0YW5jZSIsInJhbmRvbUtleSIsImludGVybmFsSW5zdGFuY2VLZXkiLCJpbnRlcm5hbFByb3BzS2V5IiwiaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleSIsImludGVybmFsRXZlbnRIYW5kbGVyc0tleSIsImludGVybmFsRXZlbnRIYW5kbGVyTGlzdGVuZXJzS2V5IiwiaW50ZXJuYWxFdmVudEhhbmRsZXNTZXRLZXkiLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJob3N0SW5zdCIsIm1hcmtDb250YWluZXJBc1Jvb3QiLCJob3N0Um9vdCIsInVubWFya0NvbnRhaW5lckFzUm9vdCIsInRhcmdldFN1c3BlbnNlSW5zdCIsImVsZW1lbnRMaXN0ZW5lclNldCIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSIsInNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwiY29tcG9uZW50TmFtZSIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJleCIsInZhbHVlU3RhY2siLCJmaWJlclN0YWNrIiwiY3JlYXRlQ3Vyc29yIiwicG9wIiwid2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0IiwiZW1wdHlDb250ZXh0T2JqZWN0IiwiY29udGV4dFN0YWNrQ3Vyc29yIiwiZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciIsInByZXZpb3VzQ29udGV4dCIsImdldFVubWFza2VkQ29udGV4dCIsImRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlciIsImlzQ29udGV4dFByb3ZpZGVyIiwiY2FjaGVDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwibWFza2VkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsImdldE1hc2tlZENvbnRleHQiLCJjb250ZXh0VHlwZXMiLCJoYXNDb250ZXh0Q2hhbmdlZCIsImNoaWxkQ29udGV4dFR5cGVzIiwicG9wQ29udGV4dCIsInBvcFRvcExldmVsQ29udGV4dE9iamVjdCIsInB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QiLCJkaWRDaGFuZ2UiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwicGFyZW50Q29udGV4dCIsImdldENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dCIsImNvbnRleHRLZXkiLCJwdXNoQ29udGV4dFByb3ZpZGVyIiwibWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsImludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIiLCJtZXJnZWRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJMZWdhY3lSb290IiwiQ29uY3VycmVudFJvb3QiLCJzeW5jUXVldWUiLCJpbmNsdWRlc0xlZ2FjeVN5bmNDYWxsYmFja3MiLCJpc0ZsdXNoaW5nU3luY1F1ZXVlIiwic2NoZWR1bGVTeW5jQ2FsbGJhY2siLCJzY2hlZHVsZUxlZ2FjeVN5bmNDYWxsYmFjayIsImZsdXNoU3luY0NhbGxiYWNrc09ubHlJbkxlZ2FjeU1vZGUiLCJmbHVzaFN5bmNDYWxsYmFja3MiLCJwcmV2aW91c1VwZGF0ZVByaW9yaXR5IiwiaXNTeW5jIiwicXVldWUiLCJSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxIiwiTm9UcmFuc2l0aW9uIiwicmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uIiwiUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MiLCJyZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsImZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwicmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmciLCJmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyIsImZpbmRTdHJpY3RSb290IiwibWF5YmVTdHJpY3RSb290Iiwic2V0VG9Tb3J0ZWRTdHJpbmciLCJhcnJheSIsInBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwic29ydGVkTmFtZXMiLCJfc29ydGVkTmFtZXMiLCJfc29ydGVkTmFtZXMyIiwiX3NvcnRlZE5hbWVzMyIsIl9zb3J0ZWROYW1lczQiLCJfc29ydGVkTmFtZXM1IiwicGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCIsInN0cmljdFJvb3QiLCJ3YXJuaW5nc0ZvclJvb3QiLCJmaWJlckFycmF5IiwiZmlyc3RGaWJlciIsInVuaXF1ZU5hbWVzIiwicmVzb2x2ZURlZmF1bHRQcm9wcyIsImJhc2VQcm9wcyIsImRlZmF1bHRQcm9wcyIsInZhbHVlQ3Vyc29yIiwicmVuZGVyZXJTaWdpbCIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyIiwibGFzdENvbnRleHREZXBlbmRlbmN5IiwibGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0IiwiaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViIsInJlc2V0Q29udGV4dERlcGVuZGVuY2llcyIsImVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJwdXNoUHJvdmlkZXIiLCJwcm92aWRlckZpYmVyIiwiX2N1cnJlbnRWYWx1ZSIsIl9jdXJyZW50UmVuZGVyZXIiLCJwb3BQcm92aWRlciIsInNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgiLCJwcm9wYWdhdGlvblJvb3QiLCJjaGlsZExhbmVzIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZSIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIiLCJuZXh0RmliZXIiLCJkZXBlbmRlbmN5IiwiZmlyc3RDb250ZXh0IiwidXBkYXRlIiwiY3JlYXRlVXBkYXRlIiwiRm9yY2VVcGRhdGUiLCJ1cGRhdGVRdWV1ZSIsInNoYXJlZFF1ZXVlIiwic2hhcmVkIiwicGVuZGluZyIsInBhcmVudFN1c3BlbnNlIiwiX2FsdGVybmF0ZSIsInByZXBhcmVUb1JlYWRDb250ZXh0IiwibWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUiLCJyZWFkQ29udGV4dCIsImNvbnRleHRJdGVtIiwibWVtb2l6ZWRWYWx1ZSIsImludGVybGVhdmVkUXVldWVzIiwicHVzaEludGVybGVhdmVkUXVldWUiLCJoYXNJbnRlcmxlYXZlZFVwZGF0ZXMiLCJlbnF1ZXVlSW50ZXJsZWF2ZWRVcGRhdGVzIiwibGFzdEludGVybGVhdmVkVXBkYXRlIiwiaW50ZXJsZWF2ZWQiLCJmaXJzdEludGVybGVhdmVkVXBkYXRlIiwibGFzdFBlbmRpbmdVcGRhdGUiLCJmaXJzdFBlbmRpbmdVcGRhdGUiLCJVcGRhdGVTdGF0ZSIsIlJlcGxhY2VTdGF0ZSIsIkNhcHR1cmVVcGRhdGUiLCJoYXNGb3JjZVVwZGF0ZSIsImRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUiLCJjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJpbml0aWFsaXplVXBkYXRlUXVldWUiLCJiYXNlU3RhdGUiLCJmaXJzdEJhc2VVcGRhdGUiLCJsYXN0QmFzZVVwZGF0ZSIsImVmZmVjdHMiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3VycmVudFF1ZXVlIiwiY2xvbmUiLCJlbnF1ZXVlVXBkYXRlIiwiaXNJbnRlcmxlYXZlZFVwZGF0ZSIsImVudGFuZ2xlVHJhbnNpdGlvbnMiLCJxdWV1ZUxhbmVzIiwibmV3UXVldWVMYW5lcyIsImVucXVldWVDYXB0dXJlZFVwZGF0ZSIsImNhcHR1cmVkVXBkYXRlIiwibmV3Rmlyc3QiLCJuZXdMYXN0IiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicHJldlN0YXRlIiwibmV4dFN0YXRlIiwicGFydGlhbFN0YXRlIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwicGVuZGluZ1F1ZXVlIiwiY3VycmVudExhc3RCYXNlVXBkYXRlIiwibmV3U3RhdGUiLCJuZXdMYW5lcyIsIm5ld0Jhc2VTdGF0ZSIsIm5ld0ZpcnN0QmFzZVVwZGF0ZSIsIm5ld0xhc3RCYXNlVXBkYXRlIiwidXBkYXRlRXZlbnRUaW1lIiwiX2Nsb25lIiwiX2xhc3RQZW5kaW5nVXBkYXRlIiwiX2ZpcnN0UGVuZGluZ1VwZGF0ZSIsImxhc3RJbnRlcmxlYXZlZCIsIm1hcmtTa2lwcGVkVXBkYXRlTGFuZXMiLCJyZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZyIsImNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmciLCJjb21taXRVcGRhdGVRdWV1ZSIsImZpbmlzaGVkV29yayIsImZpbmlzaGVkUXVldWUiLCJlZmZlY3QiLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImVtcHR5UmVmc09iamVjdCIsInJlZnMiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSIsImRpZFdhcm5PbkludmFsaWRDYWxsYmFjayIsImNhbGxlck5hbWUiLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImVucXVldWVTZXRTdGF0ZSIsInJlcXVlc3RFdmVudFRpbWUiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFN0YXRlIiwibmV4dENvbnRleHQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJzaG91bGRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNoZWNrQ2xhc3NJbnN0YW5jZSIsInJlbmRlclByZXNlbnQiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiX3N0YXRlIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwidXBkYXRlciIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwiaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIiLCJhZGRlbmR1bSIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiX2NvbXBvbmVudE5hbWUiLCJuZXdBcGlOYW1lIiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwiY29tcG9uZW50RGlkTW91bnQiLCJmaWJlckZsYWdzIiwicmVzdW1lTW91bnRDbGFzc0luc3RhbmNlIiwibWVtb2l6ZWRQcm9wcyIsIm9sZENvbnRleHQiLCJuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0IiwiaGFzTmV3TGlmZWN5Y2xlcyIsIl9maWJlckZsYWdzIiwiX2ZpYmVyRmxhZ3MyIiwidXBkYXRlQ2xhc3NJbnN0YW5jZSIsInVucmVzb2x2ZWRPbGRQcm9wcyIsImVsZW1lbnRUeXBlIiwidW5yZXNvbHZlZE5ld1Byb3BzIiwicGVuZGluZ1Byb3BzIiwibmV4dFVubWFza2VkQ29udGV4dCIsImZvcmtTdGFjayIsImZvcmtTdGFja0luZGV4IiwidHJlZUZvcmtQcm92aWRlciIsInRyZWVGb3JrQ291bnQiLCJpZFN0YWNrIiwiaWRTdGFja0luZGV4IiwidHJlZUNvbnRleHRQcm92aWRlciIsInRyZWVDb250ZXh0SWQiLCJ0cmVlQ29udGV4dE92ZXJmbG93IiwiaXNGb3JrZWRDaGlsZCIsIndhcm5JZk5vdEh5ZHJhdGluZyIsImdldEZvcmtzQXRMZXZlbCIsImdldFRyZWVJZCIsImlkV2l0aExlYWRpbmdCaXQiLCJnZXRMZWFkaW5nQml0IiwicHVzaFRyZWVGb3JrIiwidG90YWxDaGlsZHJlbiIsInB1c2hUcmVlSWQiLCJiYXNlSWRXaXRoTGVhZGluZ0JpdCIsImJhc2VPdmVyZmxvdyIsImJhc2VMZW5ndGgiLCJnZXRCaXRMZW5ndGgiLCJiYXNlSWQiLCJzbG90IiwibnVtYmVyT2ZPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvd0JpdHMiLCJuZXdPdmVyZmxvdyIsInJlc3RPZkJhc2VJZCIsInJlc3RPZkJhc2VMZW5ndGgiLCJyZXN0T2ZMZW5ndGgiLCJyZXN0T2ZOZXdCaXRzIiwibmV3Qml0cyIsIl9pZCIsIl9vdmVyZmxvdyIsInB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQiLCJyZXR1cm5GaWJlciIsIm51bWJlck9mRm9ya3MiLCJzbG90SW5kZXgiLCJwb3BUcmVlQ29udGV4dCIsImdldFN1c3BlbmRlZFRyZWVDb250ZXh0IiwicmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0Iiwic3VzcGVuZGVkQ29udGV4dCIsImdldElzSHlkcmF0aW5nIiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkU3VzcGVuZE9yRXJyb3JERVYiLCJoeWRyYXRpb25FcnJvcnMiLCJ3YXJuSWZIeWRyYXRpbmciLCJtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFViIsImVudGVySHlkcmF0aW9uU3RhdGUiLCJyZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJ0cmVlQ29udGV4dCIsIndhcm5Vbmh5ZHJhdGVkSW5zdGFuY2UiLCJkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UiLCJjaGlsZFRvRGVsZXRlIiwiY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24iLCJkZWxldGlvbnMiLCJ3YXJuTm9uaHlkcmF0ZWRJbnN0YW5jZSIsIl90ZXh0IiwiX2lzQ29uY3VycmVudE1vZGUiLCJfcGFyZW50SW5zdGFuY2UiLCJfdHlwZTIiLCJfcHJvcHMyIiwiX3RleHQyIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsInRyeUh5ZHJhdGUiLCJuZXh0SW5zdGFuY2UiLCJyZXRyeUxhbmUiLCJkZWh5ZHJhdGVkRnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQiLCJzaG91bGRDbGllbnRSZW5kZXJPbk1pc21hdGNoIiwidGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJmaXJzdEF0dGVtcHRlZEluc3RhbmNlIiwicHJldkh5ZHJhdGlvblBhcmVudEZpYmVyIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsInNob3VsZFdhcm5JZk1pc21hdGNoRGV2IiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UiLCJfaXNDb25jdXJyZW50TW9kZTIiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UiLCJza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwicG9wVG9OZXh0SG9zdFBhcmVudCIsInBvcEh5ZHJhdGlvblN0YXRlIiwid2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyIsImhhc1VuaHlkcmF0ZWRUYWlsTm9kZXMiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwidXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUiLCJxdWV1ZVJlY292ZXJhYmxlRXJyb3JzIiwicXVldWVIeWRyYXRpb25FcnJvciIsImRpZFdhcm5BYm91dE1hcHMiLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmcyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5Gb3JNaXNzaW5nS2V5IiwiX3N0b3JlIiwidmFsaWRhdGVkIiwiY29lcmNlUmVmIiwibWl4ZWRSZWYiLCJyZWYiLCJfc2VsZiIsInJlc29sdmVkSW5zdCIsInN0cmluZ1JlZiIsIl9zdHJpbmdSZWYiLCJ0aHJvd09uSW52YWxpZE9iamVjdFR5cGUiLCJuZXdDaGlsZCIsImNoaWxkU3RyaW5nIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwicmVzb2x2ZUxhenkiLCJsYXp5VHlwZSIsIkNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiY3JlYXRlRmliZXJGcm9tVGV4dCIsImV4aXN0aW5nIiwidXBkYXRlRWxlbWVudCIsInVwZGF0ZUZyYWdtZW50IiwiaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsInVwZGF0ZVBvcnRhbCIsInBvcnRhbCIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwiZnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiX2NyZWF0ZWQiLCJfY3JlYXRlZDIiLCJfY3JlYXRlZDMiLCJ1cGRhdGVTbG90Iiwib2xkRmliZXIiLCJ1cGRhdGVGcm9tTWFwIiwibmV3SWR4IiwibWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIyIiwiX21hdGNoZWRGaWJlcjMiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbnVtYmVyT2ZGb3JrcyIsIl9uZXdGaWJlcjIiLCJfbnVtYmVyT2ZGb3JrczIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwibmV3Q2hpbGRyZW5JdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJfbmV3Q2hpbGRyZW4iLCJfc3RlcCIsImRvbmUiLCJfbmV3RmliZXIzIiwiX251bWJlck9mRm9ya3MzIiwiX25ld0ZpYmVyNCIsIl9udW1iZXJPZkZvcmtzNCIsInJlY29uY2lsZVNpbmdsZVRleHROb2RlIiwicmVjb25jaWxlU2luZ2xlRWxlbWVudCIsIl9leGlzdGluZyIsIl9jcmVhdGVkNCIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCIsIm1vdW50Q2hpbGRGaWJlcnMiLCJjbG9uZUNoaWxkRmliZXJzIiwiY3VycmVudENoaWxkIiwicmVzZXRDaGlsZEZpYmVycyIsInJlc2V0V29ya0luUHJvZ3Jlc3MiLCJOT19DT05URVhUIiwiY29udGV4dFN0YWNrQ3Vyc29yJDEiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwicmVxdWlyZWRDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250YWluZXIiLCJyb290SW5zdGFuY2UiLCJwdXNoSG9zdENvbnRhaW5lciIsIm5leHRSb290SW5zdGFuY2UiLCJuZXh0Um9vdENvbnRleHQiLCJwb3BIb3N0Q29udGFpbmVyIiwiZ2V0SG9zdENvbnRleHQiLCJwdXNoSG9zdENvbnRleHQiLCJwb3BIb3N0Q29udGV4dCIsIkRlZmF1bHRTdXNwZW5zZUNvbnRleHQiLCJTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayIsIkludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCIsIkZvcmNlU3VzcGVuc2VGYWxsYmFjayIsInN1c3BlbnNlU3RhY2tDdXJzb3IiLCJoYXNTdXNwZW5zZUNvbnRleHQiLCJmbGFnIiwic2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQiLCJzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0Iiwic2hhbGxvd0NvbnRleHQiLCJhZGRTdWJ0cmVlU3VzcGVuc2VDb250ZXh0Iiwic3VidHJlZUNvbnRleHQiLCJwdXNoU3VzcGVuc2VDb250ZXh0IiwibmV3Q29udGV4dCIsInBvcFN1c3BlbnNlQ29udGV4dCIsInNob3VsZENhcHR1cmVTdXNwZW5zZSIsImhhc0ludmlzaWJsZVBhcmVudCIsImZpbmRGaXJzdFN1c3BlbmRlZCIsInJvdyIsInJldmVhbE9yZGVyIiwiZGlkU3VzcGVuZCIsIk5vRmxhZ3MkMSIsIkhhc0VmZmVjdCIsIkluc2VydGlvbiIsIkxheW91dCIsIlBhc3NpdmUkMSIsIndvcmtJblByb2dyZXNzU291cmNlcyIsInJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucyIsIm11dGFibGVTb3VyY2UiLCJfd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSIsInJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbiIsImdldFZlcnNpb24iLCJfZ2V0VmVyc2lvbiIsIm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEiLCJSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQyIiwiZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50IiwiZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIiwiY3VycmVudEhvb2siLCJ3b3JrSW5Qcm9ncmVzc0hvb2siLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzIiwibG9jYWxJZENvdW50ZXIiLCJnbG9iYWxDbGllbnRJZENvdW50ZXIiLCJSRV9SRU5ERVJfTElNSVQiLCJjdXJyZW50SG9va05hbWVJbkRldiIsImhvb2tUeXBlc0RldiIsImhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2IiwiaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMiLCJtb3VudEhvb2tUeXBlc0RldiIsImhvb2tOYW1lIiwidXBkYXRlSG9va1R5cGVzRGV2Iiwid2Fybk9uSG9va01pc21hdGNoSW5EZXYiLCJjaGVja0RlcHNBcmVBcnJheURldiIsImRlcHMiLCJjdXJyZW50SG9va05hbWUiLCJ0YWJsZSIsInNlY29uZENvbHVtblN0YXJ0Iiwib2xkSG9va05hbWUiLCJuZXdIb29rTmFtZSIsInRocm93SW52YWxpZEhvb2tFcnJvciIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJyZW5kZXJXaXRoSG9va3MiLCJzZWNvbmRBcmciLCJuZXh0UmVuZGVyTGFuZXMiLCJfZGVidWdIb29rVHlwZXMiLCJIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIm51bWJlck9mUmVSZW5kZXJzIiwiSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwiZGlkUmVuZGVyVG9vRmV3SG9va3MiLCJjaGVja0RpZFJlbmRlcklkSG9vayIsImRpZFJlbmRlcklkSG9vayIsImJhaWxvdXRIb29rcyIsInJlc2V0SG9va3NBZnRlclRocm93IiwiaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSIsIm1vdW50V29ya0luUHJvZ3Jlc3NIb29rIiwiYmFzZVF1ZXVlIiwidXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rIiwibmV4dEN1cnJlbnRIb29rIiwibmV4dFdvcmtJblByb2dyZXNzSG9vayIsIm5ld0hvb2siLCJjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwibGFzdEVmZmVjdCIsInN0b3JlcyIsImJhc2ljU3RhdGVSZWR1Y2VyIiwibW91bnRSZWR1Y2VyIiwicmVkdWNlciIsImluaXRpYWxBcmciLCJpbml0aWFsU3RhdGUiLCJkaXNwYXRjaCIsImxhc3RSZW5kZXJlZFJlZHVjZXIiLCJsYXN0UmVuZGVyZWRTdGF0ZSIsImRpc3BhdGNoUmVkdWNlckFjdGlvbiIsInVwZGF0ZVJlZHVjZXIiLCJiYXNlRmlyc3QiLCJwZW5kaW5nRmlyc3QiLCJmaXJzdCIsIm5ld0Jhc2VRdWV1ZUZpcnN0IiwibmV3QmFzZVF1ZXVlTGFzdCIsImhhc0VhZ2VyU3RhdGUiLCJlYWdlclN0YXRlIiwiaW50ZXJsZWF2ZWRMYW5lIiwicmVyZW5kZXJSZWR1Y2VyIiwibGFzdFJlbmRlclBoYXNlVXBkYXRlIiwiZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSIsIm1vdW50TXV0YWJsZVNvdXJjZSIsImdldFNuYXBzaG90Iiwic3Vic2NyaWJlIiwidXBkYXRlTXV0YWJsZVNvdXJjZSIsIm1vdW50U3luY0V4dGVybmFsU3RvcmUiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsIm5leHRTbmFwc2hvdCIsImNhY2hlZFNuYXBzaG90IiwiZ2V0V29ya0luUHJvZ3Jlc3NSb290IiwicHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayIsIm1vdW50RWZmZWN0Iiwic3Vic2NyaWJlVG9TdG9yZSIsInB1c2hFZmZlY3QiLCJ1cGRhdGVTdG9yZUluc3RhbmNlIiwidXBkYXRlU3luY0V4dGVybmFsU3RvcmUiLCJwcmV2U25hcHNob3QiLCJzbmFwc2hvdENoYW5nZWQiLCJ1cGRhdGVFZmZlY3QiLCJyZW5kZXJlZFNuYXBzaG90IiwiY2hlY2siLCJjb21wb25lbnRVcGRhdGVRdWV1ZSIsImNoZWNrSWZTbmFwc2hvdENoYW5nZWQiLCJmb3JjZVN0b3JlUmVyZW5kZXIiLCJoYW5kbGVTdG9yZUNoYW5nZSIsImxhdGVzdEdldFNuYXBzaG90IiwicHJldlZhbHVlIiwibW91bnRTdGF0ZSIsImRpc3BhdGNoU2V0U3RhdGUiLCJ1cGRhdGVTdGF0ZSIsInJlcmVuZGVyU3RhdGUiLCJkZXN0cm95IiwiZmlyc3RFZmZlY3QiLCJtb3VudFJlZiIsIl9yZWYyIiwidXBkYXRlUmVmIiwibW91bnRFZmZlY3RJbXBsIiwiaG9va0ZsYWdzIiwidXBkYXRlRWZmZWN0SW1wbCIsInByZXZFZmZlY3QiLCJtb3VudEluc2VydGlvbkVmZmVjdCIsInVwZGF0ZUluc2VydGlvbkVmZmVjdCIsIm1vdW50TGF5b3V0RWZmZWN0IiwidXBkYXRlTGF5b3V0RWZmZWN0IiwiaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdCIsInJlZkNhbGxiYWNrIiwiX2luc3QiLCJyZWZPYmplY3QiLCJfaW5zdDIiLCJtb3VudEltcGVyYXRpdmVIYW5kbGUiLCJlZmZlY3REZXBzIiwidXBkYXRlSW1wZXJhdGl2ZUhhbmRsZSIsIm1vdW50RGVidWdWYWx1ZSIsImZvcm1hdHRlckZuIiwidXBkYXRlRGVidWdWYWx1ZSIsIm1vdW50Q2FsbGJhY2siLCJ1cGRhdGVDYWxsYmFjayIsIm1vdW50TWVtbyIsIm5leHRDcmVhdGUiLCJ1cGRhdGVNZW1vIiwibW91bnREZWZlcnJlZFZhbHVlIiwidXBkYXRlRGVmZXJyZWRWYWx1ZSIsInJlc29sdmVkQ3VycmVudEhvb2siLCJ1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbCIsInJlcmVuZGVyRGVmZXJyZWRWYWx1ZSIsInNob3VsZERlZmVyVmFsdWUiLCJkZWZlcnJlZExhbmUiLCJzdGFydFRyYW5zaXRpb24iLCJzZXRQZW5kaW5nIiwiY3VycmVudFRyYW5zaXRpb24iLCJfdXBkYXRlZEZpYmVycyIsInVwZGF0ZWRGaWJlcnNDb3VudCIsIm1vdW50VHJhbnNpdGlvbiIsIl9tb3VudFN0YXRlIiwiaXNQZW5kaW5nIiwidXBkYXRlVHJhbnNpdGlvbiIsIl91cGRhdGVTdGF0ZSIsInJlcmVuZGVyVHJhbnNpdGlvbiIsIl9yZXJlbmRlclN0YXRlIiwiZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWIiwibW91bnRJZCIsImlkZW50aWZpZXJQcmVmaXgiLCJ0cmVlSWQiLCJsb2NhbElkIiwiZ2xvYmFsQ2xpZW50SWQiLCJ1cGRhdGVJZCIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUiLCJtYXJrVXBkYXRlSW5EZXZUb29scyIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZURlYnVnVmFsdWUiLCJ1c2VEZWZlcnJlZFZhbHVlIiwidXNlVHJhbnNpdGlvbiIsInVzZU11dGFibGVTb3VyY2UiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUlkIiwidW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJ3YXJuSW52YWxpZEhvb2tBY2Nlc3MiLCJub3ckMSIsImNvbW1pdFRpbWUiLCJsYXlvdXRFZmZlY3RTdGFydFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsInBhc3NpdmVFZmZlY3RTdGFydFRpbWUiLCJjdXJyZW50VXBkYXRlSXNOZXN0ZWQiLCJuZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJpc0N1cnJlbnRVcGRhdGVOZXN0ZWQiLCJtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwicmVzZXROZXN0ZWRVcGRhdGVGbGFnIiwic3luY05lc3RlZFVwZGF0ZUZsYWciLCJnZXRDb21taXRUaW1lIiwicmVjb3JkQ29tbWl0VGltZSIsInN0YXJ0UHJvZmlsZXJUaW1lciIsImFjdHVhbFN0YXJ0VGltZSIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSIsIm92ZXJyaWRlQmFzZVRpbWUiLCJhY3R1YWxEdXJhdGlvbiIsInNlbGZCYXNlRHVyYXRpb24iLCJyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbiIsInBhcmVudEZpYmVyIiwiZWZmZWN0RHVyYXRpb24iLCJwYXJlbnRTdGF0ZU5vZGUiLCJyZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJwYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJzdGFydExheW91dEVmZmVjdFRpbWVyIiwic3RhcnRQYXNzaXZlRWZmZWN0VGltZXIiLCJ0cmFuc2ZlckFjdHVhbER1cmF0aW9uIiwiY3JlYXRlQ2FwdHVyZWRWYWx1ZSIsInNob3dFcnJvckRpYWxvZyIsImJvdW5kYXJ5IiwiZXJyb3JJbmZvIiwibG9nQ2FwdHVyZWRFcnJvciIsImxvZ0Vycm9yIiwiY29tcG9uZW50U3RhY2siLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJjb21iaW5lZE1lc3NhZ2UiLCJQb3NzaWJseVdlYWtNYXAkMSIsImNyZWF0ZVJvb3RFcnJvclVwZGF0ZSIsIm9uVW5jYXVnaHRFcnJvciIsImNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUiLCJtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyIsImNvbXBvbmVudERpZENhdGNoIiwibWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCIsImF0dGFjaFBpbmdMaXN0ZW5lciIsInBpbmdDYWNoZSIsInRocmVhZElEcyIsInBpbmciLCJwaW5nU3VzcGVuZGVkUm9vdCIsInJlc3RvcmVQZW5kaW5nVXBkYXRlcnMiLCJhdHRhY2hSZXRyeUxpc3RlbmVyIiwic3VzcGVuc2VCb3VuZGFyeSIsIndha2VhYmxlcyIsInJlc2V0U3VzcGVuZGVkQ29tcG9uZW50Iiwic291cmNlRmliZXIiLCJyb290UmVuZGVyTGFuZXMiLCJjdXJyZW50U291cmNlIiwiZ2V0TmVhcmVzdFN1c3BlbnNlQm91bmRhcnlUb0NhcHR1cmUiLCJtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUiLCJjdXJyZW50U291cmNlRmliZXIiLCJ0aHJvd0V4Y2VwdGlvbiIsInJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUiLCJ1bmNhdWdodFN1c3BlbnNlRXJyb3IiLCJfc3VzcGVuc2VCb3VuZGFyeSIsInJlbmRlckRpZEVycm9yIiwiX2Vycm9ySW5mbyIsImlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkiLCJfbGFuZSIsIl91cGRhdGUiLCJnZXRTdXNwZW5kZWRDYWNoZSIsIm1hcmtVcGRhdGUiLCJtYXJrUmVmIiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwidXBkYXRlSG9zdENvbXBvbmVudCIsInVwZGF0ZUhvc3RUZXh0IiwibmVlZHNWaXNpYmlsaXR5VG9nZ2xlIiwiaXNIaWRkZW4iLCJjdXJyZW50SG9zdENvbnRleHQiLCJjdXRPZmZUYWlsSWZOZWVkZWQiLCJyZW5kZXJTdGF0ZSIsImhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayIsInRhaWxNb2RlIiwidGFpbE5vZGUiLCJ0YWlsIiwibGFzdFRhaWxOb2RlIiwiX3RhaWxOb2RlIiwiX2xhc3RUYWlsTm9kZSIsImJ1YmJsZVByb3BlcnRpZXMiLCJjb21wbGV0ZWRXb3JrIiwiZGlkQmFpbG91dCIsIm5ld0NoaWxkTGFuZXMiLCJzdWJ0cmVlRmxhZ3MiLCJ0cmVlQmFzZUR1cmF0aW9uIiwiX3RyZWVCYXNlRHVyYXRpb24iLCJfY2hpbGQyIiwiX2NoaWxkMyIsImNvbXBsZXRlV29yayIsImZpYmVyUm9vdCIsInBlbmRpbmdDb250ZXh0Iiwid2FzSHlkcmF0ZWQiLCJfd2FzSHlkcmF0ZWQiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2N1cnJlbnRIb3N0Q29udGV4dCIsIl93YXNIeWRyYXRlZDIiLCJfd2FzSHlkcmF0ZWQzIiwiaXNUaW1lZE91dFN1c3BlbnNlIiwicHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJfaXNUaW1lZE91dFN1c3BlbnNlIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50IiwibmV4dERpZFRpbWVvdXQiLCJwcmV2RGlkVGltZW91dCIsIl9wcmV2U3RhdGUiLCJfb2Zmc2NyZWVuRmliZXIyIiwiaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0IiwidW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2siLCJyZW5kZXJEaWRTdXNwZW5kIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50MiIsIl9Db21wb25lbnQiLCJkaWRTdXNwZW5kQWxyZWFkeSIsInJlbmRlcmVkVGFpbCIsImNhbm5vdEJlU3VzcGVuZGVkIiwicmVuZGVySGFzTm90U3VzcGVuZGVkWWV0Iiwic3VzcGVuZGVkIiwibmV3VGhlbmFibGVzIiwiZ2V0UmVuZGVyVGFyZ2V0VGltZSIsIl9zdXNwZW5kZWQiLCJfbmV3VGhlbmFibGVzIiwicmVuZGVyaW5nU3RhcnRUaW1lIiwiaXNCYWNrd2FyZHMiLCJsYXN0Iiwic3VzcGVuc2VDb250ZXh0IiwicG9wUmVuZGVyTGFuZXMiLCJfbmV4dFN0YXRlIiwibmV4dElzSGlkZGVuIiwiX3ByZXZTdGF0ZTIiLCJwcmV2SXNIaWRkZW4iLCJzdWJ0cmVlUmVuZGVyTGFuZXMiLCJSZWFjdEN1cnJlbnRPd25lciQxIiwiZGlkUmVjZWl2ZVVwZGF0ZSIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudCIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnMiLCJkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIiwiZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIiLCJkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwiZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZSIsInVwZGF0ZUZvcndhcmRSZWYiLCJpbm5lclByb3BUeXBlcyIsImhhc0lkIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsInVwZGF0ZU1lbW9Db21wb25lbnQiLCJpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50IiwiY29tcGFyZSIsInJlc29sdmVkVHlwZSIsInJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQiLCJjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMiLCJfaW5uZXJQcm9wVHlwZXMiLCJoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQiLCJjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCIsInByZXZQcm9wcyIsIm91dGVyTWVtb1R5cGUiLCJvdXRlclByb3BUeXBlcyIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50IiwiYmFzZUxhbmVzIiwiY2FjaGVQb29sIiwidHJhbnNpdGlvbnMiLCJwdXNoUmVuZGVyTGFuZXMiLCJzcGF3bmVkQ2FjaGVQb29sIiwibmV4dEJhc2VMYW5lcyIsInByZXZCYXNlTGFuZXMiLCJfbmV4dFN0YXRlMiIsIl9zdWJ0cmVlUmVuZGVyTGFuZXMiLCJ1cGRhdGVNb2RlIiwidXBkYXRlUHJvZmlsZXIiLCJtYXJrUmVmJDEiLCJ1cGRhdGVDbGFzc0NvbXBvbmVudCIsInNob3VsZEVycm9yIiwidGVtcEluc3RhbmNlIiwiaGFzQ29udGV4dCIsIm5leHRVbml0T2ZXb3JrIiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJkaWRDYXB0dXJlRXJyb3IiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJwcmV2Q2hpbGRyZW4iLCJvdmVycmlkZVN0YXRlIiwiY2FjaGUiLCJwZW5kaW5nU3VzcGVuc2VCb3VuZGFyaWVzIiwicmVjb3ZlcmFibGVFcnJvciIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwiX3JlY292ZXJhYmxlRXJyb3IiLCJ1cGRhdGVIb3N0Q29tcG9uZW50JDEiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0JDEiLCJtb3VudExhenlDb21wb25lbnQiLCJfY3VycmVudCIsInJlc29sdmVkVGFnIiwicmVzb2x2ZUxhenlDb21wb25lbnRUYWciLCJyZXNvbHZlZFByb3BzIiwicmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nIiwicmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmciLCJoaW50IiwibW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJfY29tcG9uZW50TmFtZTIiLCJkZWJ1Z1NvdXJjZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsIl9jb21wb25lbnROYW1lMyIsIl9jb21wb25lbnROYW1lNCIsIlNVU1BFTkRFRF9NQVJLRVIiLCJtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUiLCJ1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwicHJldk9mZnNjcmVlblN0YXRlIiwic2hvdWxkUmVtYWluT25GYWxsYmFjayIsImdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJzaG91bGRTdXNwZW5kIiwic2hvd0ZhbGxiYWNrIiwibW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQiLCJuZXh0UHJpbWFyeUNoaWxkcmVuIiwibmV4dEZhbGxiYWNrQ2hpbGRyZW4iLCJmYWxsYmFjayIsImZhbGxiYWNrRnJhZ21lbnQiLCJtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbiIsIm1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJfZGVoeWRyYXRlZCIsInVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCIsInJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4iLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4iLCJmYWxsYmFja0NoaWxkRnJhZ21lbnQiLCJtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyIsIl9uZXh0RmFsbGJhY2tDaGlsZHJlbjIiLCJfbmV4dFByaW1hcnlDaGlsZHJlbjIiLCJfZmFsbGJhY2tDaGlsZEZyYWdtZW50IiwidXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50MyIsIl9uZXh0UHJpbWFyeUNoaWxkcmVuMyIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDQiLCJ1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbiIsIl9uZXh0RmFsbGJhY2tDaGlsZHJlbjMiLCJfbmV4dFByaW1hcnlDaGlsZHJlbjQiLCJfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDUiLCJfcHJldk9mZnNjcmVlblN0YXRlIiwiX25leHRQcmltYXJ5Q2hpbGRyZW41IiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50NiIsInByaW1hcnlDaGlsZHJlbiIsInByaW1hcnlDaGlsZFByb3BzIiwibW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiZmFsbGJhY2tDaGlsZHJlbiIsInByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQiLCJvZmZzY3JlZW5Qcm9wcyIsImNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbiIsInVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50IiwiZmliZXJNb2RlIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSIsInJldHJ5IiwicmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeSIsInNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlciIsInByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSIsImZpbmRMYXN0Q29udGVudFJvdyIsImxhc3RDb250ZW50Um93IiwiY3VycmVudFJvdyIsInZhbGlkYXRlUmV2ZWFsT3JkZXIiLCJ2YWxpZGF0ZVRhaWxPcHRpb25zIiwidmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZCIsImNoaWxkU2xvdCIsImlzQW5BcnJheSIsImlzSXRlcmFibGUiLCJ2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuIiwiY2hpbGRyZW5JdGVyYXRvciIsImluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsInNob3VsZEZvcmNlRmFsbGJhY2siLCJkaWRTdXNwZW5kQmVmb3JlIiwiX3RhaWwiLCJuZXh0Um93IiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJwcm92aWRlclR5cGUiLCJwcm92aWRlclByb3BUeXBlcyIsIm9sZFZhbHVlIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyIiwidXBkYXRlQ29udGV4dENvbnN1bWVyIiwiQ29uc3VtZXIiLCJyZW1vdW50RmliZXIiLCJvbGRXb3JrSW5Qcm9ncmVzcyIsIm5ld1dvcmtJblByb2dyZXNzIiwicHJldlNpYmxpbmciLCJ1cGRhdGVMYW5lcyIsImF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlIiwiaGFzQ2hpbGRXb3JrIiwicHJpbWFyeUNoaWxkTGFuZXMiLCJfaGFzQ2hpbGRXb3JrIiwiYmVnaW5Xb3JrIiwiX2RlYnVnTmVlZHNSZW1vdW50IiwidW5yZXNvbHZlZFByb3BzIiwiX3VucmVzb2x2ZWRQcm9wcyIsIl9yZXNvbHZlZFByb3BzIiwiX3VucmVzb2x2ZWRQcm9wczIiLCJfcmVzb2x2ZWRQcm9wczIiLCJfdW5yZXNvbHZlZFByb3BzMyIsIl9yZXNvbHZlZFByb3BzMyIsIl9Db21wb25lbnQyIiwiX3VucmVzb2x2ZWRQcm9wczQiLCJfcmVzb2x2ZWRQcm9wczQiLCJ1bndpbmRXb3JrIiwiX2ZsYWdzIiwiX2ZsYWdzMiIsInVud2luZEludGVycnVwdGVkV29yayIsImludGVycnVwdGVkV29yayIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwib2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwib2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsIlBvc3NpYmx5V2Vha1NldCIsIldlYWtTZXQiLCJuZXh0RWZmZWN0IiwiaW5Qcm9ncmVzc0xhbmVzIiwiaW5Qcm9ncmVzc1Jvb3QiLCJyZXBvcnRVbmNhdWdodEVycm9ySW5ERVYiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInNhZmVseUNhbGxDb21taXRIb29rTGF5b3V0RWZmZWN0TGlzdE1vdW50IiwibmVhcmVzdE1vdW50ZWRBbmNlc3RvciIsImNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvciIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsInNhZmVseUNhbGxDb21wb25lbnREaWRNb3VudCIsInNhZmVseUF0dGFjaFJlZiIsImNvbW1pdEF0dGFjaFJlZiIsInNhZmVseURldGFjaFJlZiIsInJldFZhbCIsInNhZmVseUNhbGxEZXN0cm95IiwiZm9jdXNlZEluc3RhbmNlSGFuZGxlIiwic2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzIiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luIiwic2hvdWxkRmlyZSIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJzbmFwc2hvdCIsImRpZFdhcm5TZXQiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCIsInNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdCIsImNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMiLCJmaW5pc2hlZFJvb3QiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUiLCJvblBvc3RDb21taXQiLCJwaGFzZSIsImNvbW1pdExheW91dEVmZmVjdE9uRmliZXIiLCJjb21taXR0ZWRMYW5lcyIsIl91cGRhdGVRdWV1ZSIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZTIiLCJvbkNvbW1pdCIsIm9uUmVuZGVyIiwiZW5xdWV1ZVBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3QiLCJjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyIsInJlYXBwZWFyTGF5b3V0RWZmZWN0c09uRmliZXIiLCJoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbiIsImhvc3RTdWJ0cmVlUm9vdCIsImluc3RhbmNlVG9Vc2UiLCJkZXRhY2hGaWJlck11dGF0aW9uIiwiZGV0YWNoRmliZXJBZnRlckVmZmVjdHMiLCJob3N0SW5zdGFuY2UiLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwiY29tbWl0UGxhY2VtZW50IiwiYmVmb3JlIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlIiwiX3BhcmVudCIsIl9iZWZvcmUiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyIiwiaXNIb3N0IiwiaG9zdFBhcmVudCIsImhvc3RQYXJlbnRJc0NvbnRhaW5lciIsImNvbW1pdERlbGV0aW9uRWZmZWN0cyIsImRlbGV0ZWRGaWJlciIsImZpbmRQYXJlbnQiLCJjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyIsInByZXZIb3N0UGFyZW50IiwicHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciIsIl9wcmV2SG9zdFBhcmVudCIsIl9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyIiwiX2VmZmVjdCIsInByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwiY29tbWl0U3VzcGVuc2VDYWxsYmFjayIsImF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMiLCJyZXRyeUNhY2hlIiwicmVzb2x2ZVJldHJ5V2FrZWFibGUiLCJjb21taXRNdXRhdGlvbkVmZmVjdHMiLCJjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyIsInByZXZEZWJ1Z0ZpYmVyIiwiY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzIiwicHJldlJvb3RTdGF0ZSIsIm9mZnNjcmVlbkZpYmVyIiwid2FzSGlkZGVuIiwibWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrIiwiX3dhc0hpZGRlbiIsIl9uZXdTdGF0ZSIsIl9pc0hpZGRlbiIsIm9mZnNjcmVlbkJvdW5kYXJ5Iiwib2Zmc2NyZWVuQ2hpbGQiLCJkaXNhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luIiwiY29tbWl0TGF5b3V0RWZmZWN0cyIsImNvbW1pdExheW91dEVmZmVjdHNfYmVnaW4iLCJzdWJ0cmVlUm9vdCIsImlzTW9kZXJuUm9vdCIsIm5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsImNvbW1pdExheW91dE1vdW50RWZmZWN0c19jb21wbGV0ZSIsIm5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwicmVhcHBlYXJMYXlvdXRFZmZlY3RzX2JlZ2luIiwiZGlzYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZSIsInJlYXBwZWFyTGF5b3V0RWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMiLCJjb21taXR0ZWRUcmFuc2l0aW9ucyIsImNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNfYmVnaW4iLCJjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzX2NvbXBsZXRlIiwiY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlciIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c19iZWdpbiIsImZpYmVyVG9EZWxldGUiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luIiwicHJldmlvdXNGaWJlciIsImRldGFjaGVkQ2hpbGQiLCJkZXRhY2hlZFNpYmxpbmciLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNfY29tcGxldGUiLCJjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIiLCJkZWxldGVkU3VidHJlZVJvb3QiLCJjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlciIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUiLCJpbnZva2VMYXlvdXRFZmZlY3RNb3VudEluREVWIiwiaW52b2tlUGFzc2l2ZUVmZmVjdE1vdW50SW5ERVYiLCJpbnZva2VMYXlvdXRFZmZlY3RVbm1vdW50SW5ERVYiLCJpbnZva2VQYXNzaXZlRWZmZWN0VW5tb3VudEluREVWIiwiQ09NUE9ORU5UX1RZUEUiLCJIQVNfUFNFVURPX0NMQVNTX1RZUEUiLCJST0xFX1RZUEUiLCJURVNUX05BTUVfVFlQRSIsIlRFWFRfVFlQRSIsInN5bWJvbEZvciIsImNvbW1pdEhvb2tzIiwib25Db21taXRSb290JDEiLCJjb21taXRIb29rIiwiUmVhY3RDdXJyZW50QWN0UXVldWUiLCJpc0xlZ2FjeUFjdEVudmlyb25tZW50IiwiaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIiwiSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIiwiamVzdElzRGVmaW5lZCIsImplc3QiLCJpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCIsImNlaWwiLCJSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIiLCJSZWFjdEN1cnJlbnRPd25lciQyIiwiUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMyIsIlJlYWN0Q3VycmVudEFjdFF1ZXVlJDEiLCJOb0NvbnRleHQiLCJCYXRjaGVkQ29udGV4dCIsIlJlbmRlckNvbnRleHQiLCJDb21taXRDb250ZXh0IiwiUm9vdEluUHJvZ3Jlc3MiLCJSb290RmF0YWxFcnJvcmVkIiwiUm9vdEVycm9yZWQiLCJSb290U3VzcGVuZGVkIiwiUm9vdFN1c3BlbmRlZFdpdGhEZWxheSIsIlJvb3RDb21wbGV0ZWQiLCJSb290RGlkTm90Q29tcGxldGUiLCJleGVjdXRpb25Db250ZXh0Iiwid29ya0luUHJvZ3Jlc3NSb290Iiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMiLCJzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIiwid29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvciIsIndvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyIsIndvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzIiwiZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSIsIkZBTExCQUNLX1RIUk9UVExFX01TIiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSIsIkluZmluaXR5IiwiUkVOREVSX1RJTUVPVVRfTVMiLCJ3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIiwicmVzZXRSZW5kZXJUaW1lciIsImhhc1VuY2F1Z2h0RXJyb3IiLCJmaXJzdFVuY2F1Z2h0RXJyb3IiLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsInJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIiwicm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyIsInBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzIiwicGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsInJvb3RXaXRoTmVzdGVkVXBkYXRlcyIsImlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyIsImRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMiLCJORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQiLCJuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQiLCJyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzIiwiY3VycmVudEV2ZW50VGltZSIsImN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lIiwiaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0IiwiaXNUcmFuc2l0aW9uIiwiZXZlbnRMYW5lIiwicmVxdWVzdFJldHJ5TGFuZSIsImNoZWNrRm9yTmVzdGVkVXBkYXRlcyIsIm1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290Iiwid2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYiLCJ3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYiLCJtYXJrUm9vdFN1c3BlbmRlZCQxIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwiaXNCYXRjaGluZ0xlZ2FjeSIsInNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdCIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJleGlzdGluZ0NhbGxiYWNrTm9kZSIsImNhbGxiYWNrTm9kZSIsImNhbmNlbENhbGxiYWNrJDEiLCJjYWxsYmFja1ByaW9yaXR5IiwibmV3Q2FsbGJhY2tQcmlvcml0eSIsImV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSIsImZha2VBY3RDYWxsYmFja05vZGUiLCJuZXdDYWxsYmFja05vZGUiLCJkaWRTY2hlZHVsZUxlZ2FjeVVwZGF0ZSIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsInNjaGVkdWxlclByaW9yaXR5TGV2ZWwiLCJzY2hlZHVsZUNhbGxiYWNrJDEiLCJwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QiLCJkaWRUaW1lb3V0Iiwib3JpZ2luYWxDYWxsYmFja05vZGUiLCJkaWRGbHVzaFBhc3NpdmVFZmZlY3RzIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsInNob3VsZFRpbWVTbGljZSIsImV4aXRTdGF0dXMiLCJyZW5kZXJSb290Q29uY3VycmVudCIsInJlbmRlclJvb3RTeW5jIiwiZXJyb3JSZXRyeUxhbmVzIiwicmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3IiLCJmYXRhbEVycm9yIiwicHJlcGFyZUZyZXNoU3RhY2siLCJyZW5kZXJXYXNDb25jdXJyZW50IiwiaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzIiwiX2Vycm9yUmV0cnlMYW5lcyIsIl9mYXRhbEVycm9yIiwiZmluaXNoZWRMYW5lcyIsImZpbmlzaENvbmN1cnJlbnRSZW5kZXIiLCJlcnJvcnNGcm9tRmlyc3RBdHRlbXB0Iiwicm9vdFdvcmtJblByb2dyZXNzIiwiZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQiLCJlcnJvcnMiLCJjb21taXRSb290Iiwic2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWIiwibXNVbnRpbFRpbWVvdXQiLCJ0aW1lb3V0SGFuZGxlIiwiZXZlbnRUaW1lTXMiLCJ0aW1lRWxhcHNlZE1zIiwiX21zVW50aWxUaW1lb3V0Iiwiam5kIiwiY2hlY2tzIiwicmVuZGVyZWRWYWx1ZSIsImZsdXNoUm9vdCIsImJhdGNoZWRVcGRhdGVzJDEiLCJwcmV2RXhlY3V0aW9uQ29udGV4dCIsImRpc2NyZXRlVXBkYXRlcyIsImZsdXNoU3luYyIsImlzQWxyZWFkeVJlbmRlcmluZyIsImhhbmRsZUVycm9yIiwiZXJyb3JlZFdvcmsiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJ5ZXRBbm90aGVyVGhyb3duVmFsdWUiLCJwdXNoRGlzcGF0Y2hlciIsInBvcERpc3BhdGNoZXIiLCJ3b3JrTG9vcFN5bmMiLCJwZXJmb3JtVW5pdE9mV29yayIsIndvcmtMb29wQ29uY3VycmVudCIsInVuaXRPZldvcmsiLCJiZWdpbldvcmskMSIsIl9uZXh0Iiwic2libGluZ0ZpYmVyIiwicmVjb3ZlcmFibGVFcnJvcnMiLCJwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSIsImNvbW1pdFJvb3RJbXBsIiwicmVuZGVyUHJpb3JpdHlMZXZlbCIsImZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFViIsInN1YnRyZWVIYXNFZmZlY3RzIiwicm9vdEhhc0VmZmVjdCIsInJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMiLCJjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYiLCJvblJlY292ZXJhYmxlRXJyb3IiLCJyZW5kZXJQcmlvcml0eSIsImZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsIiwicHJvZmlsZXJFZmZlY3RzIiwiX2ZpYmVyIiwicHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QiLCJyb290RmliZXIiLCJ3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFViIsInJldHJ5VGltZWRPdXRCb3VuZGFyeSIsImJvdW5kYXJ5RmliZXIiLCJ0aW1lRWxhcHNlZCIsImhhc1Bhc3NpdmVFZmZlY3RzIiwiaW52b2tlRWZmZWN0c0luRGV2IiwiaW52b2tlRWZmZWN0Rm4iLCJwcmltYXJ5U3VidHJlZUZsYWciLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50IiwiZHVtbXlGaWJlciIsIm9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5IiwiYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYiLCJvcmlnaW5hbEVycm9yIiwicmVwbGF5RXJyb3IiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCIsInJlbmRlcmluZ0NvbXBvbmVudE5hbWUiLCJkZWR1cGVLZXkiLCJzZXRTdGF0ZUNvbXBvbmVudE5hbWUiLCJzY2hlZHVsaW5nRmliZXIiLCJwcmlvcml0eUxldmVsIiwiYWN0UXVldWUiLCJpc1J1bm5pbmciLCJyZXNvbHZlRmFtaWx5IiwiZmFpbGVkQm91bmRhcmllcyIsInNldFJlZnJlc2hIYW5kbGVyIiwiaGFuZGxlciIsImZhbWlseSIsImN1cnJlbnRSZW5kZXIiLCJzeW50aGV0aWNUeXBlIiwicHJldlR5cGUiLCJuZXh0VHlwZSIsIm5lZWRzQ29tcGFyZUZhbWlsaWVzIiwiJCR0eXBlb2ZOZXh0VHlwZSIsInByZXZGYW1pbHkiLCJzY2hlZHVsZVJlZnJlc2giLCJzdGFsZUZhbWlsaWVzIiwidXBkYXRlZEZhbWlsaWVzIiwic2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseSIsInNjaGVkdWxlUm9vdCIsInVwZGF0ZUNvbnRhaW5lciIsImNhbmRpZGF0ZVR5cGUiLCJuZWVkc1JlbmRlciIsIm5lZWRzUmVtb3VudCIsImZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCIsImZhbWlsaWVzIiwiaG9zdEluc3RhbmNlcyIsInR5cGVzIiwiZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5IiwiZGlkTWF0Y2giLCJmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5IiwiZm91bmRIb3N0SW5zdGFuY2VzIiwiZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5IiwiaGFzQmFkTWFwUG9seWZpbGwiLCJub25FeHRlbnNpYmxlT2JqZWN0IiwicHJldmVudEV4dGVuc2lvbnMiLCJGaWJlck5vZGUiLCJOYU4iLCJjcmVhdGVGaWJlciIsInNob3VsZENvbnN0cnVjdCQxIiwiY3VycmVudERlcGVuZGVuY2llcyIsImNyZWF0ZUhvc3RSb290RmliZXIiLCJpc1N0cmljdE1vZGUiLCJjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlIiwiZmliZXJUYWciLCJnZXRUYWciLCJjcmVhdGVGaWJlckZyb21Qcm9maWxlciIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlIiwiY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0IiwiZWxlbWVudHMiLCJwcmltYXJ5Q2hpbGRJbnN0YW5jZSIsImRlaHlkcmF0ZWROb2RlIiwicGVuZGluZ0NoaWxkcmVuIiwiRmliZXJSb290Tm9kZSIsImh5ZHJhdGUiLCJfZGVidWdSb290VHlwZSIsImNyZWF0ZUZpYmVyUm9vdCIsImluaXRpYWxDaGlsZHJlbiIsImh5ZHJhdGlvbkNhbGxiYWNrcyIsInRyYW5zaXRpb25DYWxsYmFja3MiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJfaW5pdGlhbFN0YXRlIiwiUmVhY3RWZXJzaW9uIiwiY3JlYXRlUG9ydGFsIiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsImRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiaG9zdEZpYmVyIiwiY3JlYXRlQ29udGFpbmVyIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwiY3VycmVudCQxIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiY29udGFpbmVyRmliZXIiLCJhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24kMSIsIm1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkIiwibWFya1JldHJ5TGFuZUltcGwiLCJhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsInNob3VsZEVycm9ySW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwiY29weVdpdGhEZWxldGVJbXBsIiwicGF0aCIsInVwZGF0ZWQiLCJjb3B5V2l0aERlbGV0ZSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZFBhdGgiLCJuZXdQYXRoIiwib2xkS2V5IiwibmV3S2V5IiwiY29weVdpdGhSZW5hbWUiLCJjb3B5V2l0aFNldEltcGwiLCJjb3B5V2l0aFNldCIsImZpbmRIb29rIiwibmV3U2hvdWxkRXJyb3JJbXBsIiwibmV3U2hvdWxkU3VzcGVuZEltcGwiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyIsImluamVjdEludG9EZXZUb29scyIsImRldlRvb2xzQ29uZmlnIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJidW5kbGVUeXBlIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsInJlbmRlcmVyQ29uZmlnIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJyZWNvbmNpbGVyVmVyc2lvbiIsImRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IiLCJyZXBvcnRFcnJvciIsIlJlYWN0RE9NUm9vdCIsImludGVybmFsUm9vdCIsIl9pbnRlcm5hbFJvb3QiLCJSZWFjdERPTUh5ZHJhdGlvblJvb3QiLCJpc1ZhbGlkQ29udGFpbmVyIiwidW5tb3VudCIsImNyZWF0ZVJvb3QiLCJ3YXJuSWZSZWFjdERPTUNvbnRhaW5lckluREVWIiwidW5zdGFibGVfc3RyaWN0TW9kZSIsInNjaGVkdWxlSHlkcmF0aW9uIiwidW5zdGFibGVfc2NoZWR1bGVIeWRyYXRpb24iLCJoeWRyYXRlUm9vdCIsIm11dGFibGVTb3VyY2VzIiwiaHlkcmF0ZWRTb3VyY2VzIiwiaXNWYWxpZENvbnRhaW5lckxlZ2FjeSIsIlJlYWN0Q3VycmVudE93bmVyJDMiLCJ0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzIiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsImhhc05vblJvb3RSZWFjdENoaWxkIiwibm9vcE9uUmVjb3ZlcmFibGVFcnJvciIsImxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyIiwiaXNIeWRyYXRpb25Db250YWluZXIiLCJvcmlnaW5hbENhbGxiYWNrIiwicm9vdFNpYmxpbmciLCJfb3JpZ2luYWxDYWxsYmFjayIsIl9yb290IiwiX3Jvb3RDb250YWluZXJFbGVtZW50Iiwid2Fybk9uSW52YWxpZENhbGxiYWNrJDEiLCJsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImZvcmNlSHlkcmF0ZSIsIm1heWJlUm9vdCIsImZpbmRET01Ob2RlIiwiY29tcG9uZW50T3JFbGVtZW50Iiwid2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJ1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImNvbnRhaW5lck5vZGUiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwicmVuZGVyZWRCeURpZmZlcmVudFJlYWN0IiwiX3Jvb3RFbCIsImlzQ29udGFpbmVyUmVhY3RSb290IiwiY3JlYXRlUG9ydGFsJDEiLCJyZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsIkludGVybmFscyIsInVzaW5nQ2xpZW50RW50cnlQb2ludCIsIkV2ZW50cyIsImNyZWF0ZVJvb3QkMSIsImh5ZHJhdGVSb290JDEiLCJmbHVzaFN5bmMkMSIsImZvdW5kRGV2VG9vbHMiLCJzZWxmIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicHJvdG9jb2wiLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wIiwibSIsIm8iLCJoIiwid2FybmluZyIsImNvbmQiLCJCcm93c2VyUm91dGVyIiwiYmFzZW5hbWUiLCJoaXN0b3J5UmVmIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJoaXN0b3J5Iiwic2V0U3RhdGUiLCJsaXN0ZW4iLCJSZWFjdC5jcmVhdGVFbGVtZW50IiwiUm91dGVyIiwibmF2aWdhdGlvblR5cGUiLCJIYXNoUm91dGVyIiwiY3JlYXRlSGFzaEhpc3RvcnkiLCJIaXN0b3J5Um91dGVyIiwiaXNNb2RpZmllZEV2ZW50IiwiTGluayIsIkxpbmtXaXRoUmVmIiwicmVsb2FkRG9jdW1lbnQiLCJyZXN0IiwidXNlSHJlZiIsImludGVybmFsT25DbGljayIsInVzZUxpbmtDbGlja0hhbmRsZXIiLCJoYW5kbGVDbGljayIsIk5hdkxpbmsiLCJOYXZMaW5rV2l0aFJlZiIsImFyaWFDdXJyZW50UHJvcCIsImNhc2VTZW5zaXRpdmUiLCJjbGFzc05hbWUiLCJjbGFzc05hbWVQcm9wIiwidXNlTG9jYXRpb24iLCJ1c2VSZXNvbHZlZFBhdGgiLCJsb2NhdGlvblBhdGhuYW1lIiwicGF0aG5hbWUiLCJ0b1BhdGhuYW1lIiwiaXNBY3RpdmUiLCJzdGFydHNXaXRoIiwiYXJpYUN1cnJlbnQiLCJyZXBsYWNlUHJvcCIsIm5hdmlnYXRlIiwidXNlTmF2aWdhdGUiLCJjcmVhdGVQYXRoIiwidXNlU2VhcmNoUGFyYW1zIiwiZGVmYXVsdEluaXQiLCJVUkxTZWFyY2hQYXJhbXMiLCJkZWZhdWx0U2VhcmNoUGFyYW1zUmVmIiwiY3JlYXRlU2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zIiwiZ2V0QWxsIiwiYXBwZW5kIiwic2V0U2VhcmNoUGFyYW1zIiwibmV4dEluaXQiLCJuYXZpZ2F0ZU9wdGlvbnMiLCJtZW1vIiwidiIsIk5hdmlnYXRpb25Db250ZXh0IiwiTG9jYXRpb25Db250ZXh0IiwiUm91dGVDb250ZXh0Iiwib3V0bGV0IiwibWF0Y2hlcyIsImludmFyaWFudCIsImFscmVhZHlXYXJuZWQiLCJ3YXJuaW5nT25jZSIsImdlbmVyYXRlUGF0aCIsInBhcmFtcyIsIm1hdGNoUm91dGVzIiwicm91dGVzIiwibG9jYXRpb25BcmciLCJwYXJzZVBhdGgiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaFJvdXRlQnJhbmNoIiwicGFyZW50c01ldGEiLCJwYXJlbnRQYXRoIiwicm91dGUiLCJyZWxhdGl2ZVBhdGgiLCJjaGlsZHJlbkluZGV4Iiwiam9pblBhdGhzIiwicm91dGVzTWV0YSIsInNjb3JlIiwiY29tcHV0ZVNjb3JlIiwiY29tcGFyZUluZGV4ZXMiLCJwYXJhbVJlIiwiZHluYW1pY1NlZ21lbnRWYWx1ZSIsImluZGV4Um91dGVWYWx1ZSIsImVtcHR5U2VnbWVudFZhbHVlIiwic3RhdGljU2VnbWVudFZhbHVlIiwic3BsYXRQZW5hbHR5IiwiaXNTcGxhdCIsInNlZ21lbnRzIiwiaW5pdGlhbFNjb3JlIiwic29tZSIsInNlZ21lbnQiLCJldmVyeSIsIm4iLCJicmFuY2giLCJtYXRjaGVkUGFyYW1zIiwibWF0Y2hlZFBhdGhuYW1lIiwicmVtYWluaW5nUGF0aG5hbWUiLCJtYXRjaFBhdGgiLCJwYXRobmFtZUJhc2UiLCJub3JtYWxpemVQYXRobmFtZSIsImNvbXBpbGVQYXRoIiwibWF0Y2hlciIsInBhcmFtTmFtZXMiLCJjYXB0dXJlR3JvdXBzIiwicGFyYW1OYW1lIiwic3BsYXRWYWx1ZSIsInNhZmVseURlY29kZVVSSUNvbXBvbmVudCIsImVuZHNXaXRoIiwicmVnZXhwU291cmNlIiwicmVzb2x2ZVBhdGgiLCJmcm9tUGF0aG5hbWUiLCJyZXNvbHZlUGF0aG5hbWUiLCJub3JtYWxpemVTZWFyY2giLCJub3JtYWxpemVIYXNoIiwicmVsYXRpdmVTZWdtZW50cyIsInJlc29sdmVUbyIsInRvQXJnIiwicm91dGVQYXRobmFtZXMiLCJyb3V0ZVBhdGhuYW1lSW5kZXgiLCJ0b1NlZ21lbnRzIiwiZ2V0VG9QYXRobmFtZSIsIm5leHRDaGFyIiwicGF0aHMiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJqb2luZWRQYXRobmFtZSIsImVuZHNXaXRoU2xhc2giLCJjcmVhdGVIcmVmIiwidXNlTmF2aWdhdGlvblR5cGUiLCJ1c2VNYXRjaCIsInJvdXRlUGF0aG5hbWVzSnNvbiIsImFjdGl2ZVJlZiIsImdvIiwiT3V0bGV0Q29udGV4dCIsInVzZU91dGxldENvbnRleHQiLCJ1c2VPdXRsZXQiLCJQcm92aWRlciIsInVzZVBhcmFtcyIsInJvdXRlTWF0Y2giLCJ1c2VSb3V0ZXMiLCJwYXJlbnRNYXRjaGVzIiwicGFyZW50UGFyYW1zIiwicGFyZW50UGF0aG5hbWUiLCJwYXJlbnRQYXRobmFtZUJhc2UiLCJwYXJlbnRSb3V0ZSIsImxvY2F0aW9uRnJvbUNvbnRleHQiLCJwYXJzZWRMb2NhdGlvbkFyZyIsIl9wYXJzZWRMb2NhdGlvbkFyZyRwYSIsIl9yZW5kZXJNYXRjaGVzIiwicmVkdWNlUmlnaHQiLCJNZW1vcnlSb3V0ZXIiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJOYXZpZ2F0ZSIsInN0YXRpYyIsIk91dGxldCIsIlJvdXRlIiwiX3JlZjMiLCJiYXNlbmFtZVByb3AiLCJsb2NhdGlvblByb3AiLCJOYXZpZ2F0aW9uVHlwZSIsIlBvcCIsInN0YXRpY1Byb3AiLCJuYXZpZ2F0aW9uQ29udGV4dCIsInRyYWlsaW5nUGF0aG5hbWUiLCJSb3V0ZXMiLCJfcmVmNCIsImNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiIsInJlbmRlck1hdGNoZXMiLCJlbmFibGVTY29wZUFQSSIsImVuYWJsZUNhY2hlRWxlbWVudCIsImVuYWJsZVRyYW5zaXRpb25UcmFjaW5nIiwiZW5hYmxlRGVidWdUcmFjaW5nIiwiY3VycmVudEV4dHJhU3RhY2tGcmFtZSIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCIsIndhcm5Ob29wIiwicHVibGljSW5zdGFuY2UiLCJfY29uc3RydWN0b3IiLCJSZWFjdE5vb3BVcGRhdGVRdWV1ZSIsImNvbXBsZXRlU3RhdGUiLCJlbXB0eU9iamVjdCIsImZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJmbk5hbWUiLCJDb21wb25lbnREdW1teSIsIlB1cmVDb21wb25lbnQiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiY3JlYXRlUmVmIiwic2VhbCIsIlJFU0VSVkVEX1BST1BTIiwiX19zZWxmIiwiX19zb3VyY2UiLCJzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biIsInNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5IiwiZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdLZXkiLCJkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlciIsIndhcm5BYm91dEFjY2Vzc2luZ1JlZiIsIndhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZCIsIlJlYWN0RWxlbWVudCIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImNsb25lQW5kUmVwbGFjZUtleSIsIm9sZEVsZW1lbnQiLCJuZXdFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnQiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJlc2NhcGUiLCJlc2NhcGVSZWdleCIsImVzY2FwZXJMb29rdXAiLCJlc2NhcGVkU3RyaW5nIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJnZXRFbGVtZW50S2V5IiwibWFwSW50b0FycmF5IiwiZXNjYXBlZFByZWZpeCIsIm5hbWVTb0ZhciIsImludm9rZUNhbGxiYWNrIiwibWFwcGVkQ2hpbGQiLCJjaGlsZEtleSIsImVzY2FwZWRDaGlsZEtleSIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJpdGVyYWJsZUNoaWxkcmVuIiwiaWkiLCJjaGlsZHJlblN0cmluZyIsIm1hcENoaWxkcmVuIiwiY291bnQiLCJjb3VudENoaWxkcmVuIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsInRvQXJyYXkiLCJvbmx5Q2hpbGQiLCJjcmVhdGVDb250ZXh0IiwiX2N1cnJlbnRWYWx1ZTIiLCJfdGhyZWFkQ291bnQiLCJfZGVmYXVsdFZhbHVlIiwiX2dsb2JhbE5hbWUiLCJoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyIsImhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyIiwiaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIiLCJfUHJvdmlkZXIiLCJfY3VycmVudFJlbmRlcmVyMiIsIlVuaW5pdGlhbGl6ZWQiLCJQZW5kaW5nIiwiUmVzb2x2ZWQiLCJSZWplY3RlZCIsImxhenlJbml0aWFsaXplciIsIl9zdGF0dXMiLCJfcmVzdWx0IiwidGhlbmFibGUiLCJtb2R1bGVPYmplY3QiLCJyZXNvbHZlZCIsInJlamVjdGVkIiwibGF6eSIsIm5ld0RlZmF1bHRQcm9wcyIsIm5ld1Byb3BUeXBlcyIsImZvcndhcmRSZWYiLCJvd25OYW1lIiwiUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImdldE1vZHVsZUlkIiwicmVzb2x2ZURpc3BhdGNoZXIiLCJkaXNwYXRjaGVyIiwiQ29udGV4dCIsInJlYWxDb250ZXh0Iiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMSIsInByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzIiwiZWxlbWVudFByb3BzIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJ2YWxpZFR5cGUiLCJzb3VyY2VJbmZvIiwidHlwZVN0cmluZyIsImRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5IiwiY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIiwidmFsaWRhdGVkRmFjdG9yeSIsImNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwiZGlkV2FybkFib3V0TWVzc2FnZUNoYW5uZWwiLCJlbnF1ZXVlVGFza0ltcGwiLCJlbnF1ZXVlVGFzayIsInRhc2siLCJyZXF1aXJlU3RyaW5nIiwibm9kZVJlcXVpcmUiLCJzZXRJbW1lZGlhdGUiLCJfZXJyIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3J0MiIsInBvc3RNZXNzYWdlIiwiYWN0U2NvcGVEZXB0aCIsImRpZFdhcm5Ob0F3YWl0QWN0IiwiYWN0IiwicHJldkFjdFNjb3BlRGVwdGgiLCJwcmV2SXNCYXRjaGluZ0xlZ2FjeSIsImZsdXNoQWN0UXVldWUiLCJwb3BBY3RTY29wZSIsInRoZW5hYmxlUmVzdWx0Iiwid2FzQXdhaXRlZCIsInJlamVjdCIsInJlY3Vyc2l2ZWx5Rmx1c2hBc3luY0FjdFdvcmsiLCJfcXVldWUiLCJfdGhlbmFibGUiLCJfdGhlbmFibGUyIiwiaXNGbHVzaGluZyIsImNyZWF0ZUVsZW1lbnQkMSIsImNsb25lRWxlbWVudCQxIiwiY3JlYXRlRmFjdG9yeSIsIm9ubHkiLCJTdHJpY3RNb2RlIiwiU3VzcGVuc2UiLCJ1bnN0YWJsZV9hY3QiLCJlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmciLCJlbmFibGVQcm9maWxpbmciLCJmcmFtZVlpZWxkTXMiLCJoZWFwIiwic2lmdFVwIiwicGVlayIsInNpZnREb3duIiwicGFyZW50SW5kZXgiLCJoYWxmTGVuZ3RoIiwibGVmdEluZGV4IiwicmlnaHRJbmRleCIsImRpZmYiLCJzb3J0SW5kZXgiLCJtYXJrVGFza0Vycm9yZWQiLCJtcyIsImhhc1BlcmZvcm1hbmNlTm93IiwicGVyZm9ybWFuY2UiLCJsb2NhbFBlcmZvcm1hbmNlIiwibG9jYWxEYXRlIiwiaW5pdGlhbFRpbWUiLCJtYXhTaWduZWQzMUJpdEludCIsIklNTUVESUFURV9QUklPUklUWV9USU1FT1VUIiwiVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUIiwiTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQiLCJMT1dfUFJJT1JJVFlfVElNRU9VVCIsIklETEVfUFJJT1JJVFlfVElNRU9VVCIsInRhc2tRdWV1ZSIsInRpbWVyUXVldWUiLCJ0YXNrSWRDb3VudGVyIiwiY3VycmVudFRhc2siLCJjdXJyZW50UHJpb3JpdHlMZXZlbCIsImlzUGVyZm9ybWluZ1dvcmsiLCJpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCIsImlzSG9zdFRpbWVvdXRTY2hlZHVsZWQiLCJsb2NhbFNldFRpbWVvdXQiLCJsb2NhbENsZWFyVGltZW91dCIsImxvY2FsU2V0SW1tZWRpYXRlIiwiaXNJbnB1dFBlbmRpbmciLCJzY2hlZHVsaW5nIiwiYWR2YW5jZVRpbWVycyIsInRpbWVyIiwic3RhcnRUaW1lIiwiaGFuZGxlVGltZW91dCIsInJlcXVlc3RIb3N0Q2FsbGJhY2siLCJmbHVzaFdvcmsiLCJmaXJzdFRpbWVyIiwicmVxdWVzdEhvc3RUaW1lb3V0IiwiaGFzVGltZVJlbWFpbmluZyIsImNhbmNlbEhvc3RUaW1lb3V0IiwicHJldmlvdXNQcmlvcml0eUxldmVsIiwid29ya0xvb3AiLCJpc1F1ZXVlZCIsInNob3VsZFlpZWxkVG9Ib3N0IiwiZGlkVXNlckNhbGxiYWNrVGltZW91dCIsImNvbnRpbnVhdGlvbkNhbGxiYWNrIiwidW5zdGFibGVfcnVuV2l0aFByaW9yaXR5IiwiZXZlbnRIYW5kbGVyIiwidW5zdGFibGVfbmV4dCIsInVuc3RhYmxlX3dyYXBDYWxsYmFjayIsInBhcmVudFByaW9yaXR5TGV2ZWwiLCJkZWxheSIsInRpbWVvdXQiLCJuZXdUYXNrIiwidW5zdGFibGVfcGF1c2VFeGVjdXRpb24iLCJ1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlIiwiaXNNZXNzYWdlTG9vcFJ1bm5pbmciLCJzY2hlZHVsZWRIb3N0Q2FsbGJhY2siLCJ0YXNrVGltZW91dElEIiwiZnJhbWVJbnRlcnZhbCIsImZvcmNlRnJhbWVSYXRlIiwiZnBzIiwiZmxvb3IiLCJwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUiLCJoYXNNb3JlV29yayIsInNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lIiwicG9ydCIsInVuc3RhYmxlX1Byb2ZpbGluZyIsInVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlIiwic2VwYXJhdG9yIiwic2VwYXJhdG9ySW5kZXgiLCJzdHIiLCJjaGFyQ29kZUF0IiwidCIsImRlbHRhIiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsInN1cHBvcnRlZEVudHJ5VHlwZXMiLCJnZXRFbnRyaWVzIiwib2JzZXJ2ZSIsImJ1ZmZlcmVkIiwidmlzaWJpbGl0eVN0YXRlIiwidSIsInBlcnNpc3RlZCIsImZpcnN0SGlkZGVuVGltZSIsImRpc2Nvbm5lY3QiLCJnZXRFbnRyaWVzQnlOYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicCIsImwiLCJoYWRSZWNlbnRJbnB1dCIsInRha2VSZWNvcmRzIiwiVCIsImciLCJ3IiwiRSIsImVudHJ5VHlwZSIsInByb2Nlc3NpbmdTdGFydCIsIlMiLCJMIiwiRiIsIm9uY2UiLCJQIiwiZ2V0RW50cmllc0J5VHlwZSIsInRpbWluZyIsIm5hdmlnYXRpb25TdGFydCIsInJlc3BvbnNlU3RhcnQiLCJyZWFkeVN0YXRlIiwiZ2V0Q0xTIiwiZ2V0RkNQIiwiZ2V0RklEIiwiZ2V0TENQIiwiZ2V0VFRGQiIsIl9leHRlbmRzIl0sInNvdXJjZVJvb3QiOiIifQ==